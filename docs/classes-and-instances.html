<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>类和实例 &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
        <h3><a href="#top">类和实例<small>27</small></a></h3>
    
    <ul>
        <li><a href="#class对象"><small>27.1</small> Class对象</a></li>
        <li><a href="#类声明"><small>27.2</small> 类声明</a></li>
        <li><a href="#类的实例"><small>27.3</small> 类的实例</a></li>
        <li><a href="#get和set表达式"><small>27.4</small> Get和SET表达式</a></li>
        <li class="divider"></li>
        <li class="end-part"><a href="#challenges">Challenges</a></li>
    </ul>
    
    
        <div class="prev-next">
        <a href="garbage-collection.html" title="垃圾回收" class="left">&larr;&nbsp;Previous</a>
        <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
        <a href="methods-and-initializers.html" title="方法和初始化" class="right">Next&nbsp;&rarr;</a>
    </div> </div>
</nav>

<nav class="narrow">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <a href="garbage-collection.html" title="垃圾回收" class="prev">←</a>
  <a href="methods-and-initializers.html" title="方法和初始化" class="next">→</a>
</nav>

<div class="page">
  <div class="nav-wrapper">
    <nav class="floating">
      <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
      <div class="expandable">
        <h3><a href="#top">类和实例<small>27</small></a></h3>
        
        <ul>
            <li><a href="#class对象"><small>27.1</small> Class对象</a></li>
            <li><a href="#类声明"><small>27.2</small> 类声明</a></li>
            <li><a href="#类的实例"><small>27.3</small> 类的实例</a></li>
            <li><a href="#get和set表达式"><small>27.4</small> Get和SET表达式</a></li>
            <li class="divider"></li>
            <li class="end-part"><a href="#challenges">Challenges</a></li>
        </ul>
        
        
                <div class="prev-next">
            <a href="garbage-collection.html" title="垃圾回收" class="left">&larr;&nbsp;Previous</a>
            <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
            <a href="methods-and-initializers.html" title="方法和初始化" class="right">Next&nbsp;&rarr;</a>
        </div>      </div>
      <a id="expand-nav">≡</a>
    </nav>
  </div>

  <article class="chapter">

    <div class="number">27</div>
    <h1>类和实例</h1>

    <blockquote>
<p>Caring too much for objects can destroy you. Only<span class="em">&mdash;</span>if you care for a thing
enough, it takes on a life of its own, doesn&rsquo;t it? And isn’t the whole point
of things<span class="em">&mdash;</span>beautiful things<span class="em">&mdash;</span>that they connect you to some larger beauty?</p>
<p>对物品过于关心会毁了你。只是，如果你对一件事物足够关心，它就有了自己的生命，不是吗？而事物<span class="em">&mdash;</span>美丽的事物<span class="em">&mdash;</span>的全部意义不就是把你和一些更大的美联系起来吗？</p>
<p><cite>Donna Tartt, <em>The Goldfinch</em></cite>
<cite>唐娜 塔特, <em>金翅雀</em></cite></p>
</blockquote>
<p>The last area left to implement in clox is object-oriented programming. <span
name="oop">OOP</span> is a bundle of intertwined features: classes, instances,
fields, methods, initializers, and inheritance. Using relatively high-level
Java, we packed all that into two chapters. Now that we&rsquo;re coding in C, which
feels like building a model of the Eiffel tower out of toothpicks, we&rsquo;ll devote
three chapters to covering the same territory. This makes for a leisurely stroll
through the implementation. After strenuous chapters like <a href="closures.html">closures</a> and the
<a href="garbage-collection.html">garbage collector</a>, you have earned a rest. In fact, the book should be easy
from here on out.
clox中需要实现的最后一个领域是面向对象编程。OOP是一堆交织在一起的特性：类、实例、字段、方法、初始化式和继承。使用相对高级的Java，我们可以把这些内容都装进两章中。现在我们用C语言编写代码，感觉就像用牙签搭建埃菲尔铁塔的模型，我们将用三章的篇幅来涵盖这些内容。这使得我们可以悠闲地漫步在实现中。在经历了闭包和垃圾回收器这样艰苦的章节之后，你赢得了休息的机会。事实上，从这里开始，这本书都是很容易的。</p>
<aside name="oop">
<p>People who have strong opinions about object-oriented programming<span class="em">&mdash;</span>read
&ldquo;everyone&rdquo;<span class="em">&mdash;</span>tend to assume OOP means some very specific list of language
features, but really there&rsquo;s a whole space to explore, and each language has its
own ingredients and recipes.
那些对面向对象编程有强烈看法的人<span class="em">&mdash;</span>读作“每个人”<span class="em">&mdash;</span>往往认为OOP意味着一些非常具体的语言特性清单，但实际上有一个完整的空间可以探索，而每种语言都有自己的成分和配方。</p>
<p>Self has objects but no classes. CLOS has methods but doesn&rsquo;t attach them to
specific classes. C++ initially had no runtime polymorphism<span class="em">&mdash;</span>no virtual
methods. Python has multiple inheritance, but Java does not. Ruby attaches
methods to classes, but you can also define methods on a single object.
Self有对象但没有类。CLOS有方法，当没有把它们附加到特定的类中。C++最初没有运行时多态<span class="em">&mdash;</span>没有虚方法。Python有多重继承，但Java没有。Ruby把方法附加在类上，但你也可以在单个对象上定义方法。</p>
</aside>
<p>In this chapter, we cover the first three features: classes, instances, and
fields. This is the stateful side of object orientation. Then in the next two
chapters, we will hang behavior and code reuse off of those objects.
在本章中，我们会介绍前三个特性：类、实例和字段。这就是面向对象中表现出状态的一面。然后在接下来的两章中，我们会对这些对象挂上行为和代码重用能力。</p>
<h2><a href="#class对象" id="class对象"><small>27&#8202;.&#8202;1</small>Class对象</a></h2>
<p>In a class-based object-oriented language, everything begins with classes. They
define what sorts of objects exist in the program and are the factories used to
produce new instances. Going bottom-up, we&rsquo;ll start with their runtime
representation and then hook that into the language.
在一门基于类的面向对象的语言中，一切都从类开始。它们定义了程序中存在什么类型的对象，并且它们也是用来生产新实例的工厂。自下向上，我们将从它们的运行时表示形式开始，然后将其挂接到语言中。</p>
<p>By this point, we&rsquo;re well-acquainted with the process of adding a new object
type to the VM. We start with a struct.
至此，我们已经非常熟悉向VM添加新对象类型的过程了。我们从一个结构体开始。</p>
<div class="codehilite"><pre class="insert-before">} ObjClosure;
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClosure</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjString</span>* <span class="i">name</span>;
} <span class="t">ObjClass</span>;
</pre><pre class="insert-after">

ObjClosure* newClosure(ObjFunction* function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClosure</em></div>

<p>After the Obj header, we store the class&rsquo;s name. This isn&rsquo;t strictly needed for
the user&rsquo;s program, but it lets us show the name at runtime for things like
stack traces.
在Obj头文件之后，我们存储了类的名称。对于用户的程序来说，这一信息并不是严格需要的，但是它让我们可以在运行时显示名称，例如堆栈跟踪。</p>
<p>The new type needs a corresponding case in the ObjType enum.
新类型需要在ObjType枚举中有一个对应的项。</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_CLASS</span>,
</pre><pre class="insert-after">  OBJ_CLOSURE,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>And that type gets a corresponding pair of macros. First, for testing an
object&rsquo;s type:
而该类型会有一组对应的宏。首先，用于测试对象的类型：</p>
<div class="codehilite"><pre class="insert-before">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_CLASS(value)        isObjType(value, OBJ_CLASS)</span>
</pre><pre class="insert-after">#define IS_CLOSURE(value)      isObjType(value, OBJ_CLOSURE)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>And then for casting a Value to an ObjClass pointer:
然后是用于将一个Value转换为一个ObjClass指针：</p>
<div class="codehilite"><pre class="insert-before">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_CLASS(value)        ((ObjClass*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_CLOSURE(value)      ((ObjClosure*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>The VM creates new class objects using this function:
VM使用这个函数创建新的类对象：</p>
<div class="codehilite"><pre class="insert-before">} ObjClass;

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClass</em></div>
<pre class="insert"><span class="t">ObjClass</span>* <span class="i">newClass</span>(<span class="t">ObjString</span>* <span class="i">name</span>);
</pre><pre class="insert-after">ObjClosure* newClosure(ObjFunction* function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>

<p>The implementation lives over here:
实现在这里：</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateObject</em>()</div>
<pre><span class="t">ObjClass</span>* <span class="i">newClass</span>(<span class="t">ObjString</span>* <span class="i">name</span>) {
  <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjClass</span>, <span class="a">OBJ_CLASS</span>);
  <span class="i">klass</span>-&gt;<span class="i">name</span> = <span class="i">name</span>;<span name="klass"> </span>
  <span class="k">return</span> <span class="i">klass</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>

<p>Pretty much all boilerplate. It takes in the class&rsquo;s name as a string and stores
it. Every time the user declares a new class, the VM will create a new one of
these ObjClass structs to represent it.
几乎都是模板代码。它接受并保存字符串形式的类名。每当用户声明一个新类时，VM会创建一个新的ObjClass结构体来表示它。</p>
<aside name="klass"><img src="image/classes-and-instances/klass.png" alt="'Klass' in a zany kidz font."/>
<p>I named the variable &ldquo;klass&rdquo; not just to give the VM a zany preschool &ldquo;Kidz
Korner&rdquo; feel. It makes it easier to get clox compiling as C++ where &ldquo;class&rdquo; is
a reserved word.
我将变量命名为“klass”，不仅仅是为了给虚拟机一种古怪的幼儿园的 &ldquo;Kidz Korner&rdquo; 感觉。它使得clox更容易被编译为C++，而C++中“class”是一个保留字。</p>
</aside>
<p>When the VM no longer needs a class, it frees it like so:
当VM不再需要某个类时，这样释放它：</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
      <span class="a">FREE</span>(<span class="t">ObjClass</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }<span name="braces"> </span>
</pre><pre class="insert-after">    case OBJ_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<aside name="braces">
<p>The braces here are pointless now, but will be useful in the next chapter when
we add some more code to the switch case.
这里的大括号现在没有意义，但在下一章我们为 switch case 添加更多代码时将会派上用场。</p>
</aside>
<p>We have a memory manager now, so we also need to support tracing through class
objects.
我们现在有一个内存管理器，所以我们也需要支持通过类对象进行跟踪。</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
      <span class="t">ObjClass</span>* <span class="i">klass</span> = (<span class="t">ObjClass</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">klass</span>-&gt;<span class="i">name</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>When the GC reaches a class object, it marks the class&rsquo;s name to keep that
string alive too.
当GC到达一个类对象时，它会标记该类的名称，以保持该字符串也能存活。</p>
<p>The last operation the VM can perform on a class is printing it.
VM可以对类执行的最后一个操作是打印它。</p>
<div class="codehilite"><pre class="insert-before">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>:
      <span class="i">printf</span>(<span class="s">&quot;%s&quot;</span>, <span class="a">AS_CLASS</span>(<span class="i">value</span>)-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_CLOSURE:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>A class simply says its own name.
类只是简单地说出它的名称。</p>
<h2><a href="#类声明" id="类声明"><small>27&#8202;.&#8202;2</small>类声明</a></h2>
<p>Runtime representation in hand, we are ready to add support for classes to the
language. Next, we move into the parser.
有了运行时表示形式，我们就可以向语言中添加对类的支持了。接下来，我们进入解释器。</p>
<div class="codehilite"><pre class="insert-before">static void declaration() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_CLASS</span>)) {
    <span class="i">classDeclaration</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FUN</span>)) {
</pre><pre class="insert-after">    funDeclaration();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>

<p>Class declarations are statements, and the parser recognizes one by the leading
<code>class</code> keyword. The rest of the compilation happens over here:
类声明是语句，解释器通过前面的<code>class</code>关键字识别声明语句。剩下部分的编译工作在这里进行：</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>function</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">classDeclaration</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">&quot;Expect class name.&quot;</span>);
  <span class="t">uint8_t</span> <span class="i">nameConstant</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
  <span class="i">declareVariable</span>();

  <span class="i">emitBytes</span>(<span class="a">OP_CLASS</span>, <span class="i">nameConstant</span>);
  <span class="i">defineVariable</span>(<span class="i">nameConstant</span>);

  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_BRACE</span>, <span class="s">&quot;Expect &#39;{&#39; before class body.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_BRACE</span>, <span class="s">&quot;Expect &#39;}&#39; after class body.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>function</em>()</div>

<p>Immediately after the <code>class</code> keyword is the class&rsquo;s name. We take that
identifier and add it to the surrounding function&rsquo;s constant table as a string.
As you just saw, printing a class shows its name, so the compiler needs to stuff
the name string somewhere that the runtime can find. The constant table is the
way to do that.
紧跟在<code>class</code>关键字之后的是类名。我们将这个标识符作为字符串添加到外围函数的常量表中。正如你刚才看到的，打印一个类会显示它的名称，所以编译器需要把这个名称字符串放在运行时可以找到的地方。常量表就是实现这一目的的方法。</p>
<p>The class&rsquo;s <span name="variable">name</span> is also used to bind the class
object to a variable of the same name. So we declare a variable with that
identifier right after consuming its token.
类名也被用来将类对象与一个同名变量绑定。因此，我们在使用完它的词法标识后，马上用这个标识符声明一个变量。</p>
<aside name="variable">
<p>We could have made class declarations be <em>expressions</em> instead of statements<span class="em">&mdash;</span>they are essentially a literal that produces a value after all. Then users would
have to explicitly bind the class to a variable themselves like:
我们可以让类声明成为表达式而不是语句<span class="em">&mdash;</span>比较它们本质上是一个产生值的字面量。然后用户必须自己显式地将类绑定到一个变量，比如：</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="t">Pie</span> = <span class="k">class</span> {}
</pre></div>
<p>Sort of like lambda functions but for classes. But since we generally want
classes to be named anyway, it makes sense to treat them as declarations.
这有点像lambda函数，但只是针对类的。但由于我们通常希望类被命名，所以将其视为声明是有意义的。</p>
</aside>
<p>Next, we emit a new instruction to actually create the class object at runtime.
That instruction takes the constant table index of the class&rsquo;s name as an
operand.
接下来我们发出一条新指令，在运行时实际创建类对象。该指令以类名的常量表索引作为操作数。</p>
<p>After that, but before compiling the body of the class, we define the variable
for the class&rsquo;s name. <em>Declaring</em> the variable adds it to the scope, but recall
from <a href="local-variables.html#another-scope-edge-case">a previous chapter</a> that we can&rsquo;t <em>use</em> the variable until it&rsquo;s
<em>defined</em>. For classes, we define the variable before the body. That way, users
can refer to the containing class inside the bodies of its own methods. That&rsquo;s
useful for things like factory methods that produce new instances of the class.
在此之后，但是在编译类主体之前，我们使用类名定义变量。<em>声明</em>变量会将其添加到作用域中，但请回想一下前一章的内容，在定义变量之前我们不能使用它。对于类，我们在解析主体之前定义变量。这样，用户就可以在类自己的方法主体中引用类本身。这对于产生类的新实例的工厂方法等场景来说是很有用的。</p>
<p>Finally, we compile the body. We don&rsquo;t have methods yet, so right now it&rsquo;s
simply an empty pair of braces. Lox doesn&rsquo;t require fields to be declared in the
class, so we&rsquo;re done with the body<span class="em">&mdash;</span>and the parser<span class="em">&mdash;</span>for now.
最后，我们编译主体。我们现在还没有方法，所以现在它只是一对空的大括号。Lox不要求在类中声明字段，因此我们目前已经完成了主体（和解析器）的工作。</p>
<p>The compiler is emitting a new instruction, so let&rsquo;s define that.
编译器会发出一条新指令，所以我们来定义它。</p>
<div class="codehilite"><pre class="insert-before">  OP_RETURN,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_CLASS</span>,
</pre><pre class="insert-after">} OpCode;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>And add it to the disassembler:
然后将其添加到反汇编程序中：</p>
<div class="codehilite"><pre class="insert-before">    case OP_RETURN:
      return simpleInstruction(&quot;OP_RETURN&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_CLASS</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_CLASS&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    default:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>For such a large-seeming feature, the interpreter support is minimal.
对于这样一个看起来很大的特性，解释器支持是最小的。</p>
<div class="codehilite"><pre class="insert-before">        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CLASS</span>:
        <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">newClass</span>(<span class="a">READ_STRING</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after">    }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We load the string for the class&rsquo;s name from the constant table and pass that to
<code>newClass()</code>. That creates a new class object with the given name. We push that
onto the stack and we&rsquo;re good. If the class is bound to a global variable, then
the compiler&rsquo;s call to <code>defineVariable()</code> will emit code to store that object
from the stack into the global variable table. Otherwise, it&rsquo;s right where it
needs to be on the stack for a new <span name="local">local</span> variable.
我们从常量表中加载类名的字符串，并将其传递给<code>newClass()</code>。这将创建一个具有给定名称的新类对象。我们把它推入栈中就可以了。如果该类被绑定到一个全局变量上，那么编译器对<code>defineVariable()</code>的调用就会生成字节码，将该对象从栈中存储到全局变量表。否则，它就正好位于栈中新的局部变量所在的位置。</p>
<aside name="local">
<p>&ldquo;Local&rdquo; classes<span class="em">&mdash;</span>classes declared inside the body of a function or block, are
an unusual concept. Many languages don&rsquo;t allow them at all. But since Lox is a
dynamically typed scripting language, it treats the top level of a program and
the bodies of functions and blocks uniformly. Classes are just another kind of
declaration, and since you can declare variables and functions inside blocks,
you can declare classes in there too.
“局部（Local）”类<span class="em">&mdash;</span>在函数或块主体中声明的类，是一个不寻常的概念。许多语言根本不允许这一特性。但由于Lox是一种动态类型脚本语言，它会对程序的顶层代码和函数以及块的主体进行统一处理。类只是另一种声明，既然你可以在块中声明变量和函数，那你也可以在块中声明类。</p>
</aside>
<p>There you have it, our VM supports classes now. You can run this:
好了，我们的虚拟机现在支持类了。你可以运行这段代码：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brioche</span> {}
<span class="k">print</span> <span class="t">Brioche</span>;
</pre></div>
<p>Unfortunately, printing is about <em>all</em> you can do with classes, so next is
making them more useful.
不幸的是，打印是你对类所能做的全部事情，所以接下来是让它们更有用。</p>
<h2><a href="#类的实例" id="类的实例"><small>27&#8202;.&#8202;3</small>类的实例</a></h2>
<p>Classes serve two main purposes in a language:
类在一门语言中主要有两个作用：</p>
<ul>
<li><strong>They are how you create new instances.</strong> Sometimes this involves a <code>new</code>
keyword, other times it&rsquo;s a method call on the class object, but you usually
mention the class by name <em>somehow</em> to get a new instance.</li>
<li><strong>They contain methods.</strong> These define how all instances of the class
behave.</li>
</ul>
<ul>
<li><strong>它们是你创建新实例的方式</strong>。有时这会涉及到<code>new</code>关键字，有时则是对类对象的方法调用，但是你通常会以某种方式通过类的名称来获得一个新的实例。</li>
<li><strong>它们包含方法</strong>。这些方法定义了类的所有实例的行为方式。</li>
</ul>
<p>We won&rsquo;t get to methods until the next chapter, so for now we will only worry
about the first part. Before classes can create instances, we need a
representation for them.
我们要到下一章才会讲到方法，所以我们现在只关心第一部分。在类能够创建实例之前，我们需要为它们提供一个表示形式。</p>
<div class="codehilite"><pre class="insert-before">} ObjClass;
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClass</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjClass</span>* <span class="i">klass</span>;
  <span class="t">Table</span> <span class="i">fields</span>;<span name="fields"> </span>
} <span class="t">ObjInstance</span>;
</pre><pre class="insert-after">

ObjClass* newClass(ObjString* name);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>

<p>Instances know their class<span class="em">&mdash;</span>each instance has a pointer to the class that it
is an instance of.  We won&rsquo;t use this much in this chapter, but it will become
critical when we add methods.
实例知道它们的类<span class="em">&mdash;</span>每个实例都有一个指向它所属类的指针。在本章中我们不会过多地使用它，但是等我们添加方法时，它将会变得非常重要。</p>
<p>More important to this chapter is how instances store their state. Lox lets
users freely add fields to an instance at runtime. This means we need a storage
mechanism that can grow. We could use a dynamic array, but we also want to look
up fields by name as quickly as possible. There&rsquo;s a data structure that&rsquo;s just
perfect for quickly accessing a set of values by name and<span class="em">&mdash;</span>even more conveniently<span class="em">&mdash;</span>we&rsquo;ve already implemented it. Each instance stores
its fields using a hash table.
对本章来说，更重要的是实例如何存储它们的状态。Lox允许用户在运行时自由地向实例中添加字段。这意味着我们需要一种可以增长的存储机制。我们可以使用动态数组，但我们也希望尽可能快地按名称查找字段。有一种数据结构非常适合于按名称快速访问一组值<span class="em">&mdash;</span>甚至更方便的是<span class="em">&mdash;</span>我们已经实现了它。每个实例都使用哈希表来存储其字段。</p>
<aside name="fields">
<p>Being able to freely add fields to an object at runtime is a big practical
difference between most dynamic and static languages. Statically typed languages
usually require fields to be explicitly declared. This way, the compiler knows
exactly what fields each instance has. It can use that to determine the precise
amount of memory needed for each instance and the offsets in that memory where
each field can be found.
能够在运行时自由地向对象添加字段，是大多数动态语言和静态语言之间的一个很大的实际区别。静态类型语言通常要求显式声明字段。这样，编译器就确切知道每个实例有哪些字段。它可以利用这一点来确定每个实例所需的精确内存量，以及每个字段在内存中的偏移量。</p>
<p>In Lox and other dynamic languages, accessing a field is usually a hash table
lookup. Constant time, but still pretty heavyweight. In a language like C++,
accessing a field is as fast as offsetting a pointer by an integer constant.
在Lox和其它动态语言中，访问字段通常是一次哈希表查询。常量时间复杂度，但仍然是相当重的。在C++这样的语言中，访问一个字段就像对指针偏移一个整数常量一样快。</p>
</aside>
<p>We only need to add an include, and we&rsquo;ve got it.
我们只需要添加一个头文件引入，就可以了。</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#include &quot;table.h&quot;</span>
</pre><pre class="insert-after">#include &quot;value.h&quot;
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>This new struct gets a new object type.
新结构体有新的对象类型。</p>
<div class="codehilite"><pre class="insert-before">  OBJ_FUNCTION,
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_INSTANCE</span>,
</pre><pre class="insert-after">  OBJ_NATIVE,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>I want to slow down a bit here because the Lox <em>language&rsquo;s</em> notion of &ldquo;type&rdquo; and
the VM <em>implementation&rsquo;s</em> notion of &ldquo;type&rdquo; brush against each other in ways that
can be confusing. Inside the C code that makes clox, there are a number of
different types of Obj<span class="em">&mdash;</span>ObjString, ObjClosure, etc. Each has its own internal
representation and semantics.
这里我想放慢一点速度，因为Lox<em>语言</em>中的“type”概念和<em>虚拟机实现</em>中的“type”概念是相互抵触的，可能会造成混淆。在生成clox 的C语言代码中，有许多不同类型的Obj<span class="em">&mdash;</span>ObjString、ObjClosure等等。每个都有自己的内部表示和语义。</p>
<p>In the Lox <em>language</em>, users can define their own classes<span class="em">&mdash;</span>say Cake and Pie<span class="em">&mdash;</span>and then create instances of those classes. From the user&rsquo;s perspective, an
instance of Cake is a different type of object than an instance of Pie. But,
from the VM&rsquo;s perspective, every class the user defines is simply another value
of type ObjClass. Likewise, each instance in the user&rsquo;s program, no matter what
class it is an instance of, is an ObjInstance. That one VM object type covers
instances of all classes. The two worlds map to each other something like this:
在Lox<em>语言</em>中，用户可以定义自己的类<span class="em">&mdash;</span>比如Cake和Pie<span class="em">&mdash;</span>然后创建这些类的实例。从用户的角度来看，Cake实例与Pie实例是不同类型的对象。但是，从虚拟机的角度来看，用户定义的每个类都只是另一个ObjClass类型的值。同样，用户程序中的每个实例，无论它是什么类的实例，都是一个ObjInstance。这一虚拟机对象类型涵盖了所有类的实例。这两个世界之间的映射是这样的：</p><img src="image/classes-and-instances/lox-clox.png" alt="A set of class declarations and instances, and the runtime representations each maps to."/>
<p>Got it? OK, back to the implementation. We also get our usual macros.
明白了吗？好了，回到实现中。我们新增了一些熟悉的宏。</p>
<div class="codehilite"><pre class="insert-before">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_INSTANCE(value)     isObjType(value, OBJ_INSTANCE)</span>
</pre><pre class="insert-after">#define IS_NATIVE(value)       isObjType(value, OBJ_NATIVE)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>And:</p>
<div class="codehilite"><pre class="insert-before">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_INSTANCE(value)     ((ObjInstance*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_NATIVE(value) \
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Since fields are added after the instance is created, the &ldquo;constructor&rdquo; function
only needs to know the class.
因为字段是在实例创建之后添加的，所以“构造器”函数只需要知道类。</p>
<div class="codehilite"><pre class="insert-before">ObjFunction* newFunction();
</pre><div class="source-file"><em>object.h</em><br>
add after <em>newFunction</em>()</div>
<pre class="insert"><span class="t">ObjInstance</span>* <span class="i">newInstance</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>);
</pre><pre class="insert-after">ObjNative* newNative(NativeFn function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>newFunction</em>()</div>

<p>We implement that function here:
我们在这里实现该函数：</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>newFunction</em>()</div>
<pre><span class="t">ObjInstance</span>* <span class="i">newInstance</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>) {
  <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjInstance</span>, <span class="a">OBJ_INSTANCE</span>);
  <span class="i">instance</span>-&gt;<span class="i">klass</span> = <span class="i">klass</span>;
  <span class="i">initTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
  <span class="k">return</span> <span class="i">instance</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>newFunction</em>()</div>

<p>We store a reference to the instance&rsquo;s class. Then we initialize the field
table to an empty hash table. A new baby object is born!
我们存储了对实例的类的引用。然后我们将字段表初始化为一个空的哈希表。一个全新的对象诞生了！</p>
<p>At the sadder end of the instance&rsquo;s lifespan, it gets freed.
在实例生命周期的最后阶段，它被释放了。</p>
<div class="codehilite"><pre class="insert-before">      FREE(ObjFunction, object);
      break;
    }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>: {
      <span class="t">ObjInstance</span>* <span class="i">instance</span> = (<span class="t">ObjInstance</span>*)<span class="i">object</span>;
      <span class="i">freeTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
      <span class="a">FREE</span>(<span class="t">ObjInstance</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>The instance owns its field table so when freeing the instance, we also free the
table. We don&rsquo;t explicitly free the entries <em>in</em> the table, because there may
be other references to those objects. The garbage collector will take care of
those for us. Here we free only the entry array of the table itself.
实例拥有自己的字段表，所以当释放实例时，我们也会释放该表。我们没有显式地释放表中的条目，因为可能存在对这些对象的其它引用。垃圾回收器会帮我们处理这些问题。这里我们只释放表本身的条目数组。</p>
<p>Speaking of the garbage collector, it needs support for tracing through
instances.
说到垃圾回收，它需要支持通过实例进行跟踪。</p>
<div class="codehilite"><pre class="insert-before">      markArray(&amp;function-&gt;chunk.constants);
      break;
    }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>: {
      <span class="t">ObjInstance</span>* <span class="i">instance</span> = (<span class="t">ObjInstance</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">instance</span>-&gt;<span class="i">klass</span>);
      <span class="i">markTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_UPVALUE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>If the instance is alive, we need to keep its class around. Also, we need to
keep every object referenced by the instance&rsquo;s fields. Most live objects that
are not roots are reachable because some instance refers to the object in a
field. Fortunately, we already have a nice <code>markTable()</code> function to make
tracing them easy.
如果这个实例是活动的，我们需要保留它的类。此外，我们还需要保留每个被实例字段引用的对象。大多数不是根的活动对象都是可达的，因为某些实例会在某个字段中引用该对象。幸运的是，我们已经有了一个很好的<code>markTable()</code>函数，可以轻松地跟踪它们。</p>
<p>Less critical but still important is printing.
不太关键但仍然重要的是打印。</p>
<div class="codehilite"><pre class="insert-before">      break;
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>:
      <span class="i">printf</span>(<span class="s">&quot;%s instance&quot;</span>,
             <span class="a">AS_INSTANCE</span>(<span class="i">value</span>)-&gt;<span class="i">klass</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p><span name="print">An</span> instance prints its name followed by &ldquo;instance&rdquo;.
(The &ldquo;instance&rdquo; part is mainly so that classes and instances don&rsquo;t print the
same.)
实例会打印它的名称，并在后面加上“instance”。（“instance”部分主要是为了使类和实例不会打印出相同的内容）</p>
<aside name="print">
<p>Most object-oriented languages let a class define some sort of <code>toString()</code>
method that lets the class specify how its instances are converted to a string
and printed. If Lox was less of a toy language, I would want to support that
too.
大多数面向对象的语言允许类定义某种形式的<code>toString()</code>方法，让该类指定如何将其实例转换为字符串并打印出来。如果Lox部署一门玩具语言，我也想要支持它。</p>
</aside>
<p>The real fun happens over in the interpreter. Lox has no special <code>new</code> keyword.
The way to create an instance of a class is to invoke the class itself as if it
were a function. The runtime already supports function calls, and it checks the
type of object being called to make sure the user doesn&rsquo;t try to invoke a number
or other invalid type.
真正有趣的部分在解释器中，Lox没有特殊的<code>new</code>关键字。创建类实例的方法是调用类本身，就像调用函数一样。运行时已经支持函数调用，它会检查被调用对象的类型，以确保用户不会试图调用数字或其它无效类型。</p>
<p>We extend that runtime checking with a new case.
我们用一个新的case分支来扩展运行时的检查。</p>
<div class="codehilite"><pre class="insert-before">    switch (OBJ_TYPE(callee)) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
        <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">AS_CLASS</span>(<span class="i">callee</span>);
        <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="i">argCount</span> - <span class="n">1</span>] = <span class="a">OBJ_VAL</span>(<span class="i">newInstance</span>(<span class="i">klass</span>));
        <span class="k">return</span> <span class="k">true</span>;
      }
</pre><pre class="insert-after">      case OBJ_CLOSURE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>If the value being called<span class="em">&mdash;</span>the object that results when evaluating the
expression to the left of the opening parenthesis<span class="em">&mdash;</span>is a class, then we treat
it as a constructor call. We <span name="args">create</span> a new instance of
the called class and store the result on the stack.
如果被调用的值（在左括号左边的表达式求值得到的对象）是一个类，则将其视为一个构造函数调用。我们创建一个被调用类的新实例，并将结果存储在栈中。</p>
<aside name="args">
<p>We ignore any arguments passed to the call for now. We&rsquo;ll revisit this code in
the <a href="methods-and-initializers.html">next chapter</a> when we add support for initializers.
我们暂时忽略传递给调用的所有参数。在下一章添加对初始化器的支持时，我们会重新审视这一段代码。</p>
</aside>
<p>We&rsquo;re one step farther. Now we can define classes and create instances of them.
我们又前进了一步。现在我们可以定义类并创建它们的实例了。</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brioche</span> {}
<span class="k">print</span> <span class="t">Brioche</span>();
</pre></div>
<p>Note the parentheses after <code>Brioche</code> on the second line now. This prints
&ldquo;Brioche instance&rdquo;.
注意第二行<code>Brioche</code>后面的括号。这里会打印“Brioche instance”。</p>
<h2><a href="#get和set表达式" id="get和set表达式"><small>27&#8202;.&#8202;4</small>Get和SET表达式</a></h2>
<p>Our object representation for instances can already store state, so all that
remains is exposing that functionality to the user. Fields are accessed and
modified using get and set expressions. Not one to break with tradition, Lox
uses the classic &ldquo;dot&rdquo; syntax:
实例的对象表示形式已经可以存储状态了，所以剩下的就是把这个功能暴露给用户。字段是使用get和set表达式进行访问和修改的。Lox并不喜欢打破传统，这里也沿用了经典的“点”语法：</p>
<div class="codehilite"><pre><span class="i">eclair</span>.<span class="i">filling</span> = <span class="s">&quot;pastry creme&quot;</span>;
<span class="k">print</span> <span class="i">eclair</span>.<span class="i">filling</span>;
</pre></div>
<p>The period<span class="em">&mdash;</span>full stop for my English friends<span class="em">&mdash;</span>works <span
name="sort">sort</span> of like an infix operator. There is an expression to the
left that is evaluated first and produces an instance. After that is the <code>.</code>
followed by a field name. Since there is a preceding operand, we hook this into
the parse table as an infix expression.
句号<span class="em">&mdash;</span>对英国朋友来说是句号<span class="em">&mdash;</span>其作用有点像一个中缀运算符。左边有一个表达式，首先被求值并产生一个实例。之后是<code>.</code>后跟一个字段名称。由于前面有一个操作数，我们将其作为中缀表达式放到解析表中。</p>
<aside name="sort">
<p>I say &ldquo;sort of&rdquo; because the right-hand side after the <code>.</code> is not an expression,
but a single identifier whose semantics are handled by the get or set expression
itself. It&rsquo;s really closer to a postfix expression.
我说“有点”是因为<code>.</code>右边的不是表达式，而是一个标识符，其语义由get或set表达式本身来处理。它实际上更接近于一个后缀表达式。</p>
</aside>
<div class="codehilite"><pre class="insert-before">  [TOKEN_COMMA]         = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_DOT</span>]           = {<span class="a">NULL</span>,     <span class="i">dot</span>,    <span class="a">PREC_CALL</span>},
</pre><pre class="insert-after">  [TOKEN_MINUS]         = {unary,    binary, PREC_TERM},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>As in other languages, the <code>.</code> operator binds tightly, with precedence as high
as the parentheses in a function call. After the parser consumes the dot token,
it dispatches to a new parse function.
和其它语言一样，<code>.</code>操作符绑定紧密，其优先级和函数调用中的括号一样高。解析器消费了点标识之后，会分发给一个新的解析函数。</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>call</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">dot</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">&quot;Expect property name after &#39;.&#39;.&quot;</span>);
  <span class="t">uint8_t</span> <span class="i">name</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);

  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
    <span class="i">emitBytes</span>(<span class="a">OP_SET_PROPERTY</span>, <span class="i">name</span>);
  } <span class="k">else</span> {
    <span class="i">emitBytes</span>(<span class="a">OP_GET_PROPERTY</span>, <span class="i">name</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>call</em>()</div>

<p>The parser expects to find a <span name="prop">property</span> name immediately
after the dot. We load that token&rsquo;s lexeme into the constant table as a string
so that the name is available at runtime.
解析器希望在点运算符后面立即找到一个属性名称。我们将该词法标识的词素作为字符串加载到常量表中，这样该名称在运行时就是可用的。</p>
<aside name="prop">
<p>The compiler uses &ldquo;property&rdquo; instead of &ldquo;field&rdquo; here because, remember, Lox also
lets you use dot syntax to access a method without calling it. &ldquo;Property&rdquo; is the
general term we use to refer to any named entity you can access on an instance.
Fields are the subset of properties that are backed by the instance&rsquo;s state.
编译器在这里使用“属性（property）”而不是“字段（field）”，因为，请记住，Lox还允许你使用点语法来访问一个方法而不调用它。“属性”是一个通用术语，我们用来指代可以在实例上访问的任何命名实体。字段是基于实例状态的属性子集。</p>
</aside>
<p>We have two new expression forms<span class="em">&mdash;</span>getters and setters<span class="em">&mdash;</span>that this one
function handles. If we see an equals sign after the field name, it must be a
set expression that is assigning to a field. But we don&rsquo;t <em>always</em> allow an
equals sign after the field to be compiled. Consider:
我们将两种新的表达式形式<span class="em">&mdash;</span>getter和setter<span class="em">&mdash;</span>都交由这一个函数处理。如果我们看到字段名称后有一个等号，那么它一定是一个赋值给字段的set表达式。但我们并不总是允许编译字段后面的等号。考虑一下：</p>
<div class="codehilite"><pre><span class="i">a</span> + <span class="i">b</span>.<span class="i">c</span> = <span class="n">3</span>
</pre></div>
<p>This is syntactically invalid according to Lox&rsquo;s grammar, which means our Lox
implementation is obligated to detect and report the error. If <code>dot()</code> silently
parsed the <code>= 3</code> part, we would incorrectly interpret the code as if the user
had written:
根据Lox的文法，这在语法上是无效的，这意味着我们的Lox实现有义务检测和报告这个错误。如果<code>dot()</code>默默地解析<code>=3</code>的部分，我们就会错误地解释代码，就像用户写的是：</p>
<div class="codehilite"><pre><span class="i">a</span> + (<span class="i">b</span>.<span class="i">c</span> = <span class="n">3</span>)
</pre></div>
<p>The problem is that the <code>=</code> side of a set expression has much lower precedence
than the <code>.</code> part. The parser may call <code>dot()</code> in a context that is too high
precedence to permit a setter to appear. To avoid incorrectly allowing that, we
parse and compile the equals part only when <code>canAssign</code> is true. If an equals
token appears when <code>canAssign</code> is false, <code>dot()</code> leaves it alone and returns. In
that case, the compiler will eventually unwind up to <code>parsePrecedence()</code>, which
stops at the unexpected <code>=</code> still sitting as the next token and reports an
error.
问题是，set表达式中的<code>=</code>侧优先级远低于<code>.</code>部分。解析器有可能会在一个优先级高到不允许出现setter的上下文中调用<code>dot()</code>。为了避免错误地允许这种情况，我们只有在<code>canAssign</code>为true时才去解析和编译等号部分。如果在<code>canAssign</code>为false时出现等号标识，<code>dot()</code>会保留它并返回。在这种情况下，编译器最终会进入<code>parsePrecedence()</code>，而该方法会在非预期的<code>=</code>（仍然作为下一个标识）处停止，并报告一个错误。</p>
<p>If we find an <code>=</code> in a context where it <em>is</em> allowed, then we compile the
expression that follows. After that, we emit a new <span
name="set"><code>OP_SET_PROPERTY</code></span> instruction. That takes a single operand for
the index of the property name in the constant table. If we didn&rsquo;t compile a set
expression, we assume it&rsquo;s a getter and emit an <code>OP_GET_PROPERTY</code> instruction,
which also takes an operand for the property name.
如果我们在允许使用等号的上下文中找到<code>=</code>，则编译后面的表达式。之后，我们发出一条新的<code>OP_SET_PROPERTY</code>指令。这条指令接受一个操作数，作为属性名称在常量表中的索引。如果我们没有编译set表达式，就假定它是getter，并发出一条<code>OP_GET_PROPERTY</code>指令，它也接受一个操作数作为属性名。</p>
<aside name="set">
<p>You can&rsquo;t <em>set</em> a non-field property, so I suppose that instruction could have
been <code>OP_SET_FIELD</code>, but I thought it looked nicer to be consistent with the get
instruction.
你不能设置非字段属性，所以我认为这个指令本该是<code>OP_SET_FIELD</code>，但是我认为它与get指令一致看起来更漂亮。</p>
</aside>
<p>Now is a good time to define these two new instructions.
现在是定义这两条新指令的好时机。</p>
<div class="codehilite"><pre class="insert-before">  OP_SET_UPVALUE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_PROPERTY</span>,
  <span class="a">OP_SET_PROPERTY</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>And add support for disassembling them:
并在反汇编程序中为它们添加支持：</p>
<div class="codehilite"><pre class="insert-before">      return byteInstruction(&quot;OP_SET_UPVALUE&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_PROPERTY</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_GET_PROPERTY&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_PROPERTY</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_SET_PROPERTY&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<h3><a href="#解释getter和setter表达式" id="解释getter和setter表达式"><small>27&#8202;.&#8202;4&#8202;.&#8202;1</small>解释getter和setter表达式</a></h3>
<p>Sliding over to the runtime, we&rsquo;ll start with get expressions since those are a
little simpler.
进入运行时，我们从获取表达式开始，因为它们更简单一些。</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_PROPERTY</span>: {
        <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">0</span>));
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();

        <span class="t">Value</span> <span class="i">value</span>;
        <span class="k">if</span> (<span class="i">tableGet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="i">name</span>, &amp;<span class="i">value</span>)) {
          <span class="i">pop</span>(); <span class="c">// Instance.</span>
          <span class="i">push</span>(<span class="i">value</span>);
          <span class="k">break</span>;
        }
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>When the interpreter reaches this instruction, the expression to the left of the
dot has already been executed and the resulting instance is on top of the stack.
We read the field name from the constant pool and look it up in the instance&rsquo;s
field table. If the hash table contains an entry with that name, we pop the
instance and push the entry&rsquo;s value as the result.
当解释器到达这条指令时，点左边的表达式已经被执行，得到的实例就在栈顶。我们从常量池中读取字段名，并在实例的字段表中查找该名称。如果哈希表中包含具有该名称的条目，我们就弹出实例，并将该条目的值作为结果压入栈。</p>
<p>Of course, the field might not exist. In Lox, we&rsquo;ve defined that to be a runtime
error. So we add a check for that and abort if it happens.
当然，这个字段可能不存在。在Lox中，我们将其定义为运行时错误。所以我们添加了一个检查，如果发生这种情况就中止。</p>
<div class="codehilite"><pre class="insert-before">          push(value);
          break;
        }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">

        <span class="i">runtimeError</span>(<span class="s">&quot;Undefined property &#39;%s&#39;.&quot;</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
        <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
</pre><pre class="insert-after">      }
      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p><span name="field">There</span> is another failure mode to handle which you&rsquo;ve
probably noticed. The above code assumes the expression to the left of the dot
did evaluate to an ObjInstance. But there&rsquo;s nothing preventing a user from
writing this:
你可能已经注意到了，还有另一种需要处理的失败模式。上面的代码中假定了点左边的表达式计算结果确实是一个ObjInstance。但是没有什么可以阻止用户这样写：</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">obj</span> = <span class="s">&quot;not an instance&quot;</span>;
<span class="k">print</span> <span class="i">obj</span>.<span class="i">field</span>;
</pre></div>
<p>The user&rsquo;s program is wrong, but the VM still has to handle it with some grace.
Right now, it will misinterpret the bits of the ObjString as an ObjInstance and,
I don&rsquo;t know, catch on fire or something definitely not graceful.
用户的程序是错误的，但是虚拟机仍然需要以某种优雅的方式来处理它。现在，它会把ObjString 数据误认为是一个ObjInstance ，并且，我不确定，代码起火或发生其它事情绝对是不优雅的。</p>
<p>In Lox, only instances are allowed to have fields. You can&rsquo;t stuff a field onto
a string or number. So we need to check that the value is an instance before
accessing any fields on it.
在Lox中，只有实例才允许有字段。你不能把字段塞到字符串或数字中。因此，在访问某个值上的任何字段之前，检查该值是否是一个实例。</p>
<aside name="field">
<p>Lox <em>could</em> support adding fields to values of other types. It&rsquo;s our language
and we can do what we want. But it&rsquo;s likely a bad idea. It significantly
complicates the implementation in ways that hurt performance<span class="em">&mdash;</span>for example,
string interning gets a lot harder.
Lox<em>可以</em>支持向其它类型的值中添加字段。这是我们的语言，我们可以做我们想做的。但这可能是个坏主意。它大大增加了实现的复杂性，从而损害了性能<span class="em">&mdash;</span>例如，字符串驻留变得更加困难。<BR></p>
<p>Also, it raises gnarly semantic questions around the equality and identity of
values. If I attach a field to the number <code>3</code>, does the result of <code>1 + 2</code> have
that field as well? If so, how does the implementation track that? If not, are
those two resulting &ldquo;threes&rdquo; still considered equal?
此外，它还引起了关于数值的相等和同一性的复杂语义问题。如果我给数字<code>3</code>附加一个字段，那么<code>1+2</code>的结果也有这个字段吗？如果是的话，实现上如何跟踪它？如果不是，这两个结果中的“3”仍然被认为是相等的吗？</p>
</aside>
<div class="codehilite"><pre class="insert-before">      case OP_GET_PROPERTY: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Only instances have properties.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }

</pre><pre class="insert-after">        ObjInstance* instance = AS_INSTANCE(peek(0));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>If the value on the stack isn&rsquo;t an instance, we report a runtime error and
safely exit.
如果栈中的值不是实例，则报告一个运行时错误并安全退出。</p>
<p>Of course, get expressions are not very useful when no instances have any
fields. For that we need setters.
当然，如果实例没有任何字段，get表达式就不太有用了。因此，我们需要setter。</p>
<div class="codehilite"><pre class="insert-before">        return INTERPRET_RUNTIME_ERROR;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_PROPERTY</span>: {
        <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">1</span>));
        <span class="i">tableSet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="a">READ_STRING</span>(), <span class="i">peek</span>(<span class="n">0</span>));
        <span class="t">Value</span> <span class="i">value</span> = <span class="i">pop</span>();
        <span class="i">pop</span>();
        <span class="i">push</span>(<span class="i">value</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>This is a little more complex than <code>OP_GET_PROPERTY</code>. When this executes, the
top of the stack has the instance whose field is being set and above that, the
value to be stored. Like before, we read the instruction&rsquo;s operand and find the
field name string. Using that, we store the value on top of the stack into the
instance&rsquo;s field table.
这比<code>OP_GET_PROPERTY</code>要复杂一些。当执行此指令时，栈顶有待设置字段的实例，在该实例之上有要存储的值。与前面一样，我们读取指令的操作数，并查找字段名称字符串。使用该方法，我们将栈顶的值存储到实例的字段表中。</p>
<p>After that is a little <span name="stack">stack</span> juggling. We pop the
stored value off, then pop the instance, and finally push the value back on. In
other words, we remove the <em>second</em> element from the stack while leaving the top
alone. A setter is itself an expression whose result is the assigned value, so
we need to leave that value on the stack. Here&rsquo;s what I mean:
在那之后是一些栈技巧。我们将存储的值弹出，然后弹出实例，最后再把值压回栈中。换句话说，我们从栈中删除第二个元素，而保留最上面的元素。setter本身是一个表达式，其结果就是所赋的值，所以我们需要将值保留在栈上。我的意思是：</p>
<aside name="stack">
<p>The stack operations go like this:
栈的操作是这样的：</p><img src="image/classes-and-instances/stack.png" alt="Popping two values and then pushing the first value back on the stack."/>
</aside>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Toast</span> {}
<span class="k">var</span> <span class="i">toast</span> = <span class="t">Toast</span>();
<span class="k">print</span> <span class="i">toast</span>.<span class="i">jam</span> = <span class="s">&quot;grape&quot;</span>; <span class="c">// Prints &quot;grape&quot;.</span>
</pre></div>
<p>Unlike when reading a field, we don&rsquo;t need to worry about the hash table not
containing the field. A setter implicitly creates the field if needed. We do
need to handle the user incorrectly trying to store a field on a value that
isn&rsquo;t an instance.
与读取字段不同，我们不需要担心哈希表中不包含该字段。如果需要的话，setter会隐式地创建这个字段。我们确实需要处理用户不正确地试图在非实例的值上存储字段的情况。</p>
<div class="codehilite"><pre class="insert-before">      case OP_SET_PROPERTY: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">1</span>))) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Only instances have fields.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }

</pre><pre class="insert-after">        ObjInstance* instance = AS_INSTANCE(peek(1));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Exactly like with get expressions, we check the value&rsquo;s type and report a
runtime error if it&rsquo;s invalid. And, with that, the stateful side of Lox&rsquo;s
support for object-oriented programming is in place. Give it a try:
就像get表达式一样，我们检查值的类型，如果无效就报告一个运行时错误。这样一来，Lox对面向对象编程中有状态部分的支持就到位了。试一试：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Pair</span> {}

<span class="k">var</span> <span class="i">pair</span> = <span class="t">Pair</span>();
<span class="i">pair</span>.<span class="i">first</span> = <span class="n">1</span>;
<span class="i">pair</span>.<span class="i">second</span> = <span class="n">2</span>;
<span class="k">print</span> <span class="i">pair</span>.<span class="i">first</span> + <span class="i">pair</span>.<span class="i">second</span>; <span class="c">// 3.</span>
</pre></div>
<p>This doesn&rsquo;t really feel very <em>object</em>-oriented. It&rsquo;s more like a strange,
dynamically typed variant of C where objects are loose struct-like bags of data.
Sort of a dynamic procedural language. But this is a big step in expressiveness.
Our Lox implementation now lets users freely aggregate data into bigger units.
In the next chapter, we will breathe life into those inert blobs.
这感觉不太面向对象。它更像是一种奇怪的、动态类型的C语言变体，其中的对象是松散的类似结构体的数据包。有点像动态过程化语言。但这是表达能力的一大进步。我们的Lox实现现在允许用户自由地将数据聚合成更大的单元。在下一章中，我们将为这些迟缓的数据注入活力。</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Trying to access a non-existent field on an object immediately aborts the
entire VM. The user has no way to recover from this runtime error, nor is
there any way to see if a field exists <em>before</em> trying to access it. It&rsquo;s up
to the user to ensure on their own that only valid fields are read.
试图访问一个对象上不存在的字段会立即中止整个虚拟机。用户没有办法从这个运行时错误中恢复过来，也没有办法在试图访问一个字段之前看它是否存在。需要由用户自己来确保只读取有效字段。</p>
<p>How do other dynamically typed languages handle missing fields? What do you
think Lox should do? Implement your solution.
其它动态类型语言是如何处理缺少字段的？你认为Lox应该怎么做？实现你的解决方案。</p>
</li>
<li>
<p>Fields are accessed at runtime by their <em>string</em> name. But that name must
always appear directly in the source code as an <em>identifier token</em>. A user
program cannot imperatively build a string value and then use that as the
name of a field. Do you think they should be able to? Devise a language
feature that enables that and implement it.
字段在运行时是通过它们的<em>字符串</em>名称来访问的。但是该名称必须总是作为标识符直接出现在源代码中。用户程序不能命令式地构建字符串值，然后将其用作字段名。你认为应该这样做吗？那就设计一种语言特性来实现它。</p>
</li>
<li>
<p>Conversely, Lox offers no way to <em>remove</em> a field from an instance. You can
set a field&rsquo;s value to <code>nil</code>, but the entry in the hash table is still
there. How do other languages handle this? Choose and implement a strategy
for Lox.
反过来说，Lox没有提供从实例中<em>删除</em>字段的方法。你可以将一个字段的值设置为<code>nil</code>，但哈希表中的条目仍然存在。其它语言如何处理这个问题？为Lox选择一个策略并实现。</p>
</li>
<li>
<p>Because fields are accessed by name at runtime, working with instance state
is slow. It&rsquo;s technically a constant-time operation<span class="em">&mdash;</span>thanks, hash tables<span class="em">&mdash;</span>but the constant factors are relatively large. This is a major component
of why dynamic languages are slower than statically typed ones.
因为字段在运行时是按照名称访问的，所以对实例状态的操作是很慢的。从技术上讲，这是一个常量时间的操作（感谢哈希表），但是常量因子比较大。这就是动态语言比静态语言慢的一个主要原因。</p>
<p>How do sophisticated implementations of dynamically typed languages cope
with and optimize this?
动态类型语言的复杂实现是如何应对和优化这一问题的？</p>
</li>
</ol>
</div>

    <footer>
      <a href="methods-and-initializers.html" class="next">
        下一节: &ldquo;方法和初始化&rdquo; &rarr;
      </a>
      Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a
        href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy;
        2015&hairsp;&ndash;&hairsp;2021</a>
    </footer>
  </article>

  </div>
  </body>
  </html>
