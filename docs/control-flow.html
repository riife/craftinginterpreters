<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>控制流 &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
        <h3><a href="#top">控制流<small>9</small></a></h3>
    
    <ul>
        <li><a href="#图灵机（简介）"><small>9.1</small> 图灵机（简介）</a></li>
        <li><a href="#条件执行"><small>9.2</small> 条件执行</a></li>
        <li><a href="#逻辑操作符"><small>9.3</small> 逻辑操作符</a></li>
        <li><a href="#while循环"><small>9.4</small> While循环</a></li>
        <li><a href="#for循环"><small>9.5</small> For循环</a></li>
        <li class="divider"></li>
        <li class="end-part"><a href="#challenges">Challenges</a></li>
        <li class="end-part"><a href="#design-note"><small>note</small>一些语法糖</a></li>
    </ul>
    
    
        <div class="prev-next">
        <a href="statements-and-state.html" title="语句和状态" class="left">&larr;&nbsp;Previous</a>
        <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
        <a href="functions.html" title="函数" class="right">Next&nbsp;&rarr;</a>
    </div> </div>
</nav>

<nav class="narrow">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <a href="statements-and-state.html" title="语句和状态" class="prev">←</a>
  <a href="functions.html" title="函数" class="next">→</a>
</nav>

<div class="page">
  <div class="nav-wrapper">
    <nav class="floating">
      <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
      <div class="expandable">
        <h3><a href="#top">控制流<small>9</small></a></h3>
        
        <ul>
            <li><a href="#图灵机（简介）"><small>9.1</small> 图灵机（简介）</a></li>
            <li><a href="#条件执行"><small>9.2</small> 条件执行</a></li>
            <li><a href="#逻辑操作符"><small>9.3</small> 逻辑操作符</a></li>
            <li><a href="#while循环"><small>9.4</small> While循环</a></li>
            <li><a href="#for循环"><small>9.5</small> For循环</a></li>
            <li class="divider"></li>
            <li class="end-part"><a href="#challenges">Challenges</a></li>
            <li class="end-part"><a href="#design-note"><small>note</small>一些语法糖</a></li>
        </ul>
        
        
                <div class="prev-next">
            <a href="statements-and-state.html" title="语句和状态" class="left">&larr;&nbsp;Previous</a>
            <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
            <a href="functions.html" title="函数" class="right">Next&nbsp;&rarr;</a>
        </div>      </div>
      <a id="expand-nav">≡</a>
    </nav>
  </div>

  <article class="chapter">

    <div class="number">9</div>
    <h1>控制流</h1>

    <blockquote>
<p>Logic, like whiskey, loses its beneficial effect when taken in too large
quantities.
逻辑和威士忌一样，如果摄入太多，就会失去其有益的效果。</p>
<p><cite>Edward John Moreton Drax Plunkett, Lord Dunsany</cite></p>
</blockquote>
<p>Compared to <a href="statements-and-state.html">last chapter&rsquo;s</a> grueling marathon, today is a
lighthearted frolic through a daisy meadow. But while the work is easy, the
reward is surprisingly large.
与上一章艰苦的马拉松相比，这一章就是在雏菊草地上的轻松嬉戏。虽然工作很简单，但回报却惊人的大。</p>
<p>Right now, our interpreter is little more than a calculator. A Lox program can
only do a fixed amount of work before completing. To make it run twice as long
you have to make the source code twice as lengthy. We&rsquo;re about to fix that. In
this chapter, our interpreter takes a big step towards the programming
language major leagues: <em>Turing-completeness</em>.
现在，我们的解释器只不过是一个计算器而已。一个Lox程序在结束之前只能做固定的工作量。要想让它的运行时间延长一倍，你就必须让源代码的长度增加一倍。我们即将解决这个问题。在本章中，我们的解释器向编程语言大联盟迈出了一大步：图灵完备性。</p>
<h2><a href="#图灵机（简介）" id="图灵机（简介）"><small>9&#8202;.&#8202;1</small>图灵机（简介）</a></h2>
<p>In the early part of last century, mathematicians stumbled into a series of
confusing <span name="paradox">paradoxes</span> that led them to doubt the
stability of the foundation they had built their work upon. To address that
<a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis">crisis</a>, they went back to square one. Starting from a handful of axioms,
logic, and set theory, they hoped to rebuild mathematics on top of an
impervious foundation.</p>
<aside name="paradox">
<p>The most famous is <a href="https://en.wikipedia.org/wiki/Russell%27s_paradox"><strong>Russell&rsquo;s paradox</strong></a>. Initially, set theory
allowed you to define any sort of set. If you could describe it in English, it
was valid. Naturally, given mathematicians&rsquo; predilection for self-reference,
sets can contain other sets. So Russell, rascal that he was, came up with:
其中最著名的就是<a href="https://en.wikipedia.org/wiki/Russell%27s_paradox">罗素悖论</a>。最初，集合理论允许你定义任何类型的集合。只要你能用英语描述它，它就是有效的。自然，鉴于数学家对自引用的偏爱，集合可以包含其他的集合。于是，罗素，这个无赖，提出了：</p>
<p><em>R is the set of all sets that do not contain themselves.</em></p>
<p><em>R是所有不包含自身的集合的集合。</em></p>
<p>Does R contain itself? If it doesn&rsquo;t, then according to the second half of the
definition it should. But if it does, then it no longer meets the definition.
Cue mind exploding.
R是否包含自己？如果不包含，那么根据定义的后半部分，它应该包含；如果包含，那么它就不满足定义。脑袋要炸了。</p>
</aside>
<p>They wanted to rigorously answer questions like, &ldquo;Can all true statements be
proven?&rdquo;, &ldquo;Can we <a href="https://en.wikipedia.org/wiki/Computable_function">compute</a> all functions that we can define?&rdquo;, or even the
more general question, &ldquo;What do we mean when we claim a function is
&lsquo;computable&rsquo;?&rdquo;</p>
<p>They presumed the answer to the first two questions would be &ldquo;yes&rdquo;. All that
remained was to prove it. It turns out that the answer to both is &ldquo;no&rdquo;, and
astonishingly, the two questions are deeply intertwined. This is a fascinating
corner of mathematics that touches fundamental questions about what brains are
able to do and how the universe works. I can&rsquo;t do it justice here.
他们认为前两个问题的答案应该是“是”，剩下的就是去证明它。但事实证明这两个问题的答案都是“否”。而且令人惊讶的是，这两个问题是深深地交织在一起的。这是数学的一个迷人的角落，它触及了关于大脑能够做什么和宇宙如何运作的基本问题。我在这里说不清楚。</p>
<p>What I do want to note is that in the process of proving that the answer to the
first two questions is &ldquo;no&rdquo;, Alan Turing and Alonzo Church devised a precise
answer to the last question<span class="em">&mdash;</span>a definition of what kinds of functions are <span
name="uncomputable">computable</span>. They each crafted a tiny system with a
minimum set of machinery that is still powerful enough to compute any of a
(very) large class of functions.
我想指出的是，在证明前两个问题的答案是 &ldquo;否 &ldquo;的过程中，艾伦·图灵和阿隆佐·邱奇为最后一个问题设计了一个精确的答案，即定义了什么样的函数是可计算的。他们各自设计了一个具有最小机械集的微型系统，该系统仍然强大到足以计算一个超大类函数中的任何一个。</p>
<aside name="uncomputable">
<p>They proved the answer to the first question is &ldquo;no&rdquo; by showing that the
function that returns the truth value of a given statement is <em>not</em> a computable
one.
他们通过证明:返回给定语句真值的函数不是可计算的函数，从而证明了第一个问题的答案是 &ldquo;否&ldquo;。</p>
</aside>
<p>These are now considered the &ldquo;computable functions&rdquo;. Turing&rsquo;s system is called a
<span name="turing"><strong>Turing machine</strong></span>. Church&rsquo;s is the <strong>lambda
calculus</strong>. Both are still widely used as the basis for models of computation
and, in fact, many modern functional programming languages use the lambda
calculus at their core.
这些现在被认为是“可计算函数”。图灵的系统被称为<strong>图灵机</strong>，邱奇的系统是<strong>lambda演算</strong>。这两种方法仍然被广泛用作计算模型的基础，事实上，许多现代函数式编程语言的核心都是lambda演算。</p>
<aside name="turing">
<p>Turing called his inventions &ldquo;a-machines&rdquo; for &ldquo;automatic&rdquo;. He wasn&rsquo;t so
self-aggrandizing as to put his <em>own</em> name on them. Later mathematicians did
that for him. That&rsquo;s how you get famous while still retaining some modesty.
图灵把他的发明称为 “a-machines”，表示“automatic(自动)”。他并没有自吹自擂到把自己的名字放入其中。后来的数学家们为他做了这些。这就是你如何在成名的同时还能保持谦虚。</p>
</aside><img src="image/control-flow/turing-machine.png" alt="A Turing machine." />
<p>Turing machines have better name recognition<span class="em">&mdash;</span>there&rsquo;s no Hollywood film about
Alonzo Church yet<span class="em">&mdash;</span>but the two formalisms are <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">equivalent in power</a>.
In fact, any programming language with some minimal level of expressiveness is
powerful enough to compute <em>any</em> computable function.</p>
<p>You can prove that by writing a simulator for a Turing machine in your language.
Since Turing proved his machine can compute any computable function, by
extension, that means your language can too. All you need to do is translate the
function into a Turing machine, and then run that on your simulator.
你可以用自己的语言为图灵机编写一个模拟器来证明这一点。由于图灵证明了他的机器可以计算任何可计算函数，推而广之，这意味着你的语言也可以。你所需要做的就是把函数翻译成图灵机，然后在你的模拟器上运行它。</p>
<p>If your language is expressive enough to do that, it&rsquo;s considered
<strong>Turing-complete</strong>. Turing machines are pretty dang simple, so it doesn&rsquo;t take
much power to do this. You basically need arithmetic, a little control flow,
and the ability to allocate and use (theoretically) arbitrary amounts of memory.
We&rsquo;ve got the first. By the end of this chapter, we&rsquo;ll have the <span
name="memory">second</span>.
如果你的语言有足够的表达能力来做到这一点，它就被认为是<strong>图灵完备</strong>的。图灵机非常简单，所以它不需要太多的能力。您基本上只需要算术、一点控制流以及分配和使用(理论上)任意数量内存的能力。我们已经具备了第一个条件。在本章结束时，我们将具备第二个条件。</p>
<aside name="memory">
<p>We <em>almost</em> have the third too. You can create and concatenate strings of
arbitrary size, so you can <em>store</em> unbounded memory. But we don&rsquo;t have any way
to access parts of a string.
我们也 <em>基本上</em> 具备第三个条件了。你可以创建和拼接任意大小的字符串，因此也就可以存储无界 <em>内存</em> 。但我们还无法访问字符串的各个部分。</p>
</aside>
<h2><a href="#条件执行" id="条件执行"><small>9&#8202;.&#8202;2</small>条件执行</a></h2>
<p>Enough history, let&rsquo;s jazz up our language. We can divide control flow roughly
into two kinds:
说完了历史，现在让我们把语言优化一下。我们大致可以把控制流分为两类：</p>
<ul>
<li>
<p><strong>Conditional</strong> or <strong>branching control flow</strong> is used to <em>not</em> execute
some piece of code. Imperatively, you can think of it as jumping <em>ahead</em>
over a region of code.</p>
<p><strong>条件</strong>或<strong>分支控制流</strong>是用来不执行某些代码的。意思是，你可以把它看作是跳过了代码的一个区域。</p>
</li>
<li>
<p><strong>Looping control flow</strong> executes a chunk of code more than once. It jumps
<em>back</em> so that you can do something again. Since you don&rsquo;t usually want
<em>infinite</em> loops, it typically has some conditional logic to know when to
stop looping as well.</p>
<p><strong>循环控制流</strong>是用于多次执行一块代码的。它会<em>向回</em>跳转，从而能再次执行某些代码。用户通常不需要无限循环，所以一般也会有一些条件逻辑用于判断何时停止循环。</p>
</li>
</ul>
<p>Branching is simpler, so we&rsquo;ll start there. C-derived languages have two main
conditional execution features, the <code>if</code> statement and the perspicaciously named
&ldquo;conditional&rdquo; <span name="ternary">operator</span> (<code>?:</code>). An <code>if</code> statement
lets you conditionally execute statements and the conditional operator lets you
conditionally execute expressions.
分支更简单一些，所以我们先从分支开始实现。C衍生语言中包含两个主要的条件执行功能，即<code>if</code>语句和“条件”运算符（<code>?:</code>）。<code>if</code>语句使你可以按条件执行语句，而条件运算符使你可以按条件执行表达式。</p>
<aside name="ternary">
<p>The conditional operator is also called the &ldquo;ternary&rdquo; operator because it&rsquo;s the
only operator in C that takes three operands.
条件操作符也称为三元操作符，因为它是C语言中唯一接受三个操作数的操作符。</p>
</aside>
<p>For simplicity&rsquo;s sake, Lox doesn&rsquo;t have a conditional operator, so let&rsquo;s get our
<code>if</code> statement on. Our statement grammar gets a new production.
为了简单起见，Lox没有条件运算符，所以让我们直接开始<code>if</code>语句吧。我们的语句语法需要一个新的生成式。</p>
<p><span name="semicolon"></span></p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">ifStmt</span>         → <span class="s">&quot;if&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> <span class="i">statement</span>
               ( <span class="s">&quot;else&quot;</span> <span class="i">statement</span> )? ;
</pre></div>
<aside name="semicolon">
<p>The semicolons in the rules aren&rsquo;t quoted, which means they are part of the
grammar metasyntax, not Lox&rsquo;s syntax. A block does not have a <code>;</code> at the end and
an <code>if</code> statement doesn&rsquo;t either, unless the then or else statement happens to
be one that ends in a semicolon.
规则中的分号没有加引号，这意味着它们是语法元语法的一部分，而不是 Lox 的语法。块的末尾没有 <code>;</code>; <code>if</code> 语句也没有，除非 <code>then</code>或 <code>else</code> 语句恰好以分号结束。</p>
</aside>
<p>An <code>if</code> statement has an expression for the condition, then a statement to execute
if the condition is truthy. Optionally, it may also have an <code>else</code> keyword and a
statement to execute if the condition is falsey. The <span name="if-ast">syntax
tree node</span> has fields for each of those three pieces.
if语句有一个表达式作为条件，然后是一个在条件为真时要执行的语句。另外，它还可以有一个<code>else</code>关键字和条件为假时要执行的语句。语法树节点中对语法的这三部分都有对应的字段。</p>
<div class="codehilite"><pre class="insert-before">      &quot;Expression : Expr expression&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;If         : Expr condition, Stmt thenBranch,&quot;</span> +
                  <span class="s">&quot; Stmt elseBranch&quot;</span>,
</pre><pre class="insert-after">      &quot;Print      : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="if-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#if-statement">Appendix II</a>.
新节点的生成代码见<a href="appendix-ii.html#if-statement">附录 II</a>。</p>
</aside>
<p>Like other statements, the parser recognizes an <code>if</code> statement by the leading
<code>if</code> keyword.
与其它语句类似，解析器通过开头的<code>if</code>关键字来识别<code>if</code>语句。</p>
<div class="codehilite"><pre class="insert-before">  private Stmt statement() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">IF</span>)) <span class="k">return</span> <span class="i">ifStatement</span>();
</pre><pre class="insert-after">    if (match(PRINT)) return printStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>When it finds one, it calls this new method to parse the rest:
如果发现了<code>if</code>关键字，就调用下面的新方法解析其余部分：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>statement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">ifStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;if&#39;.&quot;</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after if condition.&quot;</span>);<span name="parens"> </span>

    <span class="t">Stmt</span> <span class="i">thenBranch</span> = <span class="i">statement</span>();
    <span class="t">Stmt</span> <span class="i">elseBranch</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">ELSE</span>)) {
      <span class="i">elseBranch</span> = <span class="i">statement</span>();
    }

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">If</span>(<span class="i">condition</span>, <span class="i">thenBranch</span>, <span class="i">elseBranch</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>

<aside name="parens">
<p>The parentheses around the condition are only half useful. You need some kind of
delimiter <em>between</em> the condition and the then statement, otherwise the parser
can&rsquo;t tell when it has reached the end of the condition expression. But the
<em>opening</em> parenthesis after <code>if</code> doesn&rsquo;t do anything useful. Dennis Ritchie put
it there so he could use <code>)</code> as the ending delimiter without having unbalanced
parentheses.
条件周围的圆括号只有一半是有用的。您需要在条件和then语句之间设置某种分隔符，否则解析器无法判断是否到达条件表达式的末尾。但是<code>if</code> 后面的小括号并没有什么用处。Dennis Ritchie 把它放在那里是为了让他可以使用<code>)</code>作为结尾的分隔符，而且不会出现不对称的小括号。</p>
<p>Other languages like Lua and some BASICs use a keyword like <code>then</code> as the ending
delimiter and don&rsquo;t have anything before the condition. Go and Swift instead
require the statement to be a braced block. That lets them use the <code>{</code> at the
beginning of the statement to tell when the condition is done.
其他语言，比如Lua和一些BASICs，使用<code>then</code>这样的关键字作为结束分隔符，在条件表达式之前没有任何内容。而Go和Swift则要求语句必须是一个带括号的块，这样就可以使用语句开头的<code>{</code>来判断条件表达式是否结束。</p>
</aside>
<p>As usual, the parsing code hews closely to the grammar. It detects an else
clause by looking for the preceding <code>else</code> keyword. If there isn&rsquo;t one, the
<code>elseBranch</code> field in the syntax tree is <code>null</code>.
跟之前一样，解析代码严格遵循语法。它通过查找前面的<code>else</code>关键字来检测<code>else</code>子句。如果没有，语法树中的<code>elseBranch</code>字段为<code>null</code>。</p>
<p>That seemingly innocuous optional else has, in fact, opened up an ambiguity in
our grammar. Consider:
实际上，这个看似无伤大雅的可选项在我们的语法中造成了歧义。考虑以下代码：</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">first</span>) <span class="k">if</span> (<span class="i">second</span>) <span class="i">whenTrue</span>(); <span class="k">else</span> <span class="i">whenFalse</span>();
</pre></div>
<p>Here&rsquo;s the riddle: Which <code>if</code> statement does that else clause belong to? This
isn&rsquo;t just a theoretical question about how we notate our grammar. It actually
affects how the code executes:
谜题是这样的:这里的<code>else</code>子句属于哪个<code>if</code>语句?这不仅仅是一个关于如何标注语法的理论问题。它实际上会影响代码的执行方式：</p>
<ul>
<li>
<p>If we attach the else to the first <code>if</code> statement, then <code>whenFalse()</code> is
called if <code>first</code> is falsey, regardless of what value <code>second</code> has.
如果我们将<code>else</code>语句关联到第一个<code>if</code>语句，那么当<code>first</code>为假时，无论<code>second</code>的值是多少，都将调用<code>whenFalse()</code>。</p>
</li>
<li>
<p>If we attach it to the second <code>if</code> statement, then <code>whenFalse()</code> is only
called if <code>first</code> is truthy and <code>second</code> is falsey.
如果我们将<code>else</code>语句关联到第二个<code>if</code>语句，那么只有当<code>first</code>为真并且<code>second</code>为假时，才会调用<code>whenFalse()</code>。</p>
</li>
</ul>
<p>Since else clauses are optional, and there is no explicit delimiter marking the
end of the <code>if</code> statement, the grammar is ambiguous when you nest <code>if</code>s in this
way. This classic pitfall of syntax is called the <strong><a href="https://en.wikipedia.org/wiki/Dangling_else">dangling else</a></strong> problem.
由于<code>else</code>子句是可选的，而且没有明确的分隔符来标记<code>if</code>语句的结尾，所以当你以这种方式嵌套<code>if</code>时，语法是不明确的。这种典型的语法陷阱被称为<a href="https://en.wikipedia.org/wiki/Dangling_else">悬空的else</a>问题。</p>
<p><span name="else"></span></p><img class="above" src="image/control-flow/dangling-else.png" alt="Two ways the else can be interpreted." />
<aside name="else">
<p>Here, formatting highlights the two ways the else could be parsed. But note that
since whitespace characters are ignored by the parser, this is only a guide to
the human reader.
在这里，格式化突出了其他内容的两种解析方式。但要注意的是，由于解析器会忽略空白字符，因此这只是给人类读者的一个指南。</p>
</aside>
<p>It <em>is</em> possible to define a context-free grammar that avoids the ambiguity
directly, but it requires splitting most of the statement rules into pairs, one
that allows an <code>if</code> with an <code>else</code> and one that doesn&rsquo;t. It&rsquo;s annoying.
也可以定义一个上下文无关的语法来直接避免歧义，但是需要将大部分语句规则拆分成对，一个是允许带有<code>else</code>的<code>if</code>语句，另一个不允许。这很烦人。</p>
<p>Instead, most languages and parsers avoid the problem in an ad hoc way. No
matter what hack they use to get themselves out of the trouble, they always
choose the same interpretation<span class="em">&mdash;</span>the <code>else</code> is bound to the nearest <code>if</code> that
precedes it.
相反，大多数语言和解析器都以一种特殊的方式避免了这个问题。不管他们用什么方法来解决这个问题，他们总是选择同样的解释——<code>else</code>与前面最近的<code>if</code>绑定在一起。</p>
<p>Our parser conveniently does that already. Since <code>ifStatement()</code> eagerly looks
for an <code>else</code> before returning, the innermost call to a nested series will claim
the else clause for itself before returning to the outer <code>if</code> statements.
我们的解析器已经很方便地做到了这一点。因为 <code>ifStatement()</code>在返回之前会继续寻找一个<code>else</code>子句，连续嵌套的最内层调用在返回外部的<code>if</code>语句之前，会先为自己声明<code>else</code>语句。</p>
<p>Syntax in hand, we are ready to interpret.
语法就绪了，我们可以开始解释了。</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitExpressionStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitIfStmt</span>(<span class="t">Stmt</span>.<span class="t">If</span> <span class="i">stmt</span>) {
    <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">thenBranch</span>);
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">elseBranch</span> != <span class="k">null</span>) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">elseBranch</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitExpressionStmt</em>()</div>

<p>The interpreter implementation is a thin wrapper around the self-same Java code.
It evaluates the condition. If truthy, it executes the then branch. Otherwise,
if there is an else branch, it executes that.
解释器实现就是对相同的Java代码的简单包装。它首先对条件表达式进行求值。如果为真，则执行<code>then</code>分支。否则，如果有存在<code>else</code>分支，就执行该分支。</p>
<p>If you compare this code to how the interpreter handles other syntax we&rsquo;ve
implemented, the part that makes control flow special is that Java <code>if</code>
statement. Most other syntax trees always evaluate their subtrees. Here, we may
not evaluate the then or else statement. If either of those has a side effect,
the choice not to evaluate it becomes user visible.
如果你把这段代码与解释器中我们已实现的处理其它语法的代码进行比较，会发现控制流中特殊的地方就在于Java的<code>if</code>语句。其它大多数语法树总是会对子树求值，但是这里，我们可能会不执行<code>then</code>语句或<code>else</code>语句。如果其中任何一个语句有副作用，那么选择不执行某条语句就是用户可见的。</p>
<h2><a href="#逻辑操作符" id="逻辑操作符"><small>9&#8202;.&#8202;3</small>逻辑操作符</a></h2>
<p>Since we don&rsquo;t have the conditional operator, you might think we&rsquo;re done with
branching, but no. Even without the ternary operator, there are two other
operators that are technically control flow constructs<span class="em">&mdash;</span>the logical operators
<code>and</code> and <code>or</code>.
由于我们没有条件运算符，你可能认为我们已经完成分支开发了，但其实还没有。虽然没有三元运算符，但是还有两个其它操作符在技术上是控制流结构——逻辑运算符<code>and</code>和<code>or</code>。</p>
<p>These aren&rsquo;t like other binary operators because they <strong>short-circuit</strong>. If,
after evaluating the left operand, we know what the result of the logical
expression must be, we don&rsquo;t evaluate the right operand. For example:
它们与其它二进制运算符不同，是因为它们会短路。如果在计算左操作数之后，我们已经确切知道逻辑表达式的结果，那么就不再计算右操作数。例如：</p>
<div class="codehilite"><pre><span class="k">false</span> <span class="k">and</span> <span class="i">sideEffect</span>();
</pre></div>
<p>For an <code>and</code> expression to evaluate to something truthy, both operands must be
truthy. We can see as soon as we evaluate the left <code>false</code> operand that that
isn&rsquo;t going to be the case, so there&rsquo;s no need to evaluate <code>sideEffect()</code> and it
gets skipped.
对于一个<code>and</code>表达式来说，两个操作数都必须是真，才能得到结果为真。我们只要看到左侧的<code>false</code>操作数，就知道结果不会是真，也就不需要对<code>sideEffect()</code>求值，会直接跳过它。</p>
<p>This is why we didn&rsquo;t implement the logical operators with the other binary
operators. Now we&rsquo;re ready. The two new operators are low in the precedence
table. Similar to <code>||</code> and <code>&amp;&amp;</code> in C, they each have their <span
name="logical">own</span> precedence with <code>or</code> lower than <code>and</code>. We slot them
right between <code>assignment</code> and <code>equality</code>.
这就是为什么我们没有在实现其它二元运算符的时候一起实现逻辑运算符。现在我们已经准备好了。这两个新的运算符在优先级表中的位置很低，类似于C语言中的<code>||</code>和<code>&amp;&amp;</code>，它们都有各自的优先级，<code>or</code>低于<code>and</code>。我们把这两个运算符插入<code>assignment</code> 和 <code>equality</code>之间。</p>
<aside name="logical">
<p>I&rsquo;ve always wondered why they don&rsquo;t have the same precedence, like the various
comparison or equality operators do.
我一直在想，为什么它们不像各种比较或相等运算符那样具有相同的优先级？</p>
</aside>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">assignment</span> ;
<span class="i">assignment</span>     → <span class="t">IDENTIFIER</span> <span class="s">&quot;=&quot;</span> <span class="i">assignment</span>
               | <span class="i">logic_or</span> ;
<span class="i">logic_or</span>       → <span class="i">logic_and</span> ( <span class="s">&quot;or&quot;</span> <span class="i">logic_and</span> )* ;
<span class="i">logic_and</span>      → <span class="i">equality</span> ( <span class="s">&quot;and&quot;</span> <span class="i">equality</span> )* ;
</pre></div>
<p>Instead of falling back to <code>equality</code>, <code>assignment</code> now cascades to <code>logic_or</code>.
The two new rules, <code>logic_or</code> and <code>logic_and</code>, are <span
name="same">similar</span> to other binary operators. Then <code>logic_and</code> calls
out to <code>equality</code> for its operands, and we chain back to the rest of the
expression rules.
<code>assignment</code> 现在不是落到 <code>equality</code>，而是继续进入<code>logic_or</code>。两个新规则，<code>logic_or</code> 和 <code>logic_and</code>，与其它二元运算符类似。然后<code>logic_and</code>会调用<code>equality</code>计算其操作数，然后我们就链入了表达式规则的其它部分。</p>
<aside name="same">
<p>The <em>syntax</em> doesn&rsquo;t care that they short-circuit. That&rsquo;s a semantic concern.
语法并不关心它们是否会短路。这是语义问题。</p>
</aside>
<p>We could reuse the existing Expr.Binary class for these two new expressions
since they have the same fields. But then <code>visitBinaryExpr()</code> would have to
check to see if the operator is one of the logical operators and use a different
code path to handle the short circuiting. I think it&rsquo;s cleaner to define a <span
name="logical-ast">new class</span> for these operators so that they get their
own visit method.
对于这两个新表达式，我们可以重用Expr.Binary类，因为他们具有相同的字段。但是这样的话，<code>visitBinaryExpr()</code> 方法中必须检查运算符是否是逻辑运算符，并且要使用不同的代码处理短路逻辑。我认为更整洁的方法是为这些运算符定义一个新类，这样它们就有了自己的<code>visit</code>方法。</p>
<div class="codehilite"><pre class="insert-before">      &quot;Literal  : Object value&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Logical  : Expr left, Token operator, Expr right&quot;</span>,
</pre><pre class="insert-after">      &quot;Unary    : Token operator, Expr right&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="logical-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#logical-expression">Appendix II</a>.
新节点的生成代码见<a href="appendix-ii.html#logical-expression">附录 II</a>。</p>
</aside>
<p>To weave the new expressions into the parser, we first change the parsing code
for assignment to call <code>or()</code>.
为了将新的表达式加入到解析器中，我们首先将赋值操作的解析代码改为调用<code>or()</code>方法。</p>
<div class="codehilite"><pre class="insert-before">  private Expr assignment() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>assignment</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">or</span>();
</pre><pre class="insert-after">

    if (match(EQUAL)) {
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>assignment</em>(), replace 1 line</div>

<p>The code to parse a series of <code>or</code> expressions mirrors other binary operators.
解析一系列<code>or</code>语句的代码与其它二元运算符相似。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>assignment</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">or</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">and</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">OR</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">and</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>assignment</em>()</div>

<p>Its operands are the next higher level of precedence, the new <code>and</code> expression.
它的操作数是位于下一优先级的新的<code>and</code>表达式。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>or</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">and</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">equality</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">AND</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">equality</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>or</em>()</div>

<p>That calls <code>equality()</code> for its operands, and with that, the expression parser
is all tied back together again. We&rsquo;re ready to interpret.
这里会调用 <code>equality()</code> 计算操作数，这样一来，表达式解析器又重新绑定到了一起。我们已经准备好进行解释了。</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitLiteralExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitLogicalExpr</span>(<span class="t">Expr</span>.<span class="t">Logical</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">left</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">left</span>);

    <span class="k">if</span> (<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">type</span> == <span class="t">TokenType</span>.<span class="i">OR</span>) {
      <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    } <span class="k">else</span> {
      <span class="k">if</span> (!<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    }

    <span class="k">return</span> <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">right</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitLiteralExpr</em>()</div>

<p>If you compare this to the <a href="evaluating-expressions.html">earlier chapter&rsquo;s</a> <code>visitBinaryExpr()</code>
method, you can see the difference. Here, we evaluate the left operand first. We
look at its value to see if we can short-circuit. If not, and only then, do we
evaluate the right operand.
如果你把这个方法与前面章节的<code>visitBinaryExpr()</code>方法相比较，就可以看出其中的区别。这里，我们先计算左操作数。然后我们查看结果值，判断是否可以短路。当且仅当不能短路时，我们才计算右侧的操作数。</p>
<p>The other interesting piece here is deciding what actual value to return. Since
Lox is dynamically typed, we allow operands of any type and use truthiness to
determine what each operand represents. We apply similar reasoning to the
result. Instead of promising to literally return <code>true</code> or <code>false</code>, a logic
operator merely guarantees it will return a value with appropriate truthiness.
另一个有趣的部分是决定返回什么实际值。由于Lox是动态类型的，我们允许任何类型的操作数，并使用真实性来确定每个操作数代表什么。我们对结果采用类似的推理。逻辑运算符并不承诺会真正返回<code>true</code>或<code>false</code>，而只是保证它将返回一个具有适当真实性的值。</p>
<p>Fortunately, we have values with proper truthiness right at hand<span class="em">&mdash;</span>the results
of the operands themselves. So we use those. For example:
幸运的是，我们手边就有具有适当真实性的值——即操作数本身的结果，所以我们可以直接使用它们。如：</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="s">&quot;hi&quot;</span> <span class="k">or</span> <span class="n">2</span>; <span class="c">// &quot;hi&quot;.</span>
<span class="k">print</span> <span class="k">nil</span> <span class="k">or</span> <span class="s">&quot;yes&quot;</span>; <span class="c">// &quot;yes&quot;.</span>
</pre></div>
<p>On the first line, <code>"hi"</code> is truthy, so the <code>or</code> short-circuits and returns
that. On the second line, <code>nil</code> is falsey, so it evaluates and returns the
second operand, <code>"yes"</code>.
在第一行，<code>“hi”</code>是真的，所以<code>or</code>短路并返回它。在第二行，<code>nil</code>是假的，因此它计算并返回第二个操作数<code>“yes”</code>。</p>
<p>That covers all of the branching primitives in Lox. We&rsquo;re ready to jump ahead to
loops. You see what I did there? <em>Jump. Ahead.</em> Get it? See, it&rsquo;s like a
reference to<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>oh, forget it.
这样就完成了Lox中的所有分支原语，我们准备实现循环吧。</p>
<h2><a href="#while循环" id="while循环"><small>9&#8202;.&#8202;4</small>While循环</a></h2>
<p>Lox features two looping control flow statements, <code>while</code> and <code>for</code>. The <code>while</code>
loop is the simpler one, so we&rsquo;ll start there. Its grammar is the same as in C.
Lox有两种类型的循环控制流语句，分别是<code>while</code>和<code>for</code>。<code>while</code>循环更简单一点，我们先从它开始.</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">whileStmt</span>      → <span class="s">&quot;while&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> <span class="i">statement</span> ;
</pre></div>
<p>We add another clause to the statement rule that points to the new rule for
while. It takes a <code>while</code> keyword, followed by a parenthesized condition
expression, then a statement for the body. That new grammar rule gets a <span
name="while-ast">syntax tree node</span>.
我们在<code>statement</code>规则中添加一个子句，指向while对应的新规则<code>whileStmt</code>。该规则接收一个<code>while</code>关键字，后跟一个带括号的条件表达式，然后是循环体对应的语句。新语法规则需要定义新的语法树节点。</p>
<div class="codehilite"><pre class="insert-before">      &quot;Print      : Expr expression&quot;,
</pre><pre class="insert-before">      <span class="s">&quot;Var        : Token name, Expr initializer&quot;</span><span class="insert-comma">,</span>
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()<br>
add <em>&ldquo;,&rdquo;</em> to previous line</div>
<pre class="insert">      <span class="s">&quot;While      : Expr condition, Stmt body&quot;</span>
</pre><pre class="insert-after">    ));
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), add <em>&ldquo;,&rdquo;</em> to previous line</div>

<aside name="while-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#while-statement">Appendix II</a>.
新节点的生成代码见<a href="appendix-ii.html#while-statement">附录 II</a>。</p>
</aside>
<p>The node stores the condition and body. Here you can see why it&rsquo;s nice to have
separate base classes for expressions and statements. The field declarations
make it clear that the condition is an expression and the body is a statement.
该节点中保存了条件式和循环体。这里就可以看出来为什么表达式和语句最好要有单独的基类。字段声明清楚地表明了，条件是一个表达式，循环主体是一个语句。</p>
<p>Over in the parser, we follow the same process we used for <code>if</code> statements.
First, we add another case in <code>statement()</code> to detect and match the leading
keyword.
在解析器中，我们遵循与<code>if</code>语句相同的处理步骤。首先，在 <code>statement()</code> 添加一个case分支检查并匹配开头的关键字。</p>
<div class="codehilite"><pre class="insert-before">    if (match(PRINT)) return printStatement();
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">WHILE</span>)) <span class="k">return</span> <span class="i">whileStatement</span>();
</pre><pre class="insert-after">    if (match(LEFT_BRACE)) return new Stmt.Block(block());
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>That delegates the real work to this method:
实际的工作委托给下面的方法：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>varDeclaration</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">whileStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;while&#39;.&quot;</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after condition.&quot;</span>);
    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>varDeclaration</em>()</div>

<p>The grammar is dead simple and this is a straight translation of it to Java.
Speaking of translating straight to Java, here&rsquo;s how we execute the new syntax:
语法非常简单，这里将其直接翻译为Java。说到直接翻译成Java，下面是我们执行新语法的方式：</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitWhileStmt</span>(<span class="t">Stmt</span>.<span class="t">While</span> <span class="i">stmt</span>) {
    <span class="k">while</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">body</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitVarStmt</em>()</div>

<p>Like the visit method for <code>if</code>, this visitor uses the corresponding Java
feature. This method isn&rsquo;t complex, but it makes Lox much more powerful. We can
finally write a program whose running time isn&rsquo;t strictly bound by the length of
the source code.
和<code>if</code>的访问方法一样，这里的访问方法使用了相应的Java特性。这个方法并不复杂，但它使Lox变得更加强大。我们终于可以编写一个运行时间不受源代码长度严格限制的程序了。</p>
<h2><a href="#for循环" id="for循环"><small>9&#8202;.&#8202;5</small>For循环</a></h2>
<p>We&rsquo;re down to the last control flow construct, <span name="for">Ye Olde</span>
C-style <code>for</code> loop. I probably don&rsquo;t need to remind you, but it looks like this:
我们已经到了最后一个控制流结构，即老式的C语言风格<code>for</code>循环。我可能不需要提醒你，但还是要说它看起来是这样的：</p>
<div class="codehilite"><pre><span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="n">10</span>; <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>) <span class="k">print</span> <span class="i">i</span>;
</pre></div>
<p>In grammarese, that&rsquo;s:
在语法中，是这样的：</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">forStmt</span>        → <span class="s">&quot;for&quot;</span> <span class="s">&quot;(&quot;</span> ( <span class="i">varDecl</span> | <span class="i">exprStmt</span> | <span class="s">&quot;;&quot;</span> )
                 <span class="i">expression</span>? <span class="s">&quot;;&quot;</span>
                 <span class="i">expression</span>? <span class="s">&quot;)&quot;</span> <span class="i">statement</span> ;
</pre></div>
<aside name="for">
<p>Most modern languages have a higher-level looping statement for iterating over
arbitrary user-defined sequences. C# has <code>foreach</code>, Java has &ldquo;enhanced for&rdquo;,
even C++ has range-based <code>for</code> statements now. Those offer cleaner syntax than
C&rsquo;s <code>for</code> statement by implicitly calling into an iteration protocol that the
object being looped over supports.
大多数现代语言都有高级循环语句，用于迭代用户定义的任意序列。C# 有 <code>foreach</code>，Java 有 &ldquo;enhanced for&rdquo;，甚至 C++ 现在也有基于范围的 <code>for</code> 语句。这些语句通过隐式调用被循环对象所支持的迭代协议，提供了比 C 的 for 语句更简洁的语法。</p>
<p>I love those. For Lox, though, we&rsquo;re limited by building up the interpreter a
chapter at a time. We don&rsquo;t have objects and methods yet, so we have no way of
defining an iteration protocol that the <code>for</code> loop could use. So we&rsquo;ll stick
with the old school C <code>for</code> loop. Think of it as &ldquo;vintage&rdquo;. The fixie of control
flow statements.
我喜欢这些语句。不过，对于 Lox 来说，我们只能一次一章地建立解释器。我们还没有对象和方法，因此无法定义 <code>for</code> 循环可以使用的迭代协议。因此，我们将坚持使用老式的 C <code>for</code> 循环。把它想象成 &ldquo;老古董&ldquo;。控制流语句的 &ldquo;老古董&ldquo;。</p>
</aside>
<p>Inside the parentheses, you have three clauses separated by semicolons:
在括号内，有三个由分号分隔的子语句：</p>
<ol>
<li>
<p>The first clause is the <em>initializer</em>. It is executed exactly once, before
anything else. It&rsquo;s usually an expression, but for convenience, we also
allow a variable declaration. In that case, the variable is scoped to the
rest of the <code>for</code> loop<span class="em">&mdash;</span>the other two clauses and the body.
第一个子句是<em>初始化式</em>。它只会在任何其它操作之前执行一次。它通常是一个表达式，但是为了便利，我们也允许一个变量声明。在这种情况下，变量的作用域就是<code>for</code>循环的其它部分——其余两个子式和循环体。</p>
</li>
<li>
<p>Next is the <em>condition</em>. As in a <code>while</code> loop, this expression controls when
to exit the loop. It&rsquo;s evaluated once at the beginning of each iteration,
including the first. If the result is truthy, it executes the loop body.
Otherwise, it bails.
接下来是<em>条件表达式</em>。与<code>while</code>循环一样，这个表达式控制了何时退出循环。它会在每次循环开始之前执行一次（包括第一次）。如果结果是真，就执行循环体；否则，就结束循环。</p>
</li>
<li>
<p>The last clause is the <em>increment</em>. It&rsquo;s an arbitrary expression that does
some work at the end of each loop iteration. The result of the expression is
discarded, so it must have a side effect to be useful. In practice, it
usually increments a variable.
最后一个子句是<em>增量式</em>。它是一个任意的表达式，会在每次循环结束的时候做一些工作。因为表达式的结果会被丢弃，所以它必须有副作用才能有用。在实践中，它通常会对变量进行递增。</p>
</li>
</ol>
<p>Any of these clauses can be omitted. Following the closing parenthesis is a
statement for the body, which is typically a block.
这些子语句都可以忽略。在右括号之后是一个语句作为循环体，通常是一个代码块。</p>
<h3><a href="#desugaring--语法脱糖" id="desugaring--语法脱糖"><small>9&#8202;.&#8202;5&#8202;.&#8202;1</small>Desugaring  语法脱糖</a></h3>
<p>That&rsquo;s a lot of machinery, but note that none of it does anything you couldn&rsquo;t
do with the statements we already have. If <code>for</code> loops didn&rsquo;t support
initializer clauses, you could just put the initializer expression before the
<code>for</code> statement. Without an increment clause, you could simply put the increment
expression at the end of the body yourself.
这里包含了很多配件，但是请注意，它所做的任何事情中，没有一件是无法用已有的语句实现的。如果<code>for</code>循环不支持初始化子句，你可以在<code>for</code>语句之前加一条初始化表达式。如果没有增量子语句，你可以直接把增量表达式放在循环体的最后。</p>
<p>In other words, Lox doesn&rsquo;t <em>need</em> <code>for</code> loops, they just make some common code
patterns more pleasant to write. These kinds of features are called <span
name="sugar"><strong>syntactic sugar</strong></span>. For example, the previous <code>for</code> loop
could be rewritten like so:
换句话说，Lox不<em>需要</em><code>for</code>循环，它们只是让一些常见的代码模式更容易编写。这类功能被称为<strong>语法糖</strong>。例如，前面的<code>for</code>循环可以改写成这样：</p>
<aside name="sugar">
<p>This delightful turn of phrase was coined by Peter J. Landin in 1964 to describe
how some of the nice expression forms supported by languages like ALGOL were a
sweetener sprinkled over the more fundamental<span class="em">&mdash;</span>but presumably less palatable<span class="em">&mdash;</span>lambda calculus underneath.
这个令人愉快的短语是由 Peter J. Landin 在1964年创造的，用来描述 ALGOL 等语言支持的一些很好的表达式形式是如何在更基本但可能不太令人满意的 lambda 演算的基础上增添一些小甜头的。</p><img class="above" src="image/control-flow/sugar.png" alt="Slightly more than a spoonful of sugar." />
</aside>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>;
  <span class="k">while</span> (<span class="i">i</span> &lt; <span class="n">10</span>) {
    <span class="k">print</span> <span class="i">i</span>;
    <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>;
  }
}
</pre></div>
<p>This script has the exact same semantics as the previous one, though it&rsquo;s not as
easy on the eyes. Syntactic sugar features like Lox&rsquo;s <code>for</code> loop make a language
more pleasant and productive to work in. But, especially in sophisticated
language implementations, every language feature that requires back-end support
and optimization is expensive.
虽然这个脚本不太容易看懂，但这个脚本与之前那个语义完全相同。像Lox中的<code>for</code>循环这样的语法糖特性可以使语言编写起来更加愉快和高效。但是，特别是在复杂的语言实现中，每一个需要后端支持和优化的语言特性都是代价昂贵的。</p>
<p>We can have our cake and eat it too by <span
name="caramel"><strong>desugaring</strong></span>. That funny word describes a process where
the front end takes code using syntax sugar and translates it to a more
primitive form that the back end already knows how to execute.
我们可以通过<strong>脱糖</strong>来吃这个蛋糕。这个有趣的词描述了这样一个过程：前端接收使用了语法糖的代码，并将其转换成后端知道如何执行的更原始的形式。</p>
<aside name="caramel">
<p>Oh, how I wish the accepted term for this was &ldquo;caramelization&rdquo;. Why introduce a
metaphor if you aren&rsquo;t going to stick with it?
哦，我多么希望这个公认的术语是 &ldquo;焦糖化&ldquo;。如果你不打算坚持，为什么要引入一个隐喻呢？</p>
</aside>
<p>We&rsquo;re going to desugar <code>for</code> loops to the <code>while</code> loops and other statements the
interpreter already handles. In our simple interpreter, desugaring really
doesn&rsquo;t save us much work, but it does give me an excuse to introduce you to the
technique. So, unlike the previous statements, we <em>won&rsquo;t</em> add a new syntax tree
node. Instead, we go straight to parsing. First, add an import we&rsquo;ll need soon.
我们将把<code>for</code>循环脱糖为<code>while</code>循环和其它解释器可处理的其它语句。在我们的简单解释器中，脱糖真的不能为我们节省很多工作，但它确实给了我一个契机来向你介绍这一技术。因此，与之前的语句不同，我们不会为<code>for</code>循环添加一个新的语法树节点。相反，我们会直接进行解析。首先，先引入一个我们要用到的依赖：</p>
<div class="codehilite"><pre class="insert-before">import java.util.ArrayList;
</pre><div class="source-file"><em>lox/Parser.java</em></div>
<pre class="insert"><span class="k">import</span> <span class="i">java.util.Arrays</span>;
</pre><pre class="insert-after">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em></div>

<p>Like every statement, we start parsing a <code>for</code> loop by matching its keyword.
像每个语句一样，我们通过匹配<code>for</code>关键字来解析循环。</p>
<div class="codehilite"><pre class="insert-before">  private Stmt statement() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">FOR</span>)) <span class="k">return</span> <span class="i">forStatement</span>();
</pre><pre class="insert-after">    if (match(IF)) return ifStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>Here is where it gets interesting. The desugaring is going to happen here, so
we&rsquo;ll build this method a piece at a time, starting with the opening parenthesis
before the clauses.
接下来是有趣的部分，脱糖也是在这里发生的，所以我们会一点点构建这个方法，首先从子句之前的左括号开始。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>statement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">forStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;for&#39;.&quot;</span>);

    <span class="c">// More here...</span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>

<p>The first clause following that is the initializer.
接下来的第一个子句是初始化式。</p>
<div class="codehilite"><pre class="insert-before">    consume(LEFT_PAREN, &quot;Expect '(' after 'for'.&quot;);

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Stmt</span> <span class="i">initializer</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">initializer</span> = <span class="k">null</span>;
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="i">VAR</span>)) {
      <span class="i">initializer</span> = <span class="i">varDeclaration</span>();
    } <span class="k">else</span> {
      <span class="i">initializer</span> = <span class="i">expressionStatement</span>();
    }
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>If the token following the <code>(</code> is a semicolon then the initializer has been
omitted. Otherwise, we check for a <code>var</code> keyword to see if it&rsquo;s a <span
name="variable">variable</span> declaration. If neither of those matched, it
must be an expression. We parse that and wrap it in an expression statement so
that the initializer is always of type Stmt.
如果<code>(</code>后面的标记是分号，那么初始化式就被省略了。否则，我们就检查<code>var</code>关键字，看它是否是一个变量声明。如果这两者都不符合，那么它一定是一个表达式。我们对其进行解析，并将其封装在一个表达式语句中，这样初始化器就必定属于Stmt类型。</p>
<aside name="variable">
<p>In a previous chapter, I said we can split expression and statement syntax trees
into two separate class hierarchies because there&rsquo;s no single place in the
grammar that allows both an expression and a statement. That wasn&rsquo;t <em>entirely</em>
true, I guess.
在前一章中，我说过我们可以将表达式和语句语法树分成两个独立的类层次结构，因为语法中没有一个地方同时允许表达式和语句。我想这并不 <em>完全</em> 正确。</p>
</aside>
<p>Next up is the condition.
接下来是条件表达式。</p>
<div class="codehilite"><pre class="insert-before">      initializer = expressionStatement();
    }
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

    <span class="t">Expr</span> <span class="i">condition</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">condition</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after loop condition.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Again, we look for a semicolon to see if the clause has been omitted. The last
clause is the increment.
同样，我们查找分号检查子句是否被忽略。最后一个子句是增量语句。</p>
<div class="codehilite"><pre class="insert-before">    consume(SEMICOLON, &quot;Expect ';' after loop condition.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

    <span class="t">Expr</span> <span class="i">increment</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">RIGHT_PAREN</span>)) {
      <span class="i">increment</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after for clauses.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>It&rsquo;s similar to the condition clause except this one is terminated by the
closing parenthesis. All that remains is the <span name="body">body</span>.
它类似于条件式子句，只是这个子句是由右括号终止的。剩下的就是循环主体了。</p>
<aside name="body">
<p>Is it just me or does that sound morbid? &ldquo;All that remained<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>was the <em>body</em>&rdquo;.
是我的错觉，还是这听起来很病态？&ldquo;剩下的<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span><span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>只有 <em>尸体(body, 主体)</em> &ldquo;。</p>
</aside>
<div class="codehilite"><pre class="insert-before">    consume(RIGHT_PAREN, &quot;Expect ')' after for clauses.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="i">body</span>;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>We&rsquo;ve parsed all of the various pieces of the <code>for</code> loop and the resulting AST
nodes are sitting in a handful of Java local variables. This is where the
desugaring comes in. We take those and use them to synthesize syntax tree nodes
that express the semantics of the <code>for</code> loop, like the hand-desugared example I
showed you earlier.
我们已经解析了<code>for</code>循环的所有部分，得到的AST节点也存储在一些Java本地变量中。这里也是脱糖开始的地方。我们利用这些变量来合成表示<code>for</code>循环语义的语法树节点，就像前面展示的手工脱糖的例子一样。</p>
<p>The code is a little simpler if we work backward, so we start with the increment
clause.
如果我们从后向前处理，代码会更简单一些，所以我们从增量子句开始。</p>
<div class="codehilite"><pre class="insert-before">    Stmt body = statement();

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">increment</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(
          <span class="t">Arrays</span>.<span class="i">asList</span>(
              <span class="i">body</span>,
              <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Expression</span>(<span class="i">increment</span>)));
    }

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>The increment, if there is one, executes after the body in each iteration of the
loop. We do that by replacing the body with a little block that contains the
original body followed by an expression statement that evaluates the increment.
如果存在增量子句的话，会在循环的每个迭代中在循环体结束之后执行。我们用一个代码块来代替循环体，这个代码块中包含原始的循环体，后面跟一个执行增量子语句的表达式语句。</p>
<div class="codehilite"><pre class="insert-before">    }

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">condition</span> == <span class="k">null</span>) <span class="i">condition</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">true</span>);
    <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Next, we take the condition and the body and build the loop using a primitive
<code>while</code> loop. If the condition is omitted, we jam in <code>true</code> to make an infinite
loop.
接下来，我们获取条件式和循环体，并通过基本的<code>while</code>语句构建对应的循环。如果条件式被省略了，我们就使用<code>true</code>来创建一个无限循环。</p>
<div class="codehilite"><pre class="insert-before">    body = new Stmt.While(condition, body);

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(<span class="t">Arrays</span>.<span class="i">asList</span>(<span class="i">initializer</span>, <span class="i">body</span>));
    }

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Finally, if there is an initializer, it runs once before the entire loop. We do
that by, again, replacing the whole statement with a block that runs the
initializer and then executes the loop.
最后，如果有初始化式，它会在整个循环之前运行一次。我们的做法是，再次用代码块来替换整个语句，该代码块中首先运行一个初始化式，然后执行循环。</p>
<p>That&rsquo;s it. Our interpreter now supports C-style <code>for</code> loops and we didn&rsquo;t have
to touch the Interpreter class at all. Since we desugared to nodes the
interpreter already knows how to visit, there is no more work to do.
就是这样。我们的解释器现在已经支持了C语言风格的<code>for</code>循环，而且我们根本不需要修改解释器类。因为我们通过脱糖将其转换为了解释器已经知道如何访问的节点，所以无需做其它的工作。</p>
<p>Finally, Lox is powerful enough to entertain us, at least for a few minutes.
Here&rsquo;s a tiny program to print the first 21 elements in the Fibonacci
sequence:
最后，Lox已强大到足以娱乐我们，至少几分钟。下面是一个打印斐波那契数列前21个元素的小程序：</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">0</span>;
<span class="k">var</span> <span class="i">temp</span>;

<span class="k">for</span> (<span class="k">var</span> <span class="i">b</span> = <span class="n">1</span>; <span class="i">a</span> &lt; <span class="n">10000</span>; <span class="i">b</span> = <span class="i">temp</span> + <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span>;
  <span class="i">temp</span> = <span class="i">a</span>;
  <span class="i">a</span> = <span class="i">b</span>;
}
</pre></div>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>A few chapters from now, when Lox supports first-class functions and dynamic
dispatch, we technically won&rsquo;t <em>need</em> branching statements built into the
language. Show how conditional execution can be implemented in terms of
those. Name a language that uses this technique for its control flow.
在接下来的几章中，当Lox支持一级函数和动态调度时，从技术上讲，我们就不需要在语言中内置分支语句。说明如何用这些特性来实现条件执行。说出一种在控制流中使用这种技术的语言。</p>
</li>
<li>
<p>Likewise, looping can be implemented using those same tools, provided our
interpreter supports an important optimization. What is it, and why is it
necessary? Name a language that uses this technique for iteration.
同样地，只要我们的解释器支持一个重要的优化，循环也可以用这些工具来实现。它是什么？为什么它是必要的？请说出一种使用这种技术进行迭代的语言。</p>
</li>
<li>
<p>Unlike Lox, most other C-style languages also support <code>break</code> and <code>continue</code>
statements inside loops. Add support for <code>break</code> statements.</p>
<p>The syntax is a <code>break</code> keyword followed by a semicolon. It should be a
syntax error to have a <code>break</code> statement appear outside of any enclosing
loop. At runtime, a <code>break</code> statement causes execution to jump to the end of
the nearest enclosing loop and proceeds from there. Note that the <code>break</code>
may be nested inside other blocks and <code>if</code> statements that also need to be
exited.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: 一些语法糖</a></h2>
<p>When you design your own language, you choose how much syntactic sugar to pour
into the grammar. Do you make an unsweetened health food where each semantic
operation maps to a single syntactic unit, or some decadent dessert where every
bit of behavior can be expressed ten different ways? Successful languages
inhabit all points along this continuum.</p>
<p>On the extreme acrid end are those with ruthlessly minimal syntax like Lisp,
Forth, and Smalltalk. Lispers famously claim their language &ldquo;has no syntax&rdquo;,
while Smalltalkers proudly show that you can fit the entire grammar on an index
card. This tribe has the philosophy that the <em>language</em> doesn&rsquo;t need syntactic
sugar. Instead, the minimal syntax and semantics it provides are powerful enough
to let library code be as expressive as if it were part of the language itself.</p>
<p>Near these are languages like C, Lua, and Go. They aim for simplicity and
clarity over minimalism. Some, like Go, deliberately eschew both syntactic sugar
and the kind of syntactic extensibility of the previous category. They want the
syntax to get out of the way of the semantics, so they focus on keeping both the
grammar and libraries simple. Code should be obvious more than beautiful.</p>
<p>Somewhere in the middle you have languages like Java, C#, and Python. Eventually
you reach Ruby, C++, Perl, and D<span class="em">&mdash;</span>languages which have stuffed so much syntax
into their grammar, they are running out of punctuation characters on the
keyboard.</p>
<p>To some degree, location on the spectrum correlates with age. It&rsquo;s relatively
easy to add bits of syntactic sugar in later releases. New syntax is a crowd
pleaser, and it&rsquo;s less likely to break existing programs than mucking with the
semantics. Once added, you can never take it away, so languages tend to sweeten
with time. One of the main benefits of creating a new language from scratch is
it gives you an opportunity to scrape off those accumulated layers of frosting
and start over.</p>
<p>Syntactic sugar has a bad rap among the PL intelligentsia. There&rsquo;s a real fetish
for minimalism in that crowd. There is some justification for that. Poorly
designed, unneeded syntax raises the cognitive load without adding enough
expressiveness to carry its weight. Since there is always pressure to cram new
features into the language, it takes discipline and a focus on simplicity to
avoid bloat. Once you add some syntax, you&rsquo;re stuck with it, so it&rsquo;s smart to be
parsimonious.</p>
<p>At the same time, most successful languages do have fairly complex grammars, at
least by the time they are widely used. Programmers spend a ton of time in their
language of choice, and a few niceties here and there really can improve the
comfort and efficiency of their work.</p>
<p>Striking the right balance<span class="em">&mdash;</span>choosing the right level of sweetness for your
language<span class="em">&mdash;</span>relies on your own sense of taste.</p>
</div>
<div class="design-note">
<p>当你设计自己的语言时，你可以选择在语法中注入多少语法糖。你是要做一种不加糖、每个语法操作都对应单一的语法单元的健康食品？还是每一点行为都可以用10种不同方式实现的堕落的甜点？把这两种情况看作是两端的话，成功的语言分布在这个连续体的每个中间点。</p>
<p>极端尖刻的一侧是那些语法极少的语言，如Lisp、Forth和SmallTalk。Lisp的拥趸广泛声称他们的语言 &ldquo;没有语法&ldquo;，而Smalltalk的人则自豪地表示，你可以把整个语法放在一张索引卡上。这个部落的理念是，语言不需要句法糖。相反，它所提供的最小的语法和语义足够强大，足以让库中的代码像语言本身的一部分一样具有表现力。</p>
<p>接近这些的是像C、Lua和Go这样的语言。他们的目标是简单和清晰，而不是极简主义。有些语言，如Go，故意避开了语法糖和前一类语言的语法扩展性。他们希望语法不受语义的影响，所以他们专注于保持语法和库的简单性。代码应该是明显的，而不是漂亮的。</p>
<p>介于之间的是Java、C#和Python等语言。最终，你会看到Ruby、C++、Perl和D-语言，它们在语法中塞入了太多的句法规则，以至于键盘上的标点符号都快用完了。</p>
<p>在某种程度上，频谱上的位置与年龄相关。在后续的版本中增加一些语法糖是比较容易的。新的语法很容易让人喜欢，而且与修改语义相比，它更不可能破坏现有的程序。一旦加进去，你就再也不能把它去掉了，所以随着时间的推移，语言会变得越来越甜。从头开始创建一门新语言的主要好处之一是，它给了你一个机会去刮掉那些累积的糖霜并重新开始。</p>
<p>语法糖在PL知识分子中名声不佳。那群人对极简主义有一种真正的迷恋。这是有一定道理的。设计不良的、不必要的语法增加了认知负荷，却没有增加相匹配的表达能力。因为一直会有向语言中添加新特性的压力，所以需要自律并专注于简单，以避免臃肿。一旦你添加了一些语法，你就会被它困住，所以明智的做法是要精简。</p>
<p>同时，大多数成功的语言都有相当复杂的语法，至少在它们被广泛使用的时候是这样。程序员在他们所选择的语言上花费了大量的时间，一些随处可见的细节确实可以提高他们工作时的舒适度和效率。</p>
<p>找到正确的平衡——为你的语言选择适当的甜度——取决于你自己的品味。</p>
</div>

    <footer>
      <a href="functions.html" class="next">
        下一节: &ldquo;函数&rdquo; &rarr;
      </a>
      Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a
        href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy;
        2015&hairsp;&ndash;&hairsp;2021</a>
    </footer>
  </article>

  </div>
  </body>
  </html>
