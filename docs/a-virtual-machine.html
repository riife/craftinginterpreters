<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>虚拟机 &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
        <h3><a href="#top">虚拟机<small>15</small></a></h3>
    
    <ul>
        <li><a href="#指令执行机器"><small>15.1</small> 指令执行机器</a></li>
        <li><a href="#一个值栈操作器"><small>15.2</small> 一个值栈操作器</a></li>
        <li><a href="#数学计算器"><small>15.3</small> 数学计算器</a></li>
        <li class="divider"></li>
        <li class="end-part"><a href="#challenges">Challenges</a></li>
        <li class="end-part"><a href="#design-note"><small>note</small>基于寄存器的字节码</a></li>
    </ul>
    
    
        <div class="prev-next">
        <a href="chunks-of-bytecode.html" title="字节码块" class="left">&larr;&nbsp;Previous</a>
        <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
        <a href="scanning-on-demand.html" title="按需扫描" class="right">Next&nbsp;&rarr;</a>
    </div> </div>
</nav>

<nav class="narrow">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <a href="chunks-of-bytecode.html" title="字节码块" class="prev">←</a>
  <a href="scanning-on-demand.html" title="按需扫描" class="next">→</a>
</nav>

<div class="page">
  <div class="nav-wrapper">
    <nav class="floating">
      <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
      <div class="expandable">
        <h3><a href="#top">虚拟机<small>15</small></a></h3>
        
        <ul>
            <li><a href="#指令执行机器"><small>15.1</small> 指令执行机器</a></li>
            <li><a href="#一个值栈操作器"><small>15.2</small> 一个值栈操作器</a></li>
            <li><a href="#数学计算器"><small>15.3</small> 数学计算器</a></li>
            <li class="divider"></li>
            <li class="end-part"><a href="#challenges">Challenges</a></li>
            <li class="end-part"><a href="#design-note"><small>note</small>基于寄存器的字节码</a></li>
        </ul>
        
        
                <div class="prev-next">
            <a href="chunks-of-bytecode.html" title="字节码块" class="left">&larr;&nbsp;Previous</a>
            <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
            <a href="scanning-on-demand.html" title="按需扫描" class="right">Next&nbsp;&rarr;</a>
        </div>      </div>
      <a id="expand-nav">≡</a>
    </nav>
  </div>

  <article class="chapter">

    <div class="number">15</div>
    <h1>虚拟机</h1>

    <blockquote>
<p>Magicians protect their secrets not because the secrets are large and
important, but because they are so small and trivial. The wonderful effects
created on stage are often the result of a secret so absurd that the magician
would be embarrassed to admit that that was how it was done.</p>
<p><cite>Christopher Priest, <em>The Prestige</em></cite>
魔术师们之所以保护他们的秘密，并不是因为秘密很大、很重要，而是它们是如此小而微不足道。在舞台上创造出的奇妙效果往往源自于一个荒谬的小秘密，以至于魔术师都不好意思承认这是如何完成的。</p>
</blockquote>
<p>We&rsquo;ve spent a lot of time talking about how to represent a program as a sequence
of bytecode instructions, but it feels like learning biology using only stuffed,
dead animals. We know what instructions are in theory, but we&rsquo;ve never seen them
in action, so it&rsquo;s hard to really understand what they <em>do</em>. It would be hard to
write a compiler that outputs bytecode when we don&rsquo;t have a good understanding
of how that bytecode behaves.
我们已经花了很多时间讨论如何将程序表示为字节码指令序列，但是这感觉像是只用填充的死动物来学习生物学。我们知道理论上的指令是什么，但我们在实际操作中从未见过，因此很难真正理解指令的<em>作用</em>。如果我们不能很好地理解字节码的行为方式，就很难编写输出字节码的编译器。</p>
<p>So, before we go and build the front end of our new interpreter, we will begin
with the back end<span class="em">&mdash;</span>the virtual machine that executes instructions. It breathes
life into the bytecode. Watching the instructions prance around gives us a
clearer picture of how a compiler might translate the user&rsquo;s source code into a
series of them.
因此，在构建新解释器的前端之前，我们先从后端开始——执行指令的虚拟机。它为字节码注入了生命。通过观察这些指令的运行，我们可以更清楚地了解编译器如何将用户的源代码转换成一系列的指令。</p>
<h2><a href="#指令执行机器" id="指令执行机器"><small>15&#8202;.&#8202;1</small>指令执行机器</a></h2>
<p>The virtual machine is one part of our interpreter&rsquo;s internal architecture. You
hand it a chunk of code<span class="em">&mdash;</span>literally a Chunk<span class="em">&mdash;</span>and it runs it. The code and
data structures for the VM reside in a new module.
虚拟机是我们解释器内部结构的一部分。你把一个代码块交给它，它就会运行这块代码。VM的代码和数据结构放在一个新的模块中。</p>
<div class="codehilite"><div class="source-file"><em>vm.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_vm_h</span>
<span class="a">#define clox_vm_h</span>

<span class="a">#include &quot;chunk.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Chunk</span>* <span class="i">chunk</span>;
} <span class="a">VM</span>;

<span class="t">void</span> <span class="i">initVM</span>();
<span class="t">void</span> <span class="i">freeVM</span>();

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, create new file</div>

<p>As usual, we start simple. The VM will gradually acquire a whole pile of state
it needs to keep track of, so we define a struct now to stuff that all in.
Currently, all we store is the chunk that it executes.
跟之前一样，我们从简单的部分开始。VM会逐步获取到一大堆它需要跟踪的状态，所以我们现在定义一个结构，把这些状态都塞进去。目前，我们只存储它执行的代码块。</p>
<p>Like we do with most of the data structures we create, we also define functions
to create and tear down a VM. Here&rsquo;s the implementation:
与我们创建的大多数数据结构类似，我们也会定义用来创建和释放虚拟机的函数。下面是其对应实现：</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
create new file</div>
<pre><span class="a">#include &quot;common.h&quot;</span>
<span class="a">#include &quot;vm.h&quot;</span>

<span class="a">VM</span> <span class="i">vm</span>;<span name="one"> </span>

<span class="t">void</span> <span class="i">initVM</span>() {
}

<span class="t">void</span> <span class="i">freeVM</span>() {
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, create new file</div>

<p>OK, calling those functions &ldquo;implementations&rdquo; is a stretch. We don&rsquo;t have any
interesting state to initialize or free yet, so the functions are empty. Trust
me, we&rsquo;ll get there.
好吧，把这些函数称为“实现”有点牵强了。我们目前还没有任何感兴趣的状态需要初始化或释放，所以这些函数是空的。相信我，我们终会实现它的。</p>
<p>The slightly more interesting line here is that declaration of <code>vm</code>. This module
is eventually going to have a slew of functions and it would be a chore to pass
around a pointer to the VM to all of them. Instead, we declare a single global
VM object. We need only one anyway, and this keeps the code in the book a little
lighter on the page.
这里稍微有趣的一行是<code>vm</code>的声明。这个模块最终会有一系列的函数，如果要将一个指向VM的指针传递给所有的函数，那就太麻烦了。相反，我们声明了一个全局VM对象。反正我们只需要一个虚拟机对象，这样可以让本书中的代码在页面上更轻便。</p>
<aside name="one">
<p>The choice to have a static VM instance is a concession for the book, but not
necessarily a sound engineering choice for a real language implementation. If
you&rsquo;re building a VM that&rsquo;s designed to be embedded in other host applications,
it gives the host more flexibility if you <em>do</em> explicitly take a VM pointer
and pass it around.</p>
<p>That way, the host app can control when and where memory for the VM is
allocated, run multiple VMs in parallel, etc.</p>
<p>What I&rsquo;m doing here is a global variable, and <a href="http://gameprogrammingpatterns.com/singleton.html">everything bad you&rsquo;ve heard about
global variables</a> is still true when programming in the large. But when
keeping things small for a book<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
</aside>
<p>Before we start pumping fun code into our VM, let&rsquo;s go ahead and wire it up to
the interpreter&rsquo;s main entrypoint.
在我们开始向虚拟机中添加有效代码之前，我们先将其连接到解释器的主入口点。</p>
<div class="codehilite"><pre class="insert-before">int main(int argc, const char* argv[]) {
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">initVM</span>();

</pre><pre class="insert-after">  Chunk chunk;
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>We spin up the VM when the interpreter first starts. Then when we&rsquo;re about to
exit, we wind it down.
当解释器第一次启动时，我们也启动虚拟机。然后当我们要退出时，我们将其关闭。</p>
<div class="codehilite"><pre class="insert-before">  disassembleChunk(&amp;chunk, &quot;test chunk&quot;);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">freeVM</span>();
</pre><pre class="insert-after">  freeChunk(&amp;chunk);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>One last ceremonial obligation:
最后一项仪式性任务：</p>
<div class="codehilite"><pre class="insert-before">#include &quot;debug.h&quot;
</pre><div class="source-file"><em>main.c</em></div>
<pre class="insert"><span class="a">#include &quot;vm.h&quot;</span>
</pre><pre class="insert-after">

int main(int argc, const char* argv[]) {
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>

<p>Now when you run clox, it starts up the VM before it creates that hand-authored
chunk from the <a href="chunks-of-bytecode.html#disassembling-chunks">last chapter</a>. The VM is ready and waiting, so let&rsquo;s teach it
to do something.
现在如果你运行clox，它会先启动虚拟机，再创建上一章中的手写代码块。虚拟机已经就绪了，我们来教它一些事情吧。</p>
<h3><a href="#执行指令" id="执行指令"><small>15&#8202;.&#8202;1&#8202;.&#8202;1</small>执行指令</a></h3>
<p>The VM springs into action when we command it to interpret a chunk of bytecode.
当我们命令VM解释一个字节码块时，它就会开始启动了。</p>
<div class="codehilite"><pre class="insert-before">  disassembleChunk(&amp;chunk, &quot;test chunk&quot;);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">interpret</span>(&amp;<span class="i">chunk</span>);
</pre><pre class="insert-after">  freeVM();
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>This function is the main entrypoint into the VM. It&rsquo;s declared like so:
这个函数是进入VM的主要入口。它的声明如下：</p>
<div class="codehilite"><pre class="insert-before">void freeVM();
</pre><div class="source-file"><em>vm.h</em><br>
add after <em>freeVM</em>()</div>
<pre class="insert"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>freeVM</em>()</div>

<p>The VM runs the chunk and then responds with a value from this enum:
VM会运行字节码块，然后返回下面枚举中的一个值作为响应：</p>
<div class="codehilite"><pre class="insert-before">} VM;

</pre><div class="source-file"><em>vm.h</em><br>
add after struct <em>VM</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">INTERPRET_OK</span>,
  <span class="a">INTERPRET_COMPILE_ERROR</span>,
  <span class="a">INTERPRET_RUNTIME_ERROR</span>
} <span class="t">InterpretResult</span>;

</pre><pre class="insert-after">void initVM();
void freeVM();
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after struct <em>VM</em></div>

<p>We aren&rsquo;t using the result yet, but when we have a compiler that reports static
errors and a VM that detects runtime errors, the interpreter will use this to
know how to set the exit code of the process.
我们现在还不会使用这个结果，但是当我们有一个报告静态错误的编译器和检测运行时错误的VM时，解释器会通过它来知道如何设置进程的退出代码。</p>
<p>We&rsquo;re inching towards some actual implementation.
我们正逐步走向一些真正的实现。</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>freeVM</em>()</div>
<pre><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>) {
  <span class="i">vm</span>.<span class="i">chunk</span> = <span class="i">chunk</span>;
  <span class="i">vm</span>.<span class="i">ip</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>;
  <span class="k">return</span> <span class="i">run</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>

<p>First, we store the chunk being executed in the VM. Then we call <code>run()</code>, an
internal helper function that actually runs the bytecode instructions. Between
those two parts is an intriguing line. What is this <code>ip</code> business?
首先，我们在虚拟机中存储正在执行的块。然后我们调用<code>run()</code>，这是一个内部辅助函数，实际运行字节码指令。在这两部分之间，有一条耐人寻味的线。这个<code>ip</code>作用是什么？</p>
<p>As the VM works its way through the bytecode, it keeps track of where it is<span class="em">&mdash;</span>the location of the instruction currently being executed. We don&rsquo;t use a <span
name="local">local</span> variable inside <code>run()</code> for this because eventually
other functions will need to access it. Instead, we store it as a field in VM.
当虚拟机运行字节码时，它会记录它在哪里——即当前执行的指令所在的位置。我们没有在<code>run()</code>方法中使用局部变量来进行记录，因为最终其它函数也会访问该值。相对地，我们将其作为一个字段存储在VM中。</p>
<aside name="local">
<p>If we were trying to squeeze every ounce of speed out of our bytecode
interpreter, we would store <code>ip</code> in a local variable. It gets modified so often
during execution that we want the C compiler to keep it in a register.</p>
</aside>
<div class="codehilite"><pre class="insert-before">typedef struct {
  Chunk* chunk;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">uint8_t</span>* <span class="i">ip</span>;
</pre><pre class="insert-after">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>Its type is a byte pointer. We use an actual real C pointer pointing right into
the middle of the bytecode array instead of something like an integer index
because it&rsquo;s faster to dereference a pointer than look up an element in an array
by index.
它的类型是一个字节指针。我们使用一个真正的C指针指向字节码数组的中间，而不是使用类似整数索引这种方式，这是因为对指针的引用比通过索引查找数组中的一个元素要更快。</p>
<p>The name &ldquo;IP&rdquo; is traditional, and<span class="em">&mdash;</span>unlike many traditional names in CS<span class="em">&mdash;</span>actually makes sense: it&rsquo;s an <strong><a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a></strong>. Almost every
instruction set in the <span name="ip">world</span>, real and virtual, has a
register or variable like this.</p>
<aside name="ip">
<p>x86, x64, and the CLR call it &ldquo;IP&rdquo;. 68k, PowerPC, ARM, p-code, and the JVM call
it &ldquo;PC&rdquo;, for <strong>program counter</strong>.</p>
</aside>
<p>We initialize <code>ip</code> by pointing it at the first byte of code in the chunk. We
haven&rsquo;t executed that instruction yet, so <code>ip</code> points to the instruction <em>about
to be executed</em>. This will be true during the entire time the VM is running: the
IP always points to the next instruction, not the one currently being handled.
我们通过将<code>ip</code>指向块中的第一个字节码来对其初始化。我们还没有执行该指令，所以<code>ip</code>指向<em>即将执行</em>的指令。在虚拟机执行的整个过程中都是如此：IP总是指向下一条指令，而不是当前正在处理的指令。</p>
<p>The real fun happens in <code>run</code>().
真正有趣的部分在<code>run()</code>中。</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>freeVM</em>()</div>
<pre><span class="k">static</span> <span class="t">InterpretResult</span> <span class="i">run</span>() {
<span class="a">#define READ_BYTE() (*vm.ip++)</span>

  <span class="k">for</span> (;;) {
    <span class="t">uint8_t</span> <span class="i">instruction</span>;
    <span class="k">switch</span> (<span class="i">instruction</span> = <span class="a">READ_BYTE</span>()) {
      <span class="k">case</span> <span class="a">OP_RETURN</span>: {
        <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
      }
    }
  }

<span class="a">#undef READ_BYTE</span>
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>

<p>This is the single most <span name="important">important</span> function in all
of clox, by far. When the interpreter executes a user&rsquo;s program, it will spend
something like 90% of its time inside <code>run()</code>. It is the beating heart of the
VM.
到目前为止，这是clox中最重要的一个函数。当解释器执行用户的程序时，它有大约90%的时间是在<code>run()</code>中。它是虚拟机跳动的心脏。</p>
<aside name="important">
<p>Or, at least, it <em>will</em> be in a few chapters when it has enough content to be
useful. Right now, it&rsquo;s not exactly a wonder of software wizardry.</p>
</aside>
<p>Despite that dramatic intro, it&rsquo;s conceptually pretty simple. We have an outer
loop that goes and goes. Each turn through that loop, we read and execute a
single bytecode instruction.
尽管这个介绍很戏剧性，但从概念上来说很简单。我们有一个不断进行的外层循环。每次循环中，我们会读取并执行一条字节码指令。</p>
<p>To process an instruction, we first figure out what kind of instruction we&rsquo;re
dealing with. The <code>READ_BYTE</code> macro reads the byte currently pointed at by <code>ip</code>
and then <span name="next">advances</span> the instruction pointer. The first
byte of any instruction is the opcode. Given a numeric opcode, we need to get to
the right C code that implements that instruction&rsquo;s semantics. This process is
called <strong>decoding</strong> or <strong>dispatching</strong> the instruction.
为了处理一条指令，我们首先需要弄清楚要处理的是哪种指令。<code>READ_BYTE</code>这个宏会读取<code>ip</code>当前指向字节，然后推进指令指针。任何指令的第一个字节都是操作码。给定一个操作码，我们需要找到实现该指令语义的正确的C代码。这个过程被称为<strong>解码</strong>或指令<strong>分派</strong>。</p>
<aside name="next">
<p>Note that <code>ip</code> advances as soon as we read the opcode, before we&rsquo;ve actually
started executing the instruction. So, again, <code>ip</code> points to the <em>next</em>
byte of code to be used.</p>
</aside>
<p>We do that process for every single instruction, every single time one is
executed, so this is the most performance critical part of the entire virtual
machine. Programming language lore is filled with <span
name="dispatch">clever</span> techniques to do bytecode dispatch efficiently,
going all the way back to the early days of computers.
每一条指令，每一次执行时，我们都会进行这个过程，所以这是整个虚拟机性能最关键的部分。编程语言的传说中充满了高效进行字节码分派的各种奇技淫巧，一直可以追溯到计算机的早期。</p>
<aside name="dispatch">
<p>If you want to learn some of these techniques, look up &ldquo;direct threaded code&rdquo;,
&ldquo;jump table&rdquo;, and &ldquo;computed goto&rdquo;.</p>
</aside>
<p>Alas, the fastest solutions require either non-standard extensions to C, or
handwritten assembly code. For clox, we&rsquo;ll keep it simple. Just like our
disassembler, we have a single giant <code>switch</code> statement with a case for each
opcode. The body of each case implements that opcode&rsquo;s behavior.
可惜的是，最快的解决方案要么需要对C进行非标准的扩展，要么需要手写汇编代码。对于clox，我们要保持简单。就像我们的反汇编程序一样，我们写一个巨大的<code>switch</code>语句，其中每个case对应一个操作码。每个case代码体实现了操作码的行为。</p>
<p>So far, we handle only a single instruction, <code>OP_RETURN</code>, and the only thing it
does is exit the loop entirely. Eventually, that instruction will be used to
return from the current Lox function, but we don&rsquo;t have functions yet, so we&rsquo;ll
repurpose it temporarily to end the execution.
到目前为止，我们只处理了一条指令，<code>OP_RETURN</code>，而它做的唯一的事情就是完全退出循环。最终，该指令将被用于从当前的Lox函数返回，但是我们目前还没有函数，所以我们暂时用它来结束代码执行。</p>
<p>Let&rsquo;s go ahead and support our one other instruction.
让我们继续支持另一个指令。</p>
<div class="codehilite"><pre class="insert-before">    switch (instruction = READ_BYTE()) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CONSTANT</span>: {
        <span class="t">Value</span> <span class="i">constant</span> = <span class="a">READ_CONSTANT</span>();
        <span class="i">printValue</span>(<span class="i">constant</span>);
        <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We don&rsquo;t have enough machinery in place yet to do anything useful with a
constant. For now, we&rsquo;ll just print it out so we interpreter hackers can see
what&rsquo;s going on inside our VM. That call to <code>printf()</code> necessitates an include.
我们还没有足够的机制来使用常量做任何有用的事。现在，我们只是把它打印出来，这样我们这些解释器黑客就可以看到我们的VM内部发生了什么。调用<code>printf()</code>方法需要进行include。</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add to top of file</div>
<pre class="insert"><span class="a">#include &lt;stdio.h&gt;</span>

</pre><pre class="insert-after">#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add to top of file</div>

<p>We also have a new macro to define.
我们还需要定义一个新的宏。
<u><em>vm.c，在 run()方法中添加代码：</em></u></p>
<div class="codehilite"><pre class="insert-before">#define READ_BYTE() (*vm.ip++)
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])</span>
</pre><pre class="insert-after">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p><code>READ_CONSTANT()</code> reads the next byte from the bytecode, treats the resulting
number as an index, and looks up the corresponding Value in the chunk&rsquo;s constant
table. In later chapters, we&rsquo;ll add a few more instructions with operands that
refer to constants, so we&rsquo;re setting up this helper macro now.
<code>READ_CONTANT()</code>从字节码中读取下一个字节，将得到的数字作为索引，并在代码块的常量表中查找相应的Value。在后面的章节中，我们将添加一些操作数指向常量的指令，所以我们现在要设置这个辅助宏。
Like the previous <code>READ_BYTE</code> macro, <code>READ_CONSTANT</code> is only used inside <code>run()</code>. To make that scoping more explicit, the macro definitions themselves are confined to that function. We define them at the beginning and—because we care—undefine them at the end.
与之前的<code>READ_BYTE</code>宏类似，<code>READ_CONSTANT</code>只会在<code>run()</code>方法中使用。为了使作用域更明确，宏定义本身要被限制在该函数中。我们在开始时定义了它们，然后因为我们比较关心，在结束时取消它们的定义。</p>
<p>Like the previous <code>READ_BYTE</code> macro, <code>READ_CONSTANT</code> is only used inside
<code>run()</code>. To make that scoping more explicit, the macro definitions themselves
are confined to that function. We <span name="macro">define</span> them at the
beginning and<span class="em">&mdash;</span>because we care<span class="em">&mdash;</span>undefine them at the end.</p>
<div class="codehilite"><pre class="insert-before">#undef READ_BYTE
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef READ_CONSTANT</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<aside name="macro">
<p>Undefining these macros explicitly might seem needlessly fastidious, but C tends
to punish sloppy users, and the C preprocessor doubly so.</p>
</aside>
<h3><a href="#执行跟踪" id="执行跟踪"><small>15&#8202;.&#8202;1&#8202;.&#8202;2</small>执行跟踪</a></h3>
<p>If you run clox now, it executes the chunk we hand-authored in the last chapter
and spits out <code>1.2</code> to your terminal. We can see that it&rsquo;s working, but that&rsquo;s
only because our implementation of <code>OP_CONSTANT</code> has temporary code to log the
value. Once that instruction is doing what it&rsquo;s supposed to do and plumbing that
constant along to other operations that want to consume it, the VM will become a
black box. That makes our lives as VM implementers harder.
如果现在运行clox，它会执行我们在上一章中手工编写的字节码块，并向终端输出1.2。我们可以看到它在工作，但这是因为我们在<code>OP_CONSTANT</code>的实现中，使用临时代码记录了这个值。一旦该指令执行了它应做的操作，并将取得的常量传递给其它想要使用该常量的操作，虚拟机就会变成一个黑盒子。这使得我们作为虚拟机实现者的工作更加艰难。</p>
<p>To help ourselves out, now is a good time to add some diagnostic logging to the
VM like we did with chunks themselves. In fact, we&rsquo;ll even reuse the same code.
We don&rsquo;t want this logging enabled all the time<span class="em">&mdash;</span>it&rsquo;s just for us VM hackers,
not Lox users<span class="em">&mdash;</span>so first we create a flag to hide it behind.
为了帮助我们自己解脱这种困境，现在是给虚拟机添加一些诊断性日志的好时机，就像我们对代码块本身所做的那样。事实上，我们甚至会重用相同的代码。我们不希望一直启用这个日志——它只针对我们这些虚拟机开发者，而不是Lox用户——所以我们首先创建一个标志来隐藏它。</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdint.h&gt;
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert">

<span class="a">#define DEBUG_TRACE_EXECUTION</span>
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>When this flag is defined, the VM disassembles and prints each instruction right
before executing it. Where our previous disassembler walked an entire chunk
once, statically, this disassembles instructions dynamically, on the fly.
定义了这个标志之后，虚拟机在执行每条指令之前都会反汇编并将其打印出来。我们之前的反汇编程序只是静态地遍历一次整个字节码块，而这个反编译程序则是动态地、即时地对指令进行反汇编。</p>
<div class="codehilite"><pre class="insert-before">  for (;;) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#ifdef DEBUG_TRACE_EXECUTION</span>
    <span class="i">disassembleInstruction</span>(<span class="i">vm</span>.<span class="i">chunk</span>,
                           (<span class="t">int</span>)(<span class="i">vm</span>.<span class="i">ip</span> - <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>));
<span class="a">#endif</span>

</pre><pre class="insert-after">    uint8_t instruction;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Since <code>disassembleInstruction()</code> takes an integer byte <em>offset</em> and we store the
current instruction reference as a direct pointer, we first do a little pointer
math to convert <code>ip</code> back to a relative offset from the beginning of the
bytecode. Then we disassemble the instruction that begins at that byte.
由于 <code>disassembleInstruction()</code> 方法接收一个整数<code>offset</code>作为字节偏移量，而我们将当前指令引用存储为一个直接指针，所以我们首先要做一个小小的指针运算，将<code>ip</code>转换成从字节码开始的相对偏移量。然后，我们对从该字节开始的指令进行反汇编。</p>
<p>As ever, we need to bring in the declaration of the function before we can call
it.
跟之前一样，我们需要在调用函数之前先引入函数的声明。</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &quot;debug.h&quot;</span>
</pre><pre class="insert-after">#include &quot;vm.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<p>I know this code isn&rsquo;t super impressive so far<span class="em">&mdash;</span>it&rsquo;s literally a switch
statement wrapped in a <code>for</code> loop but, believe it or not, this is one of the two
major components of our VM. With this, we can imperatively execute instructions.
Its simplicity is a virtue<span class="em">&mdash;</span>the less work it does, the faster it can do it.
Contrast this with all of the complexity and overhead we had in jlox with the
Visitor pattern for walking the AST.
我知道这段代码到目前为止还不是很令人印象深刻——它实际上只是一个封装在<code>for</code>循环中的switch语句，但信不信由你，这就是我们虚拟机的两个主要组成部分之一。有了它，我们就可以命令式地执行指令。它的简单是一种优点——它做的工作越少，就能做得越快。作为对照，可以回想一下我们在jlox中使用Visitor模式遍历AST的复杂度和开销。</p>
<h2><a href="#一个值栈操作器" id="一个值栈操作器"><small>15&#8202;.&#8202;2</small>一个值栈操作器</a></h2>
<p>In addition to imperative side effects, Lox has expressions that produce,
modify, and consume values. Thus, our compiled bytecode needs a way to shuttle
values around between the different instructions that need them. For example:
除了命令式的副作用外，Lox还有产生、修改和使用值的表达式。因此，我们编译的字节码还需要一种方法在需要值的不同指令之间传递它们。例如：</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="n">3</span> - <span class="n">2</span>;
</pre></div>
<p>We obviously need instructions for the constants 3 and 2, the <code>print</code> statement,
and the subtraction. But how does the subtraction instruction know that 3 is
the <span name="word">minuend</span> and 2 is the subtrahend? How does the print
instruction know to print the result of that?
显然我们需要常数3和2、<code>print</code>语句和减法对应的指令。但是减法指令如何知道3是被减数而2是减数呢？打印指令怎么知道要打印计算结果的呢？</p>
<aside name="word">
<p>Yes, I did have to look up &ldquo;subtrahend&rdquo; and &ldquo;minuend&rdquo; in a dictionary. But
aren&rsquo;t they delightful words? &ldquo;Minuend&rdquo; sounds like a kind of Elizabethan dance
and &ldquo;subtrahend&rdquo; might be some sort of underground Paleolithic monument.</p>
</aside>
<p>To put a finer point on it, look at this thing right here:
为了说得更清楚一点，看看下面的代码：</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">echo</span>(<span class="i">n</span>) {
  <span class="k">print</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">n</span>;
}

<span class="k">print</span> <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">1</span>) + <span class="i">echo</span>(<span class="n">2</span>)) + <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">4</span>) + <span class="i">echo</span>(<span class="n">5</span>));
</pre></div>
<p>I wrapped each subexpression in a call to <code>echo()</code> that prints and returns its
argument. That side effect means we can see the exact order of operations.
我将每个子表达都包装在对<code>echo()</code>的调用中，这个调用会打印并返回其参数。这个副作用意味着我们可以看到操作的确切顺序。</p>
<p>Don&rsquo;t worry about the VM for a minute. Think about just the semantics of Lox
itself. The operands to an arithmetic operator obviously need to be evaluated
before we can perform the operation itself. (It&rsquo;s pretty hard to add <code>a + b</code> if
you don&rsquo;t know what <code>a</code> and <code>b</code> are.) Also, when we implemented expressions in
jlox, we <span name="undefined">decided</span> that the left operand must be
evaluated before the right.
暂时不要担心虚拟机的问题。只考虑Lox本身的语义。算术运算符的操作数显然需要在执行运算操作之前求值（如果你不知道<code>a</code>和<code>b</code>是什么，就很难计算<code>a+b</code>）。另外，当我们在jlox中实现表达式时，我们决定了左操作数必须在右操作数之前进行求值。</p>
<aside name="undefined">
<p>We could have left evaluation order unspecified and let each implementation
decide. That leaves the door open for optimizing compilers to reorder arithmetic
expressions for efficiency, even in cases where the operands have visible side
effects. C and Scheme leave evaluation order unspecified. Java specifies
left-to-right evaluation like we do for Lox.</p>
<p>I think nailing down stuff like this is generally better for users. When
expressions are not evaluated in the order users intuit<span class="em">&mdash;</span>possibly in different
orders across different implementations!<span class="em">&mdash;</span>it can be a burning hellscape of
pain to figure out what&rsquo;s going on.</p>
</aside>
<p>Here is the syntax tree for the <code>print</code> statement:
下面是<code>print</code>语句的语法树：</p>
<p><img src="image/a-virtual-machine/ast.png" alt="The AST for the example
statement, with numbers marking the order that the nodes are evaluated." /></p>
<p>Given left-to-right evaluation, and the way the expressions are nested, any
correct Lox implementation <em>must</em> print these numbers in this order:
确定了从左到右的求值顺序，以及表达式嵌套方式，任何一个正确的Lox实现都<em>必须</em>按照下面的顺序打印这些数字：</p>
<div class="codehilite"><pre>1  // from echo(1)
2  // from echo(2)
3  // from echo(1 + 2)
4  // from echo(4)
5  // from echo(5)
9  // from echo(4 + 5)
12 // from print 3 + 9
</pre></div>
<p>Our old jlox interpreter accomplishes this by recursively traversing the AST. It
does a postorder traversal. First it recurses down the left operand branch,
then the right operand, then finally it evaluates the node itself.
我们的老式jlox解释器通过递归遍历AST来实现这一点。其中使用的是后序遍历。首先，它向下递归左操作数分支，然后是右操作数分支，最后计算节点本身。</p>
<p>After evaluating the left operand, jlox needs to store that result somewhere
temporarily while it&rsquo;s busy traversing down through the right operand tree. We
use a local variable in Java for that. Our recursive tree-walk interpreter
creates a unique Java call frame for each node being evaluated, so we could have
as many of these local variables as we needed.
在对左操作数求值之后，jlox需要将结果临时保存在某个地方，然后再向下遍历右操作数。我们使用Java中的一个局部变量来实现。我们的递归树遍历解释器会为每个正在求值的节点创建一个单独的Java调用帧，所以我们可以根据需要维护很多这样的局部变量。</p>
<p>In clox, our <code>run()</code> function is not recursive<span class="em">&mdash;</span>the nested expression tree is
flattened out into a linear series of instructions. We don&rsquo;t have the luxury of
using C local variables, so how and where should we store these temporary
values? You can probably <span name="guess">guess</span> already, but I want to
really drill into this because it&rsquo;s an aspect of programming that we take for
granted, but we rarely learn <em>why</em> computers are architected this way.
在clox中，我们的<code>run()</code>函数不是递归的——嵌套的表达式被展开成一系列线性指令。我们没有办法使用C语言的局部变量，那我们应该如何存储这些临时值呢？你可能已经猜到了，但我想真正深入研究这个问题，因为这是编程中我们习以为常的一个方面，但我们很少了解为什么计算机是这样架构的。</p>
<aside name="guess">
<p>Hint: it&rsquo;s in the name of this section, and it&rsquo;s how Java and C manage recursive
calls to functions.</p>
</aside>
<p>Let&rsquo;s do a weird exercise. We&rsquo;ll walk through the execution of the above program
a step at a time:
让我们做一个奇怪的练习。我们来一步一步地遍历上述程序的执行过程：</p>
<p><img src="image/a-virtual-machine/bars.png" alt="The series of instructions with
bars showing which numbers need to be preserved across which instructions." /></p>
<p>On the left are the steps of code. On the right are the values we&rsquo;re tracking.
Each bar represents a number. It starts when the value is first produced<span class="em">&mdash;</span>either a constant or the result of an addition. The length of the bar tracks
when a previously produced value needs to be kept around, and it ends when that
value finally gets consumed by an operation.
左边是代码的执行步骤。右边是我们要追踪的值。每条杠代表一个数字。起点是数值产生时——要么是一个常数，要么是一个加法计算结果；杠的长度表示之前产生的值需要保留的时间；当该值最终被某个操作消费后，杠就到终点了。</p>
<p>As you step through, you see values appear and then later get eaten. The
longest-lived ones are the values produced from the left-hand side of an
addition. Those stick around while we work through the right-hand operand
expression.
随着你不断执行，你会看到一些数值出现，然后被消费掉。寿命最长的是加法左侧产生的值。当我们在处理右边的操作数表达式时，这些值会一直存在。</p>
<p>In the above diagram, I gave each unique number its own visual column. Let&rsquo;s be
a little more parsimonious. Once a number is consumed, we allow its column to be
reused for another later value. In other words, we take all of those gaps
up there and fill them in, pushing in numbers from the right:
在上图中，我为每个数字提供了单独的可视化列。让我们更简洁一些。一旦一个数字被消费了，我们就允许它的列被其它值重用。换句话说，我们将数字从右向左推入，把上面的空隙都填上：</p>
<p><img src="image/a-virtual-machine/bars-stacked.png" alt="Like the previous
diagram, but with number bars pushed to the left, forming a stack." /></p>
<p>There&rsquo;s some interesting stuff going on here. When we shift everything over,
each number still manages to stay in a single column for its entire life. Also,
there are no gaps left. In other words, whenever a number appears earlier than
another, then it will live at least as long as that second one. The first number
to appear is the last to be consumed. Hmm<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>last-in, first-out<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>why, that&rsquo;s a
<span name="pancakes">stack</span>!
这里有一些有趣的事情发生了。当我们把所有数字都移动以后，每个数字在整个生命周期中仍然能保持在一列。此外，也没有留下任何空隙。换句话说，只要一个数字比另一个数字出现得早，那么它的寿命至少和第二个数字一样长。第一个出现的数字是最后一个消费掉的，嗯……后进先出……哎呀，这是一个栈！</p>
<aside name="pancakes">
<p>This is also a stack:</p><img src="image/a-virtual-machine/pancakes.png" alt="A stack... of pancakes." />
</aside>
<p>In the second diagram, each time we introduce a number, we push it onto the
stack from the right. When numbers are consumed, they are always popped off from
rightmost to left.
在第二张图中，每次我们生成一个数字时，都会从右边将它压入栈。当数字被消费时，它们也是从右向左进行弹出。</p>
<p>Since the temporary values we need to track naturally have stack-like behavior,
our VM will use a stack to manage them. When an instruction &ldquo;produces&rdquo; a value,
it pushes it onto the stack. When it needs to consume one or more values, it
gets them by popping them off the stack.
由于我们需要跟踪的临时值天然具有类似栈的行为，我们的虚拟机将使用栈来管理它们。当一条指令“生成”一个值时，它会把这个值压入栈中。当它需要消费一个或多个值时，通过从栈中弹出数据来获得这些值。</p>
<h3><a href="#虚拟机的栈" id="虚拟机的栈"><small>15&#8202;.&#8202;2&#8202;.&#8202;1</small>虚拟机的栈</a></h3>
<p>Maybe this doesn&rsquo;t seem like a revelation, but I <em>love</em> stack-based VMs. When
you first see a magic trick, it feels like something actually magical. But then
you learn how it works<span class="em">&mdash;</span>usually some mechanical gimmick or misdirection<span class="em">&mdash;</span>and
the sense of wonder evaporates. There are a <span name="wonder">couple</span> of
ideas in computer science where even after I pulled them apart and learned all
the ins and outs, some of the initial sparkle remained. Stack-based VMs are one
of those.
也许这看起来不像是什么新发现，但我喜欢基于栈的虚拟机。当你第一次看到一个魔术时，你会觉得它真的很神奇。但是当你了解到它是如何工作的——通常是一些机械式花招或误导——惊奇的感觉就消失了。在计算机科学中，有一些理念，即使我把它们拆开并了解了所有的来龙去脉之后，最初的闪光点仍然存在。基于堆栈的虚拟机就是其中之一。</p>
<aside name="wonder">
<p>Heaps<span class="em">&mdash;</span><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">the data structure</a>, not <a href="https://en.wikipedia.org/wiki/Memory_management#HEAP">the memory management thing</a><span class="em">&mdash;</span>are another. And Vaughan Pratt&rsquo;s top-down operator precedence parsing scheme,
which we&rsquo;ll learn about <a href="compiling-expressions.html">in due time</a>.</p>
</aside>
<p>As you&rsquo;ll see in this chapter, executing instructions in a stack-based VM is
dead <span name="cheat">simple</span>. In later chapters, you&rsquo;ll also discover
that compiling a source language to a stack-based instruction set is a piece of
cake. And yet, this architecture is fast enough to be used by production
language implementations. It almost feels like cheating at the programming
language game.
你在本章中将会看到，在基于堆栈的虚拟机中执行指令是非常简单的。在后面的章节中，你还会发现，将源语言编译成基于栈的指令集是小菜一碟。但是，这种架构的速度快到足以在产生式语言的实现中使用。这感觉就像是在编程语言游戏中作弊。</p>
<aside name="cheat">
<p>To take a bit of the sheen off: stack-based interpreters aren&rsquo;t a silver bullet.
They&rsquo;re often <em>adequate</em>, but modern implementations of the JVM, the CLR, and
JavaScript all use sophisticated <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time compilation</a> pipelines to
generate <em>much</em> faster native code on the fly.</p>
</aside>
<p>Alrighty, it&rsquo;s codin&rsquo; time! Here&rsquo;s the stack:
好了，编码时间到！下面是栈：</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
  Chunk* chunk;
  uint8_t* ip;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">Value</span> <span class="i">stack</span>[<span class="a">STACK_MAX</span>];
  <span class="t">Value</span>* <span class="i">stackTop</span>;
</pre><pre class="insert-after">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>We implement the stack semantics ourselves on top of a raw C array. The bottom
of the stack<span class="em">&mdash;</span>the first value pushed and the last to be popped<span class="em">&mdash;</span>is at
element zero in the array, and later pushed values follow it. If we push the
letters of &ldquo;crepe&rdquo;<span class="em">&mdash;</span>my favorite stackable breakfast item<span class="em">&mdash;</span>onto the stack, in
order, the resulting C array looks like this:
我们在一个原生的C数组上自己实现了栈语义。栈的底部——第一个推入的值和最后一个被弹出的值——位于数组中的零号位置，后面推入的值跟在它后面。如果我们把“crepe”几个字母按顺序推入栈中，得到的C数组看起来像这样：</p>
<p><img src="image/a-virtual-machine/array.png" alt="An array containing the
letters in 'crepe' in order starting at element 0." /></p>
<p>Since the stack grows and shrinks as values are pushed and popped, we need to
track where the top of the stack is in the array. As with <code>ip</code>, we use a direct
pointer instead of an integer index since it&rsquo;s faster to dereference the pointer
than calculate the offset from the index each time we need it.
由于栈会随着值的压入和弹出而伸缩，我们需要跟踪栈的顶部在数组中的位置。和<code>ip</code>一样，我们使用一个直接指针而不是整数索引，因为每次我们需要使用它时，解引用比计算索引的偏移量更快。</p>
<p>The pointer points at the array element just <em>past</em> the element containing the
top value on the stack. That seems a little odd, but almost every implementation
does this. It means we can indicate that the stack is empty by pointing at
element zero in the array.
指针指向数组中栈顶元素的下一个元素位置，这看起来有点奇怪，但几乎每个实现都会这样做。这意味着我们可以通过指向数组中的零号元素来表示栈是空的。</p>
<p><img src="image/a-virtual-machine/stack-empty.png" alt="An empty array with
stackTop pointing at the first element." /></p>
<p>If we pointed to the top element, then for an empty stack we&rsquo;d need to point at
element -1. That&rsquo;s <span name="defined">undefined</span> in C. As we push values
onto the stack<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>
如果我们指向栈顶元素，那么对于空栈，我们就需要指向-1位置的元素。这在C语言中是没有定义的。当我们把值压入栈时：</p>
<aside name="defined">
<p>What about when the stack is <em>full</em>, you ask, Clever Reader? The C standard is
one step ahead of you. It <em>is</em> allowed and well-specified to have an array
pointer that points just past the end of an array.</p>
</aside>
<p><img src="image/a-virtual-machine/stack-c.png" alt="An array with 'c' at element
zero." /></p>
<p><span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span><code>stackTop</code> always points just past the last item.
<code>stackTop</code>一直会超过栈中的最后一个元素。</p>
<p><img src="image/a-virtual-machine/stack-crepe.png" alt="An array with 'c', 'r',
'e', 'p', and 'e' in the first five elements." /></p>
<p>I remember it like this: <code>stackTop</code> points to where the next value to be pushed
will go. The maximum number of values we can store on the stack (for now, at
least) is:
我是这样记的：<code>stackTop</code>指向下一个值要被压入的位置。我们在栈中可以存储的值的最大数量（至少目前是这样）为：</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert">

<span class="a">#define STACK_MAX 256</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>

<p>Giving our VM a fixed stack size means it&rsquo;s possible for some sequence of
instructions to push too many values and run out of stack space<span class="em">&mdash;</span>the classic
&ldquo;stack overflow&rdquo;. We could grow the stack dynamically as needed, but for now
we&rsquo;ll keep it simple. Since VM uses Value, we need to include its declaration.
给我们的虚拟机一个固定的栈大小，意味着某些指令系列可能会压入太多的值并耗尽栈空间——典型的“堆栈溢出”。我们可以根据需要动态地增加栈，但是现在我们还是保持简单。因为VM中会使用Value，我们需要包含它的声明。</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert"><span class="a">#include &quot;value.h&quot;</span>
</pre><pre class="insert-after">

#define STACK_MAX 256
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>

<p>Now that VM has some interesting state, we get to initialize it.
现在，虚拟机中有了一些有趣的状态，我们要对它进行初始化。</p>
<div class="codehilite"><pre class="insert-before">void initVM() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">  <span class="i">resetStack</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>That uses this helper function:
其中使用了这个辅助函数：</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after variable <em>vm</em></div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">resetStack</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">vm</span>.<span class="i">stack</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after variable <em>vm</em></div>

<p>Since the stack array is declared directly inline in the VM struct, we don&rsquo;t
need to allocate it. We don&rsquo;t even need to clear the unused cells in the
array<span class="em">&mdash;</span>we simply won&rsquo;t access them until after values have been stored in
them. The only initialization we need is to set <code>stackTop</code> to point to the
beginning of the array to indicate that the stack is empty.
因为栈数组是直接在VM结构体中内联声明的，所以我们不需要为其分配空间。我们甚至不需要清除数组中不使用的单元——我们只有在值存入之后才会访问它们。我们需要的唯一的初始化操作就是将<code>stackTop</code>指向数组的起始位置，以表明栈是空的。</p>
<p>The stack protocol supports two operations:
栈协议支持两种操作：</p>
<div class="codehilite"><pre class="insert-before">InterpretResult interpret(Chunk* chunk);
</pre><div class="source-file"><em>vm.h</em><br>
add after <em>interpret</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>);
<span class="t">Value</span> <span class="i">pop</span>();
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>interpret</em>()</div>

<p>You can push a new value onto the top of the stack, and you can pop the most
recently pushed value back off. Here&rsquo;s the first function:
你可以把一个新值压入栈顶，你也可以把最近压入的值弹出。下面是第一个函数：</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>freeVM</em>()</div>
<pre><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>) {
  *<span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">value</span>;
  <span class="i">vm</span>.<span class="i">stackTop</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>

<p>If you&rsquo;re rusty on your C pointer syntax and operations, this is a good warm-up.
The first line stores <code>value</code> in the array element at the top of the stack.
Remember, <code>stackTop</code> points just <em>past</em> the last used element, at the next
available one. This stores the value in that slot. Then we increment the pointer
itself to point to the next unused slot in the array now that the previous slot
is occupied.
如果你对C指针的语法和操作感到生疏，这是一个很好的熟悉的机会。第一行在栈顶的数组元素中存储<code>value</code>。记住，<code>stackTop</code>刚刚跳过上次使用的元素，即下一个可用的元素。这里把值存储在该元素槽中。接着，因为上一个槽被占用了，我们增加指针本身，指向数组中下一个未使用的槽。</p>
<p>Popping is the mirror image.
弹出正好是压入的镜像操作。</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>push</em>()</div>
<pre><span class="t">Value</span> <span class="i">pop</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span>--;
  <span class="k">return</span> *<span class="i">vm</span>.<span class="i">stackTop</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>push</em>()</div>

<p>First, we move the stack pointer <em>back</em> to get to the most recent used slot in
the array. Then we look up the value at that index and return it. We don&rsquo;t need
to explicitly &ldquo;remove&rdquo; it from the array<span class="em">&mdash;</span>moving <code>stackTop</code> down is enough to
mark that slot as no longer in use.
首先，我们将栈指针回退到数组中最近使用的槽。然后，我们查找该索引处的值并将其返回。我们不需要显式地将其从数组中“移除”——将<code>stackTop</code>下移就足以将该槽标记为不再使用了。</p>
<h3><a href="#栈跟踪" id="栈跟踪"><small>15&#8202;.&#8202;2&#8202;.&#8202;2</small>栈跟踪</a></h3>
<p>We have a working stack, but it&rsquo;s hard to <em>see</em> that it&rsquo;s working. When we start
implementing more complex instructions and compiling and running larger pieces
of code, we&rsquo;ll end up with a lot of values crammed into that array. It would
make our lives as VM hackers easier if we had some visibility into the stack.
我们有了一个工作的栈，但是很难看出它在工作。当我们开始实现更复杂的指令，编译和运行更大的代码片段时，最终会在这个数组中塞入很多值。如果我们对栈有一定的可见性，那么作为虚拟机开发者，我们就会更轻松。</p>
<p>To that end, whenever we&rsquo;re tracing execution, we&rsquo;ll also show the current
contents of the stack before we interpret each instruction.
为此，每当我们追踪执行情况时，我们也会在解释每条指令之前展示栈中的当前内容。</p>
<div class="codehilite"><pre class="insert-before">#ifdef DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">    <span class="i">printf</span>(<span class="s">&quot;          &quot;</span>);
    <span class="k">for</span> (<span class="t">Value</span>* <span class="i">slot</span> = <span class="i">vm</span>.<span class="i">stack</span>; <span class="i">slot</span> &lt; <span class="i">vm</span>.<span class="i">stackTop</span>; <span class="i">slot</span>++) {
      <span class="i">printf</span>(<span class="s">&quot;[ &quot;</span>);
      <span class="i">printValue</span>(*<span class="i">slot</span>);
      <span class="i">printf</span>(<span class="s">&quot; ]&quot;</span>);
    }
    <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
</pre><pre class="insert-after">    disassembleInstruction(vm.chunk,
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We loop, printing each value in the array, starting at the first (bottom of the
stack) and ending when we reach the top. This lets us observe the effect of each
instruction on the stack. The output is pretty verbose, but it&rsquo;s useful when
we&rsquo;re surgically extracting a nasty bug from the bowels of the interpreter.
我们循环打印数组中的每个值，从第一个值开始（栈底），到栈顶结束。这样我们可以观察到每条指令对栈的影响。这个输出会相当冗长，但是从我们在解释器中遇到令人讨厌的错误时，这就会很有用了。</p>
<p>Stack in hand, let&rsquo;s revisit our two instructions. First up:
堆栈在手，让我们重新审视一下目前的两条指令。首先是：</p>
<div class="codehilite"><pre class="insert-before">      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">        <span class="i">push</span>(<span class="i">constant</span>);
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>In the last chapter, I was hand-wavey about how the <code>OP_CONSTANT</code> instruction
&ldquo;loads&rdquo; a constant. Now that we have a stack you know what it means to actually
produce a value: it gets pushed onto the stack.
在上一节中，我粗略介绍了<code>OP_CONSTANT</code>指令是如何“加载”一个常量的。现在我们有了一个堆栈，你就知道产生一个值实际上意味着什么：将它压入栈。</p>
<div class="codehilite"><pre class="insert-before">      case OP_RETURN: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="i">printValue</span>(<span class="i">pop</span>());
        <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
</pre><pre class="insert-after">        return INTERPRET_OK;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Then we make <code>OP_RETURN</code> pop the stack and print the top value before exiting.
When we add support for real functions to clox, we&rsquo;ll change this code. But, for
now, it gives us a way to get the VM executing simple instruction sequences and
displaying the result.
接下来，我们让<code>OP_RETURN</code>在退出之前弹出栈顶值并打印。等到我们在clox中添加对真正的函数的支持时，我们将会修改这段代码。但是，目前来看，我们可以使用这种方法让VM执行简单的指令序列并显示结果。</p>
<h2><a href="#数学计算器" id="数学计算器"><small>15&#8202;.&#8202;3</small>数学计算器</a></h2>
<p>The heart and soul of our VM are in place now. The bytecode loop dispatches and
executes instructions. The stack grows and shrinks as values flow through it.
The two halves work, but it&rsquo;s hard to get a feel for how cleverly they interact
with only the two rudimentary instructions we have so far. So let&rsquo;s teach our
interpreter to do arithmetic.
我们的虚拟机的核心和灵魂现在都已经就位了。字节码循环分派和执行指令。栈堆随着数值的流动而增长和收缩。这两部分都在工作，但仅凭我们目前的两条基本指令，很难感受到它们如何巧妙地互动。所以让我们教解释器如何做算术。
We’ll start with the simplest arithmetic operation, unary negation.
我们从最简单的算术运算开始，即一元取负。</p>
<p>We&rsquo;ll start with the simplest arithmetic operation, unary negation.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1.2</span>;
<span class="k">print</span> -<span class="i">a</span>; <span class="c">// -1.2.</span>
</pre></div>
<p>The prefix <code>-</code> operator takes one operand, the value to negate. It produces a
single result. We aren&rsquo;t fussing with a parser yet, but we can add the
bytecode instruction that the above syntax will compile to.
前缀的<code>-</code>运算符接受一个操作数，也就是要取负的值。它只产生一个结果。我们还没有对解析器进行处理，但可以添加上述语法编译后对应的字节码指令。</p>
<div class="codehilite"><pre class="insert-before">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_NEGATE</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>We execute it like so:
我们这样执行它：</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NEGATE</span>:   <span class="i">push</span>(-<span class="i">pop</span>()); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>The instruction needs a value to operate on, which it gets by popping from the
stack. It negates that, then pushes the result back on for later instructions to
use. Doesn&rsquo;t get much easier than that. We can disassemble it too.
该指令需要操作一个值，该值通过弹出栈获得。它对该值取负，然后把结果重新压入栈，以便后面的指令使用。没有什么比这更简单的了。我们也可以对其反汇编：</p>
<div class="codehilite"><pre class="insert-before">    case OP_CONSTANT:
      return constantInstruction(&quot;OP_CONSTANT&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_NEGATE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_NEGATE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>And we can try it out in our test chunk.
我们可以在测试代码中试一试。</p>
<div class="codehilite"><pre class="insert-before">  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_NEGATE</span>, <span class="n">123</span>);
</pre><pre class="insert-after">

  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>After loading the constant, but before returning, we execute the negate
instruction. That replaces the constant on the stack with its negation. Then the
return instruction prints that out:
在加载常量之后，返回之前，我们会执行取负指令。这条指令会将栈中的常量替换为其对应的负值。然后返回指令会打印出：</p>
<div class="codehilite"><pre>-1.2
</pre></div>
<p>Magical!
神奇！</p>
<h3><a href="#二元操作符" id="二元操作符"><small>15&#8202;.&#8202;3&#8202;.&#8202;1</small>二元操作符</a></h3>
<p>OK, unary operators aren&rsquo;t <em>that</em> impressive. We still only ever have a single
value on the stack. To really see some depth, we need binary operators. Lox has
four binary <span name="ops">arithmetic</span> operators: addition, subtraction,
multiplication, and division. We&rsquo;ll go ahead and implement them all at the same
time.
好吧，一元运算符并没有那么令人印象深刻。我们的栈中仍然只有一个值。要真正看到一些深度，我们需要二元运算符。Lox中有四个二进制算术运算符：加、减、乘、除。我们接下来会同时实现它们。</p>
<aside name="ops">
<p>Lox has some other binary operators<span class="em">&mdash;</span>comparison and equality<span class="em">&mdash;</span>but those
don&rsquo;t produce numbers as a result, so we aren&rsquo;t ready for them yet.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_ADD</span>,
  <span class="a">OP_SUBTRACT</span>,
  <span class="a">OP_MULTIPLY</span>,
  <span class="a">OP_DIVIDE</span>,
</pre><pre class="insert-after">  OP_NEGATE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Back in the bytecode loop, they are executed like this:
回到字节码循环中，它们是这样执行的：</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_ADD</span>:      <span class="a">BINARY_OP</span>(+); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_SUBTRACT</span>: <span class="a">BINARY_OP</span>(-); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_MULTIPLY</span>: <span class="a">BINARY_OP</span>(*); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_DIVIDE</span>:   <span class="a">BINARY_OP</span>(/); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_NEGATE:   push(-pop()); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>The only difference between these four instructions is which underlying C
operator they ultimately use to combine the two operands. Surrounding that core
arithmetic expression is some boilerplate code to pull values off the stack and
push the result. When we later add dynamic typing, that boilerplate will grow.
To avoid repeating that code four times, I wrapped it up in a macro.
这四条指令之间唯一的区别是，它们最终使用哪一个底层C运算符来组合两个操作数。围绕这个核心算术表达式的是一些模板代码，用于从栈中获取数值，并将结果结果压入栈中。等我们后面添加动态类型时，这些模板代码会增加。为了避免这些代码重复出现四次，我将它包装在一个宏中。</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define BINARY_OP(op) \</span>
<span class="a">    do { \</span>
<span class="a">      double b = pop(); \</span>
<span class="a">      double a = pop(); \</span>
<span class="a">      push(a op b); \</span>
<span class="a">    } while (false)</span>
</pre><pre class="insert-after">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>I admit this is a fairly <span name="operator">adventurous</span> use of the C
preprocessor. I hesitated to do this, but you&rsquo;ll be glad in later chapters when
we need to add the type checking for each operand and stuff. It would be a chore
to walk you through the same code four times.
我承认这是对C预处理器的一次相当大胆的使用。我曾犹豫过要不要这么做，但在后面的章节中，等到我们需要为每个操作数和其它内容添加类型检查时，你就会高兴的。如果把相同的代码遍历四遍就太麻烦了。</p>
<aside name="operator">
<p>Did you even know you can pass an <em>operator</em> as an argument to a macro? Now you
do. The preprocessor doesn&rsquo;t care that operators aren&rsquo;t first class in C. As far
as it&rsquo;s concerned, it&rsquo;s all just text tokens.</p>
<p>I know, you can just <em>feel</em> the temptation to abuse this, can&rsquo;t you?</p>
</aside>
<p>If you aren&rsquo;t familiar with the trick already, that outer <code>do while</code> loop
probably looks really weird. This macro needs to expand to a series of
statements. To be careful macro authors, we want to ensure those statements all
end up in the same scope when the macro is expanded. Imagine if you defined:
如果你对这个技巧还不熟悉，那么外层的<code>do while</code>循环可能看起来非常奇怪。这个宏需要扩展为一系列语句。作为一个谨慎的宏作者，我们要确保当宏展开时，这些语句都在同一个作用域内。想象一下，如果你定义了：</p>
<div class="codehilite"><pre><span class="a">#define WAKE_UP() makeCoffee(); drinkCoffee();</span>
</pre></div>
<p>And then used it like:
然后这样使用它：</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">morning</span>) <span class="a">WAKE_UP</span>();
</pre></div>
<p>The intent is to execute both statements of the macro body only if <code>morning</code> is
true. But it expands to:
其本意是在<code>morning</code>为true时执行这两个语句。但是宏展开结果为：</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">morning</span>) <span class="i">makeCoffee</span>(); <span class="i">drinkCoffee</span>();;
</pre></div>
<p>Oops. The <code>if</code> attaches only to the <em>first</em> statement. You might think you could
fix this using a block.
哎呀。<code>if</code>只关联了第一条语句。您可能认为可以用代码块解决这个问题。</p>
<div class="codehilite"><pre><span class="a">#define WAKE_UP() { makeCoffee(); drinkCoffee(); }</span>
</pre></div>
<p>That&rsquo;s better, but you still risk:
这样好一点，但还是有风险：</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">morning</span>)
  <span class="a">WAKE_UP</span>();
<span class="k">else</span>
  <span class="i">sleepIn</span>();
</pre></div>
<p>Now you get a compile error on the <code>else</code> because of that trailing <code>;</code> after the
macro&rsquo;s block. Using a <code>do while</code> loop in the macro looks funny, but it gives
you a way to contain multiple statements inside a block that <em>also</em> permits a
semicolon at the end.
现在你会在<code>else</code>子句遇到编译错误，因为在宏代码块后面有个<code>;</code>。在宏中使用<code>do while</code>循环看起来很滑稽，但它提供了一种方法，可以在一个代码块中包含多个语句，并且允许在末尾使用分号。</p>
<p>Where were we? Right, so what the body of that macro does is straightforward. A
binary operator takes two operands, so it pops twice. It performs the operation
on those two values and then pushes the result.
我们说到哪里了？对了，这个宏的主体所做的事情很直接。一个二元运算符接受两个操作数，因此会弹出栈两次，对这两个值执行操作，然后将结果压入栈。</p>
<p>Pay close attention to the <em>order</em> of the two pops. Note that we assign the
first popped operand to <code>b</code>, not <code>a</code>. It looks backwards. When the operands
themselves are calculated, the left is evaluated first, then the right. That
means the left operand gets pushed before the right operand. So the right
operand will be on top of the stack. Thus, the first value we pop is <code>b</code>.
请密切注意这两次弹出栈的顺序。注意，我们将第一个弹出的操作数赋值给<code>b</code>，而不是<code>a</code>。在对操作数求值时，先计算左操作数，再计算右操作数。这意味着左操作数会在右操作数之前被压入栈，所以右侧的操作数在栈顶。因此，我们弹出的第一个值属于<code>b</code>。</p>
<p>For example, if we compile <code>3 - 1</code>, the data flow between the instructions looks
like so:
举例来说，如果我们编译<code>3-1</code>，指令之间的数据流看起来是这样的：</p>
<p><img src="image/a-virtual-machine/reverse.png" alt="A sequence of instructions
with the stack for each showing how pushing and then popping values reverses
their order." /></p>
<p>As we did with the other macros inside <code>run()</code>, we clean up after ourselves at
the end of the function.
正如我们在<code>run()</code>内的其它宏中做的那样，我们在函数结束时自行清理。</p>
<div class="codehilite"><pre class="insert-before">#undef READ_CONSTANT
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef BINARY_OP</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Last is disassembler support.
最后是反汇编器的支持。</p>
<div class="codehilite"><pre class="insert-before">    case OP_CONSTANT:
      return constantInstruction(&quot;OP_CONSTANT&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_ADD</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_ADD&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SUBTRACT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_SUBTRACT&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_MULTIPLY</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_MULTIPLY&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_DIVIDE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_DIVIDE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>The arithmetic instruction formats are simple, like <code>OP_RETURN</code>. Even though the
arithmetic <em>operators</em> take operands<span class="em">&mdash;</span>which are found on the stack<span class="em">&mdash;</span>the
arithmetic <em>bytecode instructions</em> do not.
算术指令的格式很简单，类似于<code>OP_RETURN</code>。即使算术运算符需要操作数（从堆栈中获取），算术的<em>字节码指令</em>也不需要。</p>
<p>Let&rsquo;s put some of our new instructions through their paces by evaluating a
larger expression:
我们通过计算一个更大的表达式来检验一些新指令。
<img src="15.虚拟机/chunk.png" alt="The expression being evaluated: -((1.2 + 3.4) / 5.6)" /></p>
<p><img src="image/a-virtual-machine/chunk.png" alt="The expression being
evaluated: -((1.2 + 3.4) / 5.6)" /></p>
<p>Building on our existing example chunk, here&rsquo;s the additional instructions we
need to hand-compile that AST to bytecode.
在我们现有的示例代码块基础上，下面是我们将AST手动编译为字节码后需要添加的指令。</p>
<div class="codehilite"><pre class="insert-before">  int constant = addConstant(&amp;chunk, 1.2);
  writeChunk(&amp;chunk, OP_CONSTANT, 123);
  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">

  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">3.4</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_ADD</span>, <span class="n">123</span>);

  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">5.6</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_DIVIDE</span>, <span class="n">123</span>);
</pre><pre class="insert-after">  writeChunk(&amp;chunk, OP_NEGATE, 123);

  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>The addition goes first. The instruction for the left constant, 1.2, is already
there, so we add another for 3.4. Then we add those two using <code>OP_ADD</code>, leaving
it on the stack. That covers the left side of the division. Next we push the
5.6, and divide the result of the addition by it. Finally, we negate the result
of that.
首先进行加法运算。左边的常数1.2的指令已经存在了，所以我们再加一条3.4的指令。然后我们用<code>OP_ADD</code>把这两个值加起来，将结果压入堆栈中。这样就完成了除法的左操作数。接下来，我们压入5.6，并用加法的结果除以它。最后，我们对结果取负。</p>
<p>Note how the output of the <code>OP_ADD</code> implicitly flows into being an operand of
<code>OP_DIVIDE</code> without either instruction being directly coupled to each other.
That&rsquo;s the magic of the stack. It lets us freely compose instructions without
them needing any complexity or awareness of the data flow. The stack acts like a
shared workspace that they all read from and write to.
注意，<code>OP_ADD</code>的输出如何隐式地变成了<code>OP_DIVIDE</code>的一个操作数，而这两条指令都没有直接耦合在一起。这就是堆栈的魔力。他让我们可以自由地编写指令，而无需任何复杂性或对于数据流的感知。堆栈就像一个共享工作区，它们都可以从中读取和写入。</p>
<p>In this tiny example chunk, the stack still only gets two values tall, but when
we start compiling Lox source to bytecode, we&rsquo;ll have chunks that use much more
of the stack. In the meantime, try playing around with this hand-authored chunk
to calculate different nested arithmetic expressions and see how values flow
through the instructions and stack.
在这个小示例中，堆栈仍然只有两个值，但当我们开始将Lox源代码编译为字节码时，我们的代码块将使用更多的堆栈。同时，你可以试着用这个手工编写的字节码块来计算不同的嵌套算术表达式，看看数值是如何在指令和栈中流动的。</p>
<p>You may as well get it out of your system now. This is the last chunk we&rsquo;ll
build by hand. When we next revisit bytecode, we will be writing a compiler to
generate it for us.
你不妨现在就把这块代码从系统中拿出来。这是我们手工构建的最后一个字节码块。当我们下次使用字节码时，我们将编写一个编译器来生成。</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>What bytecode instruction sequences would you generate for the following
expressions:</p>
<div class="codehilite"><pre><span class="n">1</span> * <span class="n">2</span> + <span class="n">3</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span>
<span class="n">3</span> - <span class="n">2</span> - <span class="n">1</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span> - <span class="n">4</span> / -<span class="n">5</span>
</pre></div>
<p>(Remember that Lox does not have a syntax for negative number literals, so
the <code>-5</code> is negating the number 5.)
（请记得，Lox语法中没有负数字面量，所以<code>-5</code>是对数字5取负）</p>
</li>
<li>
<p>If we really wanted a minimal instruction set, we could eliminate either
<code>OP_NEGATE</code> or <code>OP_SUBTRACT</code>. Show the bytecode instruction sequence you
would generate for:
如果我们真的想要一个最小指令集，我们可以取消<code>OP_NEGATE</code>或<code>OP_SUBTRACT</code>。请写出你为下面的表达式生成的字节码指令序列：</p>
<div class="codehilite"><pre><span class="n">4</span> - <span class="n">3</span> * -<span class="n">2</span>
</pre></div>
<p>First, without using <code>OP_NEGATE</code>. Then, without using <code>OP_SUBTRACT</code>.</p>
<p>Given the above, do you think it makes sense to have both instructions? Why
or why not? Are there any other redundant instructions you would consider
including?
首先是不能使用 <code>OP_NEGATE</code>。然后，试一下不使用<code>OP_SUBTRACT</code>。
综上所述，你认为同时拥有这两条指令有意义吗？为什么呢？还有没有其它指令可以考虑加入？</p>
</li>
<li>
<p>Our VM&rsquo;s stack has a fixed size, and we don&rsquo;t check if pushing a value
overflows it. This means the wrong series of instructions could cause our
interpreter to crash or go into undefined behavior. Avoid that by
dynamically growing the stack as needed.
我们虚拟机的堆栈有一个固定大小，而且我们不会检查压入一个值是否会溢出。这意味着错误的指令序列可能会导致我们的解释器崩溃或进入未定义的行为。通过根据需求动态增长堆栈来避免这种情况。</p>
<p>What are the costs and benefits of doing so?
这样做的代价和好处是什么？</p>
</li>
<li>
<p>To interpret <code>OP_NEGATE</code>, we pop the operand, negate the value, and then
push the result. That&rsquo;s a simple implementation, but it increments and
decrements <code>stackTop</code> unnecessarily, since the stack ends up the same height
in the end. It might be faster to simply negate the value in place on the
stack and leave <code>stackTop</code> alone. Try that and see if you can measure a
performance difference.
为了解释<code>OP_NEGATE</code>，我们弹出操作数，对值取负，然后将结果压入栈。这是一个简单的实现，但它对<code>stackTop</code>进行了不必要的增减操作，因为栈最终的高度是相同的。简单地对栈中的值取负而不处理<code>stackTop</code>可能会更快。试一下，看看你是否能测出性能差异。</p>
<p>Are there other instructions where you can do a similar optimization?
是否有其它指令可以做类似的优化？</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: 基于寄存器的字节码</a></h2>
<p>For the remainder of this book, we&rsquo;ll meticulously implement an interpreter
around a stack-based bytecode instruction set. There&rsquo;s another family of
bytecode architectures out there<span class="em">&mdash;</span><em>register-based</em>. Despite the name, these
bytecode instructions aren&rsquo;t quite as difficult to work with as the registers in
an actual chip like <span name="x64">x64</span>. With real hardware registers,
you usually have only a handful for the entire program, so you spend a lot of
effort <a href="https://en.wikipedia.org/wiki/Register_allocation">trying to use them efficiently and shuttling stuff in and out of
them</a>.</p>
<aside name="x64">
<p>Register-based bytecode is a little closer to the <a href="https://en.wikipedia.org/wiki/Register_window"><em>register windows</em></a>
supported by SPARC chips.</p>
</aside>
<p>In a register-based VM, you still have a stack. Temporary values still get
pushed onto it and popped when no longer needed. The main difference is that
instructions can read their inputs from anywhere in the stack and can store
their outputs into specific stack slots.</p>
<p>Take this little Lox script:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
<span class="k">var</span> <span class="i">c</span> = <span class="i">a</span> + <span class="i">b</span>;
</pre></div>
<p>In our stack-based VM, the last statement will get compiled to something like:</p>
<div class="codehilite"><pre><span class="i">load</span> &lt;<span class="i">a</span>&gt;  <span class="c">// Read local variable a and push onto stack.</span>
<span class="i">load</span> &lt;<span class="i">b</span>&gt;  <span class="c">// Read local variable b and push onto stack.</span>
<span class="i">add</span>       <span class="c">// Pop two values, add, push result.</span>
<span class="i">store</span> &lt;<span class="i">c</span>&gt; <span class="c">// Pop value and store in local variable c.</span>
</pre></div>
<p>(Don&rsquo;t worry if you don&rsquo;t fully understand the load and store instructions yet.
We&rsquo;ll go over them in much greater detail <a href="global-variables.html">when we implement
variables</a>.) We have four separate instructions. That means four
times through the bytecode interpret loop, four instructions to decode and
dispatch. It&rsquo;s at least seven bytes of code<span class="em">&mdash;</span>four for the opcodes and another
three for the operands identifying which locals to load and store. Three pushes
and three pops. A lot of work!</p>
<p>In a register-based instruction set, instructions can read from and store
directly into local variables. The bytecode for the last statement above looks
like:</p>
<div class="codehilite"><pre><span class="i">add</span> &lt;<span class="i">a</span>&gt; &lt;<span class="i">b</span>&gt; &lt;<span class="i">c</span>&gt; <span class="c">// Read values from a and b, add, store in c.</span>
</pre></div>
<p>The add instruction is bigger<span class="em">&mdash;</span>it has three instruction operands that define
where in the stack it reads its inputs from and writes the result to. But since
local variables live on the stack, it can read directly from <code>a</code> and <code>b</code> and
then store the result right into <code>c</code>.</p>
<p>There&rsquo;s only a single instruction to decode and dispatch, and the whole thing
fits in four bytes. Decoding is more complex because of the additional operands,
but it&rsquo;s still a net win. There&rsquo;s no pushing and popping or other stack
manipulation.</p>
<p>The main implementation of Lua used to be stack-based. For <span name="lua">Lua
5.0</span>, the implementers switched to a register instruction set and noted a
speed improvement. The amount of improvement, naturally, depends heavily on the
details of the language semantics, specific instruction set, and compiler
sophistication, but that should get your attention.</p>
<aside name="lua">
<p>The Lua dev team<span class="em">&mdash;</span>Roberto Ierusalimschy, Waldemar Celes, and Luiz Henrique de
Figueiredo<span class="em">&mdash;</span>wrote a <em>fantastic</em> paper on this, one of my all time favorite
computer science papers, &ldquo;<a href="https://www.lua.org/doc/jucs05.pdf">The Implementation of Lua 5.0</a>&rdquo; (PDF).</p>
</aside>
<p>That raises the obvious question of why I&rsquo;m going to spend the rest of the book
doing a stack-based bytecode. Register VMs are neat, but they are quite a bit
harder to write a compiler for. For what is likely to be your very first
compiler, I wanted to stick with an instruction set that&rsquo;s easy to generate and
easy to execute. Stack-based bytecode is marvelously simple.</p>
<p>It&rsquo;s also <em>much</em> better known in the literature and the community. Even though
you may eventually move to something more advanced, it&rsquo;s a good common ground to
share with the rest of your language hacker peers.</p>
</div>
<div class="design-note">
<p>在本书的其余部分，我们将围绕基于堆栈的字节码指令集精心实现一个解释器。此外还有另一种字节码架构——基于寄存器。尽管名称如此，但这些字节码指令并不像 <span name="x64_zh">x64</span> 这样的真实芯片中的寄存器那样难以操作。对于真正的硬件寄存器，整个程序通常只用少数几个，所以你<a href="https://en.wikipedia.org/wiki/Register_allocation">要花很多精力来有效地使用它们，并把数据存入或取出</a>。（基于寄存器的字节码更接近于SPARC芯片支持的寄存器窗口）</p>
<aside name="x64_zh">
<p>基于寄存器的字节码更接近 SPARC 芯片支持的<a href="https://en.wikipedia.org/wiki/Register_window"><em>寄存器窗口</em></a>。</p>
</aside>
<p>在一个基于寄存器的虚拟机中，仍然有一个栈。临时值还是被压入栈中，当不再需要时再被弹出。主要的区别是，指令可以从栈的任意位置读取它们的输入值，并可以将它们的输出值存储到任一指定的槽中。</p>
<p>以Lox脚本为例：</p>
<div class="codehilite"><pre><span class="i">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="i">var</span> <span class="i">b</span> = <span class="n">2</span>;
<span class="i">var</span> <span class="i">c</span> = <span class="i">a</span> + <span class="i">b</span>;
</pre></div>
<p>在我们基于堆栈的虚拟机中，最后一条指令的编译结果类似于：</p>
<div class="codehilite"><pre><span class="i">load</span> &lt;<span class="i">a</span>&gt;  <span class="c">// 读取局部变量a，并将其压入栈</span>
<span class="i">load</span> &lt;<span class="i">b</span>&gt;  <span class="c">// 读取局部变量b，并将其压入栈</span>
<span class="i">add</span>       <span class="c">// 弹出两个值，相加，将结果压入栈</span>
<span class="i">store</span> &lt;<span class="i">c</span>&gt; <span class="c">// 弹出值，并存入局部变量c</span>
</pre></div>
<p>（如果你还没有完全理解加载load和存储store指令，也不用担心。我们会在实现变量时详细地讨论它们）我们有四条独立的指令，这意味着会有四次字节码解释循环，四条指令需要解码和调度。这至少包含7个字节的代码——四个字节是操作码，另外三个是操作数，用于标识要加载和存储哪些局部变量。三次入栈，三次出栈，工作量很大！</p>
<p>在基于寄存器的指令集中，指令可以直接对局部变量进行读取和存储。上面最后一条语句的字节码如下所示：</p>
<div class="codehilite"><pre><span class="i">add</span> &lt;<span class="i">a</span>&gt; &lt;<span class="i">b</span>&gt; &lt;<span class="i">c</span>&gt; <span class="c">// 从a和b中读取值，相加，并存储到c中</span>
</pre></div>
<p>add指令比之前更大——有三个指令操作数，定义了从堆栈的哪个位置读取输入，并将结果写入哪个位置。但由于局部变量在堆栈中，它可以直接从<code>a</code>和<code>b</code>中读取数据，如何将结果存入<code>c</code>中。</p>
<p>只有一条指令需要解码和调度，整个程序只需要四个字节。由于有了额外的操作数，解码变得更加复杂，但相比之下它仍然是更优秀的。没有压入和弹出或其它堆栈操作。</p>
<p>Lua的实现曾经是基于堆栈的。到了<span name="lua_zh">Lua
5.0</span>，实现切换到了寄存器指令集，并注意到速度有所提高。当然，提高的幅度很大程度上取决于语言语义的细节、特定指令集和编译器复杂性，但这应该引起你的注意。</p>
<aside name="lua_zh">
<p>Lua 开发团队<span class="em">&mdash;</span>Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo<span class="em">&mdash;</span>就此撰写了一篇 <em>精彩</em> 的论文，这也是我一直以来最喜欢的计算机科学论文之一: <a href="https://www.lua.org/doc/jucs05.pdf">《Lua 5.0 的实现》</a>（PDF）。</p>
</aside>
<p>这就引出了一个显而易见的问题：我为什么要在本书的剩余部分做一个基于堆栈的字节码。寄存器虚拟机是很好的，但要为它们编写编译器却相当困难。考虑到这可能是你写的第一个编译器，我想坚持使用一个易于生成和易于执行的指令集。基于堆栈的字节码是非常简单的。</p>
<p>它的文献和社区中也更广为人知。即使你最终可能会转向更高级的东西，这也是一个你可以与其他语言开发者分享的很好的共同点。</p>
</div>

    <footer>
      <a href="scanning-on-demand.html" class="next">
        下一节: &ldquo;按需扫描&rdquo; &rarr;
      </a>
      Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a
        href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy;
        2015&hairsp;&ndash;&hairsp;2021</a>
    </footer>
  </article>

  </div>
  </body>
  </html>
