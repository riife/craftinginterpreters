<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>函数 &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
        <h3><a href="#top">函数<small>10</small></a></h3>
    
    <ul>
        <li><a href="#函数调用"><small>10.1</small> 函数调用</a></li>
        <li><a href="#原生函数（本地函数）"><small>10.2</small> 原生函数（本地函数）</a></li>
        <li><a href="#函数声明"><small>10.3</small> 函数声明</a></li>
        <li><a href="#函数对象"><small>10.4</small> 函数对象</a></li>
        <li><a href="#return语句"><small>10.5</small> Return语句</a></li>
        <li><a href="#局部函数和闭包"><small>10.6</small> 局部函数和闭包</a></li>
        <li class="divider"></li>
        <li class="end-part"><a href="#challenges">Challenges</a></li>
    </ul>
    
    
        <div class="prev-next">
        <a href="control-flow.html" title="控制流" class="left">&larr;&nbsp;Previous</a>
        <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
        <a href="resolving-and-binding.html" title="解析和绑定" class="right">Next&nbsp;&rarr;</a>
    </div> </div>
</nav>

<nav class="narrow">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <a href="control-flow.html" title="控制流" class="prev">←</a>
  <a href="resolving-and-binding.html" title="解析和绑定" class="next">→</a>
</nav>

<div class="page">
  <div class="nav-wrapper">
    <nav class="floating">
      <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
      <div class="expandable">
        <h3><a href="#top">函数<small>10</small></a></h3>
        
        <ul>
            <li><a href="#函数调用"><small>10.1</small> 函数调用</a></li>
            <li><a href="#原生函数（本地函数）"><small>10.2</small> 原生函数（本地函数）</a></li>
            <li><a href="#函数声明"><small>10.3</small> 函数声明</a></li>
            <li><a href="#函数对象"><small>10.4</small> 函数对象</a></li>
            <li><a href="#return语句"><small>10.5</small> Return语句</a></li>
            <li><a href="#局部函数和闭包"><small>10.6</small> 局部函数和闭包</a></li>
            <li class="divider"></li>
            <li class="end-part"><a href="#challenges">Challenges</a></li>
        </ul>
        
        
                <div class="prev-next">
            <a href="control-flow.html" title="控制流" class="left">&larr;&nbsp;Previous</a>
            <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
            <a href="resolving-and-binding.html" title="解析和绑定" class="right">Next&nbsp;&rarr;</a>
        </div>      </div>
      <a id="expand-nav">≡</a>
    </nav>
  </div>

  <article class="chapter">

    <div class="number">10</div>
    <h1>函数</h1>

    <blockquote>
<p>And that is also the way the human mind works<span class="em">&mdash;</span>by the compounding of old
ideas into new structures that become new ideas that can themselves be used in
compounds, and round and round endlessly, growing ever more remote from the
basic earthbound imagery that is each language&rsquo;s soil.
这也是人类思维的运作方式——将旧的想法复合成为新结构，成为新的想法，而这些想法本身又可以被用于复合，循环往复，无休无止，越来越远离每一种语言赖以生存的基本的土壤。</p>
<p><cite>Douglas R. Hofstadter, <em>I Am a Strange Loop</em></cite></p>
</blockquote>
<p>This chapter marks the culmination of a lot of hard work. The previous chapters
add useful functionality in their own right, but each also supplies a piece of a
<span name="lambda">puzzle</span>. We&rsquo;ll take those pieces<span class="em">&mdash;</span>expressions,
statements, variables, control flow, and lexical scope<span class="em">&mdash;</span>add a couple more, and
assemble them all into support for real user-defined functions and function
calls.
这一章标志着很多艰苦工作的一个高潮。在前面的章节中，各自添加了一些有用的功能，但是每一章也都提供了一个拼图的碎片。我们整理这些碎片——表达式、语句、变量、控制流和词法作用域，再加上其它功能，并把他们组合起来，以支持真正的用户定义函数和函数调用。</p>
<aside name="lambda"><img src="image/functions/lambda.png" alt="A lambda puzzle." />
</aside>
<h2><a href="#函数调用" id="函数调用"><small>10&#8202;.&#8202;1</small>函数调用</a></h2>
<p>You&rsquo;re certainly familiar with C-style function call syntax, but the grammar is
more subtle than you may realize. Calls are typically to named functions like:
你肯定熟悉C语言风格的函数调用语法，但其语法可能比你意识到的更微妙。调用通常是指向命名的函数，例如：</p>
<div class="codehilite"><pre><span class="i">average</span>(<span class="n">1</span>, <span class="n">2</span>);
</pre></div>
<p>But the <span name="pascal">name</span> of the function being called isn&rsquo;t
actually part of the call syntax. The thing being called<span class="em">&mdash;</span>the <strong>callee</strong><span class="em">&mdash;</span>can be any expression that evaluates to a function. (Well, it does have to be a
pretty <em>high precedence</em> expression, but parentheses take care of that.) For
example:
但是被调用函数的名称实际上并不是调用语法的一部分。被调用者（<strong>callee</strong>）可以是计算结果为一个函数的任何表达式。(好吧，它必须是一个非常高优先级的表达式，但是圆括号可以解决这个问题。)例如：</p>
<aside name="pascal">
<p>The name <em>is</em> part of the call syntax in Pascal. You can call only named
functions or functions stored directly in variables.
名称 <em>是</em> Pascal 调用语法的一部分。你只能调用已命名的函数或直接存储在变量中的函数。</p>
</aside>
<div class="codehilite"><pre><span class="i">getCallback</span>()();
</pre></div>
<p>There are two call expressions here. The first pair of parentheses has
<code>getCallback</code> as its callee. But the second call has the entire <code>getCallback()</code>
expression as its callee. It is the parentheses following an expression that
indicate a function call. You can think of a call as sort of like a postfix
operator that starts with <code>(</code>.
这里有两个函数调用。第一对括号将<code>getCallback</code>作为其被调用者。但是第二对括号将整个<code>getCallback()</code> 表达式作为其被调用者。表达式后面的小括号表示函数调用，你可以把调用看作是一种以<code>(</code>开头的后缀运算符。</p>
<p>This &ldquo;operator&rdquo; has higher precedence than any other operator, even the unary
ones. So we slot it into the grammar by having the <code>unary</code> rule bubble up to a
new <code>call</code> rule.
这个“运算符”比其它运算符（包括一元运算符）有更高的优先级。所以我们通过让<code>unary</code>规则跳转到新的<code>call</code>规则，将其添加到语法中。</p>
<p><span name="curry"></span></p>
<div class="codehilite"><pre><span class="i">unary</span>          → ( <span class="s">&quot;!&quot;</span> | <span class="s">&quot;-&quot;</span> ) <span class="i">unary</span> | <span class="i">call</span> ;
<span class="i">call</span>           → <span class="i">primary</span> ( <span class="s">&quot;(&quot;</span> <span class="i">arguments</span>? <span class="s">&quot;)&quot;</span> )* ;
</pre></div>
<p>This rule matches a primary expression followed by zero or more function calls.
If there are no parentheses, this parses a bare primary expression. Otherwise,
each call is recognized by a pair of parentheses with an optional list of
arguments inside. The argument list grammar is:
该规则匹配一个基本表达式，后面跟着0个或多个函数调用。如果没有括号，则解析一个简单的基本表达式。否则，每一对圆括号都表示一个函数调用，圆括号内有一个可选的参数列表。参数列表语法是：</p>
<aside name="curry">
<p>The rule uses <code>*</code> to allow matching a series of calls like <code>fn(1)(2)(3)</code>. Code
like that isn&rsquo;t common in C-style languages, but it is in the family of
languages derived from ML. There, the normal way of defining a function that
takes multiple arguments is as a series of nested functions. Each function takes
one argument and returns a new function. That function consumes the next
argument, returns yet another function, and so on. Eventually, once all of the
arguments are consumed, the last function completes the operation.
该规则中使用<code>*</code>符号匹配类似<code>fn(1)(2)(3)</code>的系列函数调用。这样的代码不是常见的C语言风格，但是在ML衍生的语言族中很常见。在ML中，定义接受多个参数的函数的常规方式是将其定义为一系列嵌套函数。每个函数接受一个参数并返回一个新函数。该函数使用下一个参数，返回另一个函数，以此类推。最终，一旦所有参数都被使用，最后一个函数就完成了操作。</p>
<p>This style, called <strong>currying</strong>, after Haskell Curry (the same guy whose first
name graces that <em>other</em> well-known functional language), is baked directly into
the language syntax so it&rsquo;s not as weird looking as it would be here.
这种风格被称为柯里化，是以Haskell Curry（他的名字出现在另一个广为人知的函数式语言中）的名字命名的，它被直接整合到语言的语法中，所以它不像这里看起来那么奇怪。</p>
</aside>
<div class="codehilite"><pre><span class="i">arguments</span>      → <span class="i">expression</span> ( <span class="s">&quot;,&quot;</span> <span class="i">expression</span> )* ;
</pre></div>
<p>This rule requires at least one argument expression, followed by zero or more
other expressions, each preceded by a comma. To handle zero-argument calls, the
<code>call</code> rule itself considers the entire <code>arguments</code> production to be optional.
这个规则要求至少有一个参数表达式，后面可以跟0个或多个其它表达式，每两个表达式之间用<code>,</code>分隔。为了处理无参调用，<code>call</code>规则本身认为整个<code>arguments</code>生成式是可选的。</p>
<p>I admit, this seems more grammatically awkward than you&rsquo;d expect for the
incredibly common &ldquo;zero or more comma-separated things&rdquo; pattern. There are some
sophisticated metasyntaxes that handle this better, but in our BNF and in many
language specs I&rsquo;ve seen, it is this cumbersome.
我承认，对于极其常见的 &ldquo;零或多个逗号分隔的事物&rdquo; 模式来说，这在语法上似乎比你想象的更难处理。有一些复杂的元语法可以更好地处理这个问题，但在我们的BNF和我见过的许多语言规范中，它就是如此的麻烦。</p>
<p>Over in our syntax tree generator, we add a <span name="call-ast">new
node</span>.
在我们的语法树生成器中，我们添加一个新节点。</p>
<div class="codehilite"><pre class="insert-before">      &quot;Binary   : Expr left, Token operator, Expr right&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Call     : Expr callee, Token paren, List&lt;Expr&gt; arguments&quot;</span>,
</pre><pre class="insert-after">      &quot;Grouping : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="call-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#call-expression">Appendix II</a>.
新节点的生成代码见<a href="appendix-ii.html#call-expression">附录 II</a>。</p>
</aside>
<p>It stores the callee expression and a list of expressions for the arguments. It
also stores the token for the closing parenthesis. We&rsquo;ll use that token&rsquo;s
location when we report a runtime error caused by a function call.
它存储了被调用者表达式和参数表达式列表，同时也保存了右括号标记。当我们报告由函数调用引起的运行时错误时，会使用该标记的位置。</p>
<p>Crack open the parser. Where <code>unary()</code> used to jump straight to <code>primary()</code>,
change it to call, well, <code>call()</code>.
打开解析器，原来<code>unary()</code>直接跳转到<code>primary()</code>方法，将其修改为调用<code>call()</code>。</p>
<div class="codehilite"><pre class="insert-before">      return new Expr.Unary(operator, right);
    }

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>unary</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">return</span> <span class="i">call</span>();
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>unary</em>(), replace 1 line</div>

<p>Its definition is:
该方法定义为：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>unary</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">call</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">primary</span>();

    <span class="k">while</span> (<span class="k">true</span>) {<span name="while-true"> </span>
      <span class="k">if</span> (<span class="i">match</span>(<span class="i">LEFT_PAREN</span>)) {
        <span class="i">expr</span> = <span class="i">finishCall</span>(<span class="i">expr</span>);
      } <span class="k">else</span> {
        <span class="k">break</span>;
      }
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>unary</em>()</div>

<p>The code here doesn&rsquo;t quite line up with the grammar rules. I moved a few things
around to make the code cleaner<span class="em">&mdash;</span>one of the luxuries we have with a
handwritten parser. But it&rsquo;s roughly similar to how we parse infix operators.
First, we parse a primary expression, the &ldquo;left operand&rdquo; to the call. Then, each
time we see a <code>(</code>, we call <code>finishCall()</code> to parse the call expression using the
previously parsed expression as the callee. The returned expression becomes the
new <code>expr</code> and we loop to see if the result is itself called.
这里的代码与语法规则并非完全一致。为了保持代码简洁，我调整了一些东西——这是我们手写解析器的优点之一。但它与我们解析中缀运算符的方式类似。首先，我们解析一个基本表达式，即调用的左操作数。然后，每次看到<code>(</code>，我们就调用<code>finishCall()</code>解析调用表达式，并使用之前解析出的表达式作为被调用者。返回的表达式成为新的<code>expr</code>，我们循环检查其结果是否被调用。</p>
<aside name="while-true">
<p>This code would be simpler as <code>while (match(LEFT_PAREN))</code> instead of the silly
<code>while (true)</code> and <code>break</code>. Don&rsquo;t worry, it will make sense when we expand the
parser later to handle properties on objects.
这段代码可以简化为<code>while (match(LEFT_PAREN))</code>形式，而不是使用这种愚蠢的<code>while (true)</code> 和 <code>break</code>形式。但是不用担心，稍后使用解析器处理对象属性的时候，这种写法就有意义了。</p>
</aside>
<p>The code to parse the argument list is in this helper:
解析参数列表的代码在下面的工具方法中：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>unary</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">finishCall</span>(<span class="t">Expr</span> <span class="i">callee</span>) {
    <span class="t">List</span>&lt;<span class="t">Expr</span>&gt; <span class="i">arguments</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">RIGHT_PAREN</span>)) {
      <span class="k">do</span> {
        <span class="i">arguments</span>.<span class="i">add</span>(<span class="i">expression</span>());
      } <span class="k">while</span> (<span class="i">match</span>(<span class="i">COMMA</span>));
    }

    <span class="t">Token</span> <span class="i">paren</span> = <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>,
                          <span class="s">&quot;Expect &#39;)&#39; after arguments.&quot;</span>);

    <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Call</span>(<span class="i">callee</span>, <span class="i">paren</span>, <span class="i">arguments</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>unary</em>()</div>

<p>This is more or less the <code>arguments</code> grammar rule translated to code, except
that we also handle the zero-argument case. We check for that case first by
seeing if the next token is <code>)</code>. If it is, we don&rsquo;t try to parse any arguments.
这或多或少是<code>arguments</code> 语法规则翻译成代码的结果，除了我们这里还处理了无参情况。我们首先判断下一个标记是否<code>)</code>来检查这种情况。如果是，我们就不会尝试解析任何参数。</p>
<p>Otherwise, we parse an expression, then look for a comma indicating that there
is another argument after that. We keep doing that as long as we find commas
after each expression. When we don&rsquo;t find a comma, then the argument list must
be done and we consume the expected closing parenthesis. Finally, we wrap the
callee and those arguments up into a call AST node.
如果不是，我们就解析一个表达式，然后寻找逗号（表明后面还有一个参数）。只要我们在表达式后面发现逗号，就会继续解析表达式。当我们找不到逗号时，说明参数列表已经结束，我们继续消费预期的右括号。最终，我们将被调用者和这些参数封装成一个函数调用的AST节点。</p>
<h3><a href="#最大参数数量" id="最大参数数量"><small>10&#8202;.&#8202;1&#8202;.&#8202;1</small>最大参数数量</a></h3>
<p>Right now, the loop where we parse arguments has no bound. If you want to call a
function and pass a million arguments to it, the parser would have no problem
with it. Do we want to limit that?
现在，我们解析参数的循环是没有边界的。如果你想调用一个函数并向其传递一百万个参数，解析器不会有任何问题。我们要对此进行限制吗？</p>
<p>Other languages have various approaches. The C standard says a conforming
implementation has to support <em>at least</em> 127 arguments to a function, but
doesn&rsquo;t say there&rsquo;s any upper limit. The Java specification says a method can
accept <em>no more than</em> <span name="254">255</span> arguments.
其它语言采用了不同的策略。C语言标准要求在符合标准的实现中，一个函数至少要支持127个参数，但是没有指定任何上限。Java规范规定一个方法可以接受不超过255个参数。</p>
<aside name="254">
<p>The limit is 25<em>4</em> arguments if the method is an instance method. That&rsquo;s because
<code>this</code><span class="em">&mdash;</span>the receiver of the method<span class="em">&mdash;</span>works like an argument that is
implicitly passed to the method, so it claims one of the slots.
如果该方法是一个实例方法，则限制为 25<em>4</em> 个参数。因为<code>this</code>（方法的接收者）就像一个被隐式传递给方法的参数一样，所以也会占用一个参数位置。</p>
</aside>
<p>Our Java interpreter for Lox doesn&rsquo;t really need a limit, but having a maximum
number of arguments will simplify our bytecode interpreter in <a href="a-bytecode-virtual-machine.html">Part III</a>. We
want our two interpreters to be compatible with each other, even in weird corner
cases like this, so we&rsquo;ll add the same limit to jlox.
Lox的Java解释器实际上并不需要限制，但是设置一个最大的参数数量限制可以简化<a href="a-bytecode-virtual-machine.html">第三部分</a>中的字节码解释器。即使是在这样奇怪的地方里，我们也希望两个解释器能够相互兼容，所以我们为jlox添加同样的限制。</p>
<div class="codehilite"><pre class="insert-before">      do {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>finishCall</em>()</div>
<pre class="insert">        <span class="k">if</span> (<span class="i">arguments</span>.<span class="i">size</span>() &gt;= <span class="n">255</span>) {
          <span class="i">error</span>(<span class="i">peek</span>(), <span class="s">&quot;Can&#39;t have more than 255 arguments.&quot;</span>);
        }
</pre><pre class="insert-after">        arguments.add(expression());
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>finishCall</em>()</div>

<p>Note that the code here <em>reports</em> an error if it encounters too many arguments,
but it doesn&rsquo;t <em>throw</em> the error. Throwing is how we kick into panic mode which
is what we want if the parser is in a confused state and doesn&rsquo;t know where it
is in the grammar anymore. But here, the parser is still in a perfectly valid
state<span class="em">&mdash;</span>it just found too many arguments. So it reports the error and keeps on
keepin&rsquo; on.
请注意，如果发现参数过多，这里的代码会<em>报告</em>一个错误，但是不会<em>抛出</em>该错误。抛出错误是进入恐慌模式的方法，如果解析器处于混乱状态，不知道自己在语法中处于什么位置，那这就是我们想要的。但是在这里，解析器仍然处于完全有效的状态，只是发现了太多的参数。所以它会报告这个错误，并继续执行解析。</p>
<h3><a href="#解释函数调用" id="解释函数调用"><small>10&#8202;.&#8202;1&#8202;.&#8202;2</small>解释函数调用</a></h3>
<p>We don&rsquo;t have any functions we can call, so it seems weird to start implementing
calls first, but we&rsquo;ll worry about that when we get there. First, our
interpreter needs a new import.
我们还没有任何可以调用的函数，所以先实现函数调用似乎有点奇怪，但是这个问题我们后面再考虑。首先，我们的解释器需要引入一个新依赖。</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert"><span class="k">import</span> <span class="i">java.util.ArrayList</span>;
</pre><pre class="insert-after">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em></div>

<p>As always, interpretation starts with a new visit method for our new call
expression node.
跟之前一样，解释工作从新的调用表达式节点对应的新的visit方法开始。</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitBinaryExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitCallExpr</span>(<span class="t">Expr</span>.<span class="t">Call</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">callee</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">callee</span>);

    <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">for</span> (<span class="t">Expr</span> <span class="i">argument</span> : <span class="i">expr</span>.<span class="i">arguments</span>) {<span name="in-order"> </span>
      <span class="i">arguments</span>.<span class="i">add</span>(<span class="i">evaluate</span>(<span class="i">argument</span>));
    }

    <span class="t">LoxCallable</span> <span class="i">function</span> = (<span class="t">LoxCallable</span>)<span class="i">callee</span>;
    <span class="k">return</span> <span class="i">function</span>.<span class="i">call</span>(<span class="k">this</span>, <span class="i">arguments</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitBinaryExpr</em>()</div>

<p>First, we evaluate the expression for the callee. Typically, this expression is
just an identifier that looks up the function by its name, but it could be
anything. Then we evaluate each of the argument expressions in order and store
the resulting values in a list.
首先，对被调用者的表达式求值。通常情况下，这个表达式只是一个标识符，可以通过它的名字来查找函数。但它可以是任何东西。然后，我们依次对每个参数表达式求值，并将结果值存储在一个列表中。</p>
<aside name="in-order">
<p>This is another one of those subtle semantic choices. Since argument expressions
may have side effects, the order they are evaluated could be user visible. Even
so, some languages like Scheme and C don&rsquo;t specify an order. This gives
compilers freedom to reorder them for efficiency, but means users may be
unpleasantly surprised if arguments aren&rsquo;t evaluated in the order they expect.
这是另一个微妙的语义选择。由于参数表达式可能有副作用，因此它们的执行顺序可能是用户可见的。即便如此，有些语言如Scheme和C并没有指定顺序。这样编译器可以自由地重新排序以提高效率，但这意味着如果参数没有按照用户期望的顺序计算，用户可能会感到不愉快。</p>
</aside>
<p>Once we&rsquo;ve got the callee and the arguments ready, all that remains is to
perform the call. We do that by casting the callee to a <span
name="callable">LoxCallable</span> and then invoking a <code>call()</code> method on it.
The Java representation of any Lox object that can be called like a function
will implement this interface. That includes user-defined functions, naturally,
but also class objects since classes are &ldquo;called&rdquo; to construct new instances.
We&rsquo;ll also use it for one more purpose shortly.
一旦我们准备好被调用者和参数，剩下的就是执行函数调用。我们将被调用者转换为LoxCallable，然后对其调用<code>call()</code>方法来实现。任何可以像函数一样被调用的Lox对象的Java表示都要实现这个接口。这自然包括用户定义的函数，但也包括类对象，因为类会被 &ldquo;调用&ldquo;来创建新的实例。稍后我们还将把它用于另一个目的。</p>
<aside name="callable">
<p>I stuck &ldquo;Lox&rdquo; before the name to distinguish it from the Java standard library&rsquo;s
own Callable interface. Alas, all the good simple names are already taken.
我在名称前加上了 &ldquo;Lox&rdquo;，以区别于 Java 标准库的 Callable 接口。唉，所有简单的好名字都已经被用完了。</p>
</aside>
<p>There isn&rsquo;t too much to this new interface.
这个新接口中没有太多内容。</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxCallable.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.List</span>;

<span class="k">interface</span> <span class="t">LoxCallable</span> {
  <span class="t">Object</span> <span class="i">call</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>, <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span>);
}
</pre></div>
<div class="source-file-narrow"><em>lox/LoxCallable.java</em>, create new file</div>

<p>We pass in the interpreter in case the class implementing <code>call()</code> needs it. We
also give it the list of evaluated argument values. The implementer&rsquo;s job is
then to return the value that the call expression produces.
我们会传入解释器，以防实现<code>call()</code>方法的类会需要它。我们也会提供已求值的参数值列表。接口实现者的任务就是返回调用表达式产生的值。</p>
<h3><a href="#调用类型错误" id="调用类型错误"><small>10&#8202;.&#8202;1&#8202;.&#8202;3</small>调用类型错误</a></h3>
<p>Before we get to implementing LoxCallable, we need to make the visit method a
little more robust. It currently ignores a couple of failure modes that we can&rsquo;t
pretend won&rsquo;t occur. First, what happens if the callee isn&rsquo;t actually something
you can call? What if you try to do this:
在实现<code>LoxCallable</code>之前，必须先强化一下我们的visit方法。这个方法忽略了两个可能出现的错误场景。第一个，如果被调用者无法被调用，会发生什么？比如：</p>
<div class="codehilite"><pre><span class="s">&quot;totally not a function&quot;</span>();
</pre></div>
<p>Strings aren&rsquo;t callable in Lox. The runtime representation of a Lox string is a
Java string, so when we cast that to LoxCallable, the JVM will throw a
ClassCastException. We don&rsquo;t want our interpreter to vomit out some nasty Java
stack trace and die. Instead, we need to check the type ourselves first.
在Lox中，字符串不是可调用的数据类型。Lox字符串在运行时中的本质其实是java字符串，所以当我们把它当作<code>LoxCallable</code> 处理的时候，JVM就会抛出<code>ClassCastException</code>。我们并不想让我们的解释器吐出一坨java堆栈信息然后挂掉。所以，我们自己必须先做一次类型检查。</p>
<div class="codehilite"><pre class="insert-before">    }

</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitCallExpr</em>()</div>
<pre class="insert">    <span class="k">if</span> (!(<span class="i">callee</span> <span class="k">instanceof</span> <span class="t">LoxCallable</span>)) {
      <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">paren</span>,
          <span class="s">&quot;Can only call functions and classes.&quot;</span>);
    }

</pre><pre class="insert-after">    LoxCallable function = (LoxCallable)callee;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitCallExpr</em>()</div>

<p>We still throw an exception, but now we&rsquo;re throwing our own exception type, one
that the interpreter knows to catch and report gracefully.
我们的实现同样也是抛出错误，但它们能够被解释器捕获并优雅地展示出来。</p>
<h3><a href="#checking-arity--检查元数" id="checking-arity--检查元数"><small>10&#8202;.&#8202;1&#8202;.&#8202;4</small>Checking arity  检查元数</a></h3>
<p>The other problem relates to the function&rsquo;s <strong>arity</strong>. Arity is the fancy term
for the number of arguments a function or operation expects. Unary operators
have arity one, binary operators two, etc. With functions, the arity is
determined by the number of parameters it declares.
另一个问题与函数的<strong>元数</strong>有关。元数是一个花哨的术语，指一个函数或操作所期望的参数数量。一元运算符的元数是1，二元运算符是2，等等。对于函数来说，元数由函数声明的参数数量决定。</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">add</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span> + <span class="i">c</span>;
}
</pre></div>
<p>This function defines three parameters, <code>a</code>, <code>b</code>, and <code>c</code>, so its arity is
three and it expects three arguments. So what if you try to call it like this:
这个函数定义了三个形参，<code>a</code> 、<code>b</code> 和<code>c</code>，所以它的元数是3，而且它期望有3个参数。那么如果你用下面的方式调用该函数会怎样：</p>
<div class="codehilite"><pre><span class="i">add</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="n">3</span>, <span class="n">4</span>); <span class="c">// Too many.</span>
<span class="i">add</span>(<span class="n">1</span>, <span class="n">2</span>);       <span class="c">// Too few.</span>
</pre></div>
<p>Different languages take different approaches to this problem. Of course, most
statically typed languages check this at compile time and refuse to compile the
code if the argument count doesn&rsquo;t match the function&rsquo;s arity. JavaScript
discards any extra arguments you pass. If you don&rsquo;t pass enough, it fills in the
missing parameters with the magic sort-of-like-null-but-not-really value
<code>undefined</code>. Python is stricter. It raises a runtime error if the argument list
is too short or too long.
不同的语言对这个问题采用了不同的方法。当然，大多数静态类型的语言在编译时都会检查这个问题，如果实参与函数元数不匹配，则拒绝编译代码。JavaScript会丢弃你传递的所有多余参数。如果你没有传入的参数数量不足，它就会用神奇的与<code>null</code>类似但并不相同的值<code>undefined</code>来填补缺少的参数。Python更严格。如果参数列表太短或太长，它会引发一个运行时错误。</p>
<p>I think the latter is a better approach. Passing the wrong number of arguments
is almost always a bug, and it&rsquo;s a mistake I do make in practice. Given that,
the sooner the implementation draws my attention to it, the better. So for Lox,
we&rsquo;ll take Python&rsquo;s approach. Before invoking the callable, we check to see if
the argument list&rsquo;s length matches the callable&rsquo;s arity.
我认为后者是一种更好的方法。传递错误的参数数量几乎总是一个错误，这也是我在实践中确实犯的一个错误。有鉴于此，语言实现能越早引起用户的注意就越好。所以对于Lox，我们将采取Python的方法。在执行可调用方法之前，我们检查参数列表的长度是否与可调用方法的元数相符。</p>
<div class="codehilite"><pre class="insert-before">    LoxCallable function = (LoxCallable)callee;
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitCallExpr</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">arguments</span>.<span class="i">size</span>() != <span class="i">function</span>.<span class="i">arity</span>()) {
      <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">paren</span>, <span class="s">&quot;Expected &quot;</span> +
          <span class="i">function</span>.<span class="i">arity</span>() + <span class="s">&quot; arguments but got &quot;</span> +
          <span class="i">arguments</span>.<span class="i">size</span>() + <span class="s">&quot;.&quot;</span>);
    }

</pre><pre class="insert-after">    return function.call(this, arguments);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitCallExpr</em>()</div>

<p>That requires a new method on the LoxCallable interface to ask it its arity.
这就需要在<code>LoxCallable</code>接口中增加一个新方法来查询函数的元数。</p>
<div class="codehilite"><pre class="insert-before">interface LoxCallable {
</pre><div class="source-file"><em>lox/LoxCallable.java</em><br>
in interface <em>LoxCallable</em></div>
<pre class="insert">  <span class="t">int</span> <span class="i">arity</span>();
</pre><pre class="insert-after">  Object call(Interpreter interpreter, List&lt;Object&gt; arguments);
</pre></div>
<div class="source-file-narrow"><em>lox/LoxCallable.java</em>, in interface <em>LoxCallable</em></div>

<p>We <em>could</em> push the arity checking into the concrete implementation of <code>call()</code>.
But, since we&rsquo;ll have multiple classes implementing LoxCallable, that would end
up with redundant validation spread across a few classes. Hoisting it up into
the visit method lets us do it in one place.
我们可以在<code>call()</code>方法的具体实现中做元数检查。但是，由于我们会有多个实现LoxCallable的类，这将导致冗余的验证分散在多个类中。把它提升到访问方法中，这样我们可以在一个地方完成该功能。</p>
<h2><a href="#原生函数（本地函数）" id="原生函数（本地函数）"><small>10&#8202;.&#8202;2</small>原生函数（本地函数）</a></h2>
<p>We can theoretically call functions, but we have no functions to call yet.
Before we get to user-defined functions, now is a good time to introduce a vital
but often overlooked facet of language implementations<span class="em">&mdash;</span><span
name="native"><strong>native functions</strong></span>. These are functions that the
interpreter exposes to user code but that are implemented in the host language
(in our case Java), not the language being implemented (Lox).
理论上我们可以调用函数了，但是我们还没有可供调用的函数。在我们实现用户自定义函数之前，现在正好可以介绍语言实现中一个重要但经常被忽视的方面——<strong>原生函数（本地函数）</strong>。这些函数是解释器向用户代码公开的，但它们是用宿主语言(在我们的例子中是Java)实现的，而不是正在实现的语言(Lox)。</p>
<p>Sometimes these are called <strong>primitives</strong>, <strong>external functions</strong>, or <strong>foreign
functions</strong>. Since these functions can be called while the user&rsquo;s program is
running, they form part of the implementation&rsquo;s runtime. A lot of programming
language books gloss over these because they aren&rsquo;t conceptually interesting.
They&rsquo;re mostly grunt work.
有时这些函数也被称为<strong>原语</strong>、<strong>外部函数</strong>或<strong>外来函数</strong>。由于这些函数可以在用户程序运行的时候被调用，因此它们构成了语言运行时的一部分。许多编程语言书籍都掩盖了这些内容，因为它们在概念上并不有趣。它们主要是一些比较繁重的工作。</p>
<aside name="native">
<p>Curiously, two names for these functions<span class="em">&mdash;</span>&ldquo;native&rdquo; and &ldquo;foreign&rdquo;<span class="em">&mdash;</span>are
antonyms. Maybe it depends on the perspective of the person choosing the term.
If you think of yourself as &ldquo;living&rdquo; within the runtime&rsquo;s implementation (in our
case, Java) then functions written in that are &ldquo;native&rdquo;. But if you have the
mindset of a <em>user</em> of your language, then the runtime is implemented in some
other &ldquo;foreign&rdquo; language.
奇怪的是，这些函数的两个名称 &ldquo;native&rdquo; 和 &ldquo;foreign&rdquo; 是反义词。也许这取决于选择这个词的人的角度。如果您认为自己生活在运行时实现中(在我们的例子中是Java)，那么用它编写的函数就是 &ldquo;native&rdquo; 的。但是，如果您站在语言用户的角度，那么运行时就是用其他&ldquo;foreign&rdquo; 语言实现的。</p>
<p>Or it may be that &ldquo;native&rdquo; refers to the machine code language of the underlying
hardware. In Java, &ldquo;native&rdquo; methods are ones implemented in C or C++ and
compiled to native machine code.
或者 &ldquo;native&rdquo; 指的是底层硬件的机器代码语言。在Java中，&ldquo;native&rdquo; 方法是用C或c++实现并编译为 &ldquo;native&rdquo; 机器码的方法。</p><img src="image/functions/foreign.png" class="above" alt="All a matter of perspective." />
</aside>
<p>But when it comes to making your language actually good at doing useful stuff,
the native functions your implementation provides are key. They provide access
to the fundamental services that all programs are defined in terms of. If you
don&rsquo;t provide native functions to access the file system, a user&rsquo;s going to have
a hell of a time writing a program that reads and <span
name="print">displays</span> a file.
但是说到让你的语言真正擅长做有用的事情，语言提供的本地函数是关键。本地函数提供了对基础服务的访问，所有的程序都是根据这些服务来定义的。如果你不提供访问文件系统的本地函数，那么用户在写一个读取和显示文件的程序时就会有很大的困难。</p>
<aside name="print">
<p>A classic native function almost every language provides is one to print text to
stdout. In Lox, I made <code>print</code> a built-in statement so that we could get stuff
on screen in the chapters before this one.
几乎每种语言都提供的一个经典的本地函数是将文本打印到标准输出。在Lox中，我将<code>print</code>作为了内置语句，以便可以在前面的章节中看到代码结果。</p>
<p>Once we have functions, we could simplify the language by tearing out the old
print syntax and replacing it with a native function. But that would mean that
examples early in the book wouldn&rsquo;t run on the interpreter from later chapters
and vice versa. So, for the book, I&rsquo;ll leave it alone.
一旦我们有了函数，我们就可以删除之前的<code>print</code>语法并用一个本机函数替换它，从而简化语言。但这意味着书中前面的例子不能在后面章节的解释器上运行，反之亦然。所以，在这本书中，我不去修改它。</p>
<p>If you&rsquo;re building an interpreter for your <em>own</em> language, though, you may want
to consider it.
但是，如果您正在为自己的语言构建一个解释器，您可能需要考虑一下。</p>
</aside>
<p>Many languages also allow users to provide their own native functions. The
mechanism for doing so is called a <strong>foreign function interface</strong> (<strong>FFI</strong>),
<strong>native extension</strong>, <strong>native interface</strong>, or something along those lines.
These are nice because they free the language implementer from providing access
to every single capability the underlying platform supports. We won&rsquo;t define an
FFI for jlox, but we will add one native function to give you an idea of what it
looks like.
许多语言还允许用户提供自己的本地函数。这样的机制称为<strong>外来函数接口(FFI)</strong>、<strong>本机扩展</strong>、<strong>本机接口</strong>或类似的东西。这些机制很好，因为它们使语言实现者无需提供对底层平台所支持的每一项功能的访问。我们不会为 jlox 定义一个 FFI，但我们会添加一个本地函数，让你知道它是什么样子。</p>
<h3><a href="#报时" id="报时"><small>10&#8202;.&#8202;2&#8202;.&#8202;1</small>报时</a></h3>
<p>When we get to <a href="a-bytecode-virtual-machine.html">Part III</a> and start working on a much more efficient
implementation of Lox, we&rsquo;re going to care deeply about performance. Performance
work requires measurement, and that in turn means <strong>benchmarks</strong>. These are
programs that measure the time it takes to exercise some corner of the
interpreter.
当我们进入第三部分，开始着手开发更有效的Lox实现时，我们就会非常关心性能。性能需要测量，这也就意味着需要<strong>基准测试</strong>。这些代码就是用于测量解释器执行某些代码时所花费的时间。</p>
<p>We could measure the time it takes to start up the interpreter, run the
benchmark, and exit, but that adds a lot of overhead<span class="em">&mdash;</span>JVM startup time, OS
shenanigans, etc. That stuff does matter, of course, but if you&rsquo;re just trying
to validate an optimization to some piece of the interpreter, you don&rsquo;t want
that overhead obscuring your results.
我们可以测量启动解释器、运行基准测试代码并退出所消耗的时间，但是这其中包括很多时间开销——JVM启动时间，操作系统欺诈等等。当然，这些东西确实很重要，但如果您只是试图验证对解释器某个部分的优化，你肯定不希望这些多余的时间开销掩盖你的结果。</p>
<p>A nicer solution is to have the benchmark script itself measure the time elapsed
between two points in the code. To do that, a Lox program needs to be able to
tell time. There&rsquo;s no way to do that now<span class="em">&mdash;</span>you can&rsquo;t implement a useful clock
&ldquo;from scratch&rdquo; without access to the underlying clock on the computer.
一个更好的解决方案是让基准脚本本身度量代码中两个点之间的时间间隔。要做到这一点，Lox程序需要能够报时。现在没有办法做到这一点——如果不访问计算机上的底层时钟，就无法从头实现一个可用的时钟。</p>
<p>So we&rsquo;ll add <code>clock()</code>, a native function that returns the number of seconds
that have passed since some fixed point in time. The difference between two
successive invocations tells you how much time elapsed between the two calls.
This function is defined in the global scope, so let&rsquo;s ensure the interpreter
has access to that.
所以我们要添加<code>clock()</code>，这是一个本地函数，用于返回自某个固定时间点以来所经过的秒数。两次连续调用之间的差值可用告诉你两次调用之间经过了多少时间。这个函数被定义在全局作用域内，以确保解释器能够访问这个函数。</p>
<div class="codehilite"><pre class="insert-before">class Interpreter implements Expr.Visitor&lt;Object&gt;,
                             Stmt.Visitor&lt;Void&gt; {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em><br>
replace 1 line</div>
<pre class="insert">  <span class="k">final</span> <span class="t">Environment</span> <span class="i">globals</span> = <span class="k">new</span> <span class="t">Environment</span>();
  <span class="k">private</span> <span class="t">Environment</span> <span class="i">environment</span> = <span class="i">globals</span>;
</pre><pre class="insert-after">

  void interpret(List&lt;Stmt&gt; statements) {
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em>, replace 1 line</div>

<p>The <code>environment</code> field in the interpreter changes as we enter and exit local
scopes. It tracks the <em>current</em> environment. This new <code>globals</code> field holds a
fixed reference to the outermost global environment.
解释器中的<code>environment</code>字段会随着进入和退出局部作用域而改变，它会跟随当前环境。新加的<code>globals</code>字段则固定指向最外层的全局作用域。</p>
<p>When we instantiate an Interpreter, we stuff the native function in that global
scope.
当我们实例化一个解释器时，我们将全局作用域中添加本地函数。</p>
<div class="codehilite"><pre class="insert-before">  private Environment environment = globals;

</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em></div>
<pre class="insert">  <span class="t">Interpreter</span>() {
    <span class="i">globals</span>.<span class="i">define</span>(<span class="s">&quot;clock&quot;</span>, <span class="k">new</span> <span class="t">LoxCallable</span>() {
      <span class="a">@Override</span>
      <span class="k">public</span> <span class="t">int</span> <span class="i">arity</span>() { <span class="k">return</span> <span class="n">0</span>; }

      <span class="a">@Override</span>
      <span class="k">public</span> <span class="t">Object</span> <span class="i">call</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>,
                         <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span>) {
        <span class="k">return</span> (<span class="t">double</span>)<span class="t">System</span>.<span class="i">currentTimeMillis</span>() / <span class="n">1000.0</span>;
      }

      <span class="a">@Override</span>
      <span class="k">public</span> <span class="t">String</span> <span class="i">toString</span>() { <span class="k">return</span> <span class="s">&quot;&lt;native fn&gt;&quot;</span>; }
    });
  }

</pre><pre class="insert-after">  void interpret(List&lt;Stmt&gt; statements) {
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>

<p>This defines a <span name="lisp-1">variable</span> named &ldquo;clock&rdquo;. Its value is a
Java anonymous class that implements LoxCallable. The <code>clock()</code> function takes
no arguments, so its arity is zero. The implementation of <code>call()</code> calls the
corresponding Java function and converts the result to a double value in
seconds.
这里有一个名为<code>clock</code>的变量，它的值是一个实现LoxCallable接口的Java匿名类。这里的<code>clock()</code>函数不接受参数，所以其元数为0。<code>call()</code>方法的实现是直接调用Java函数并将结果转换为以秒为单位的double值。</p>
<aside name="lisp-1">
<p>In Lox, functions and variables occupy the same namespace. In Common Lisp, the
two live in their own worlds. A function and variable with the same name don&rsquo;t
collide. If you call the name, it looks up the function. If you refer to it, it
looks up the variable. This does require jumping through some hoops when you do
want to refer to a function as a first-class value.
在 Lox 中，函数和变量占据同一个命名空间。在 Common Lisp 中，函数和变量生活在各自的世界里。同名的函数和变量不会发生冲突。如果你调用变量名，它会查找函数。如果你引用它，它就会查找变量。如果你想将函数作为first-class value 引用，这确实会有一些障碍。</p>
<p>Richard P. Gabriel and Kent Pitman coined the terms &ldquo;Lisp-1&rdquo; to refer to
languages like Scheme that put functions and variables in the same namespace,
and &ldquo;Lisp-2&rdquo; for languages like Common Lisp that partition them. Despite being
totally opaque, those names have since stuck. Lox is a Lisp-1.
Richard P. Gabriel 和 Kent Pitman 创造了 &ldquo;Lisp-1&rdquo; 这个术语，用来指像 Scheme 这样将函数和变量放在同一命名空间的语言，而 &ldquo;Lisp-2&rdquo; 则指像 Common Lisp 这样将它们分隔开来的语言。尽管完全不透明，但这些名称后来一直沿用至今。Lox 就是一种 Lisp-1。</p>
</aside>
<p>If we wanted to add other native functions<span class="em">&mdash;</span>reading input from the user,
working with files, etc.<span class="em">&mdash;</span>we could add them each as their own anonymous class
that implements LoxCallable. But for the book, this one is really all we need.
如果我们想要添加其它本地函数——读取用户输入，处理文件等等——我们可以依次为它们提供实现LoxCallable接口的匿名类。但是在本书中，这个函数足以满足需要。</p>
<p>Let&rsquo;s get ourselves out of the function-defining business and let our users
take over<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>
让我们从函数定义的事务中解脱出来，由用户来接管吧。</p>
<h2><a href="#函数声明" id="函数声明"><small>10&#8202;.&#8202;3</small>函数声明</a></h2>
<p>We finally get to add a new production to the <code>declaration</code> rule we introduced
back when we added variables. Function declarations, like variables, bind a new
<span name="name">name</span>. That means they are allowed only in places where
a declaration is permitted.
我们终于可以在添加变量时就引入的<code>declaration</code>规则中添加产生式了。就像变量一样，函数声明也会绑定一个新的名称。这意味中它们只能出现在允许声明的地方。</p>
<aside name="name">
<p>A named function declaration isn&rsquo;t really a single primitive operation. It&rsquo;s
syntactic sugar for two distinct steps: (1) creating a new function object, and
(2) binding a new variable to it. If Lox had syntax for anonymous functions, we
wouldn&rsquo;t need function declaration statements. You could just do:
命名函数声明并不是一个真正的原始操作。它是两个不同步骤的语法糖： (1) 创建一个新的函数对象，以及 (2) 将一个新变量绑定到该对象上。如果 Lox 有匿名函数的语法，我们就不需要函数声明语句了。你只需:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">add</span> = <span class="k">fun</span> (<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span>;
};
</pre></div>
<p>However, since named functions are the common case, I went ahead and gave Lox
nice syntax for them.
不过，由于命名函数是常见的情况，我还是为它们提供了良好的 Lox 语法。</p>
</aside>
<div class="codehilite"><pre><span class="i">declaration</span>    → <span class="i">funDecl</span>
               | <span class="i">varDecl</span>
               | <span class="i">statement</span> ;
</pre></div>
<p>The updated <code>declaration</code> rule references this new rule:
更新后的<code>declaration</code>引用了下面的新规则：</p>
<div class="codehilite"><pre><span class="i">funDecl</span>        → <span class="s">&quot;fun&quot;</span> <span class="i">function</span> ;
<span class="i">function</span>       → <span class="t">IDENTIFIER</span> <span class="s">&quot;(&quot;</span> <span class="i">parameters</span>? <span class="s">&quot;)&quot;</span> <span class="i">block</span> ;
</pre></div>
<p>The main <code>funDecl</code> rule uses a separate helper rule <code>function</code>. A function
<em>declaration statement</em> is the <code>fun</code> keyword followed by the actual function-y
stuff. When we get to classes, we&rsquo;ll reuse that <code>function</code> rule for declaring
methods. Those look similar to function declarations, but aren&rsquo;t preceded by
<span name="fun"><code>fun</code></span>.
主要的<code>funDecl</code>规则使用了一个单独的辅助规则<code>function</code>。函数<em>声明语句</em>是<code>fun</code>关键字后跟实际的函数体内容。等到我们实现类的时候，将会复用<code>function</code>规则来声明方法。这些方法与函数声明类似，但是前面没有<code>fun</code>。</p>
<aside name="fun">
<p>Methods are too classy to have fun.
方法太高雅了，不好玩。</p>
</aside>
<p>The function itself is a name followed by the parenthesized parameter list and
the body. The body is always a braced block, using the same grammar rule that
block statements use. The parameter list uses this rule:
函数本身是一个名称，后跟带括号的参数列表和函数体。函数体是一个带花括号的块，可以使用与块语句相同的语法。参数列表则使用以下规则：</p>
<div class="codehilite"><pre><span class="i">parameters</span>     → <span class="t">IDENTIFIER</span> ( <span class="s">&quot;,&quot;</span> <span class="t">IDENTIFIER</span> )* ;
</pre></div>
<p>It&rsquo;s like the earlier <code>arguments</code> rule, except that each parameter is an
identifier, not an expression. That&rsquo;s a lot of new syntax for the parser to chew
through, but the resulting AST <span name="fun-ast">node</span> isn&rsquo;t too bad.
这就类似于前面的<code>arguments</code> 规则，区别在于参数是一个标识符，而不是一个表达式。这对于解析器来说是很多要处理的新语法，但是生成的AST节点没这么复杂。</p>
<div class="codehilite"><pre class="insert-before">      &quot;Expression : Expr expression&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Function   : Token name, List&lt;Token&gt; params,&quot;</span> +
                  <span class="s">&quot; List&lt;Stmt&gt; body&quot;</span>,
</pre><pre class="insert-after">      &quot;If         : Expr condition, Stmt thenBranch,&quot; +
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="fun-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#function-statement">Appendix II</a>.
新节点的生成代码见<a href="appendix-ii.html#function-statement">附录 II</a>。</p>
</aside>
<p>A function node has a name, a list of parameters (their names), and then the
body. We store the body as the list of statements contained inside the curly
braces.
函数节点有一个名称、一个参数列表(参数的名称)，然后是函数主体。我们将函数主体存储为包含在花括号中的语句列表。</p>
<p>Over in the parser, we weave in the new declaration.
在解析器中，我们把新的声明添加进去。</p>
<div class="codehilite"><pre class="insert-before">    try {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>declaration</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">match</span>(<span class="i">FUN</span>)) <span class="k">return</span> <span class="i">function</span>(<span class="s">&quot;function&quot;</span>);
</pre><pre class="insert-after">      if (match(VAR)) return varDeclaration();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>declaration</em>()</div>

<p>Like other statements, a function is recognized by the leading keyword. When we
encounter <code>fun</code>, we call <code>function</code>. That corresponds to the <code>function</code> grammar
rule since we already matched and consumed the <code>fun</code> keyword. We&rsquo;ll build the
method up a piece at a time, starting with this:
像其它语句一样，函数是通过前面的关键字来识别的。当我们遇到<code>fun</code>时，我们就调用<code>function</code>。这步操作对应于<code>function</code>语法规则，因为我们已经匹配并消费了<code>fun</code>关键字。我们会一步步构建这个方法，首先从下面的代码开始：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>expressionStatement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">function</span>(<span class="t">String</span> <span class="i">kind</span>) {
    <span class="t">Token</span> <span class="i">name</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">&quot;Expect &quot;</span> + <span class="i">kind</span> + <span class="s">&quot; name.&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expressionStatement</em>()</div>

<p>Right now, it only consumes the identifier token for the function&rsquo;s name. You
might be wondering about that funny little <code>kind</code> parameter. Just like we reuse
the grammar rule, we&rsquo;ll reuse the <code>function()</code> method later to parse methods
inside classes. When we do that, we&rsquo;ll pass in &ldquo;method&rdquo; for <code>kind</code> so that the
error messages are specific to the kind of declaration being parsed.
现在，它只是消费了标识符标记作为函数名称。你可能会对这里的<code>kind</code>参数感到疑惑。就像我们复用语法规则一样，稍后我们也会复用<code>function()</code>方法来解析类中的方法。到时候，我们会在<code>kind</code>参数中传入 &ldquo;method&rdquo;，这样错误信息就会针对被解析的声明类型来展示。</p>
<p>Next, we parse the parameter list and the pair of parentheses wrapped around it.
接下来，我们要解析参数列表和包裹着它们的一对小括号。</p>
<div class="codehilite"><pre class="insert-before">    Token name = consume(IDENTIFIER, &quot;Expect &quot; + kind + &quot; name.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>function</em>()</div>
<pre class="insert">    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &quot;</span> + <span class="i">kind</span> + <span class="s">&quot; name.&quot;</span>);
    <span class="t">List</span>&lt;<span class="t">Token</span>&gt; <span class="i">parameters</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">RIGHT_PAREN</span>)) {
      <span class="k">do</span> {
        <span class="k">if</span> (<span class="i">parameters</span>.<span class="i">size</span>() &gt;= <span class="n">255</span>) {
          <span class="i">error</span>(<span class="i">peek</span>(), <span class="s">&quot;Can&#39;t have more than 255 parameters.&quot;</span>);
        }

        <span class="i">parameters</span>.<span class="i">add</span>(
            <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">&quot;Expect parameter name.&quot;</span>));
      } <span class="k">while</span> (<span class="i">match</span>(<span class="i">COMMA</span>));
    }
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after parameters.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>function</em>()</div>

<p>This is like the code for handling arguments in a call, except not split out
into a helper method. The outer <code>if</code> statement handles the zero parameter case,
and the inner <code>while</code> loop parses parameters as long as we find commas to
separate them. The result is the list of tokens for each parameter&rsquo;s name.
这就像在函数调用中处理参数的代码一样，只是没有拆分到一个辅助方法中。外部的<code>if</code>语句用于处理零参数的情况，内部的<code>while</code>会循环解析参数，只要能找到分隔参数的逗号。其结果是包含每个参数名称的标记列表。</p>
<p>Just like we do with arguments to function calls, we validate at parse time
that you don&rsquo;t exceed the maximum number of parameters a function is allowed to
have.
就像我们处理函数调用的参数一样，我们在解析时验证是否超过了一个函数所允许的最大参数数。</p>
<p>Finally, we parse the body and wrap it all up in a function node.
最后，我们解析函数主体，并将其封装为一个函数节点。</p>
<div class="codehilite"><pre class="insert-before">    consume(RIGHT_PAREN, &quot;Expect ')' after parameters.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>function</em>()</div>
<pre class="insert">

    <span class="i">consume</span>(<span class="i">LEFT_BRACE</span>, <span class="s">&quot;Expect &#39;{&#39; before &quot;</span> + <span class="i">kind</span> + <span class="s">&quot; body.&quot;</span>);
    <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">body</span> = <span class="i">block</span>();
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Function</span>(<span class="i">name</span>, <span class="i">parameters</span>, <span class="i">body</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>function</em>()</div>

<p>Note that we consume the <code>{</code> at the beginning of the body here before calling
<code>block()</code>. That&rsquo;s because <code>block()</code> assumes the brace token has already been
matched. Consuming it here lets us report a more precise error message if the
<code>{</code> isn&rsquo;t found since we know it&rsquo;s in the context of a function declaration.
请注意，在调用<code>block()</code>方法之前，我们已经消费了函数体开头的<code>{</code>。这是因为<code>block()</code>方法假定大括号标记已经匹配了。在这里消费该标记可以让我们在找不到<code>{</code>的情况下报告一个更精确的错误信息，因为我们知道当前是在一个函数声明的上下文中。</p>
<h2><a href="#函数对象" id="函数对象"><small>10&#8202;.&#8202;4</small>函数对象</a></h2>
<p>We&rsquo;ve got some syntax parsed so usually we&rsquo;re ready to interpret, but first we
need to think about how to represent a Lox function in Java. We need to keep
track of the parameters so that we can bind them to argument values when the
function is called. And, of course, we need to keep the code for the body of the
function so that we can execute it.
我们已经解析了一些语法，通常我们要开始准备解释了，但是我们首先需要思考一下，在Java中如何表示一个Lox函数。我们需要跟踪形参，以便在函数被调用时可以将形参与实参值进行绑定。当然，我们也要保留函数体的代码，以便我们可以执行它。</p>
<p>That&rsquo;s basically what the Stmt.Function class is. Could we just use that?
Almost, but not quite. We also need a class that implements LoxCallable so that
we can call it. We don&rsquo;t want the runtime phase of the interpreter to bleed into
the front end&rsquo;s syntax classes so we don&rsquo;t want Stmt.Function itself to
implement that. Instead, we wrap it in a new class.
这基本上就是Stmt.Function的内容。我们可以用这个吗？差不多，但还不够。我们还需要一个实现LoxCallable的类，以便我们可以调用它。我们不希望解释器的运行时阶段渗入到前端语法类中，所以我们不希望使用Stmt.Function本身来实现它。相反，我们将它包装在一个新类中。</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.List</span>;

<span class="k">class</span> <span class="t">LoxFunction</span> <span class="k">implements</span> <span class="t">LoxCallable</span> {
  <span class="k">private</span> <span class="k">final</span> <span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">declaration</span>;
  <span class="t">LoxFunction</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">declaration</span>) {
    <span class="k">this</span>.<span class="i">declaration</span> = <span class="i">declaration</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, create new file</div>

<p>We implement the <code>call()</code> of LoxCallable like so:
使用如下方式实现LoxCallable的<code>call()</code>方法：</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
add after <em>LoxFunction</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">call</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>,
                     <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span>) {
    <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>(<span class="i">interpreter</span>.<span class="i">globals</span>);
    <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">declaration</span>.<span class="i">params</span>.<span class="i">size</span>(); <span class="i">i</span>++) {
      <span class="i">environment</span>.<span class="i">define</span>(<span class="i">declaration</span>.<span class="i">params</span>.<span class="i">get</span>(<span class="i">i</span>).<span class="i">lexeme</span>,
          <span class="i">arguments</span>.<span class="i">get</span>(<span class="i">i</span>));
    }

    <span class="i">interpreter</span>.<span class="i">executeBlock</span>(<span class="i">declaration</span>.<span class="i">body</span>, <span class="i">environment</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, add after <em>LoxFunction</em>()</div>

<p>This handful of lines of code is one of the most fundamental, powerful pieces of
our interpreter. As we saw in <a href="statements-and-state.html">the chapter on statements and <span
name="env">state</span></a>, managing name environments is a core part
of a language implementation. Functions are deeply tied to that.</p>
<aside name="env">
<p>We&rsquo;ll dig even deeper into environments in the <a href="resolving-and-binding.html">next chapter</a>.
我们将在<a href="resolving-and-binding.html">下一章</a>中更深入地探讨环境问题。</p>
</aside>
<p>Parameters are core to functions, especially the fact that a function
<em>encapsulates</em> its parameters<span class="em">&mdash;</span>no other code outside of the function can see
them. This means each function gets its own environment where it stores those
variables.
参数是函数的核心，尤其是考虑到函数<em>封装</em>了其参数——函数之外的代码看不到这些参数。这意味着每个函数都会维护自己的环境，其中存储着那些变量。</p>
<p>Further, this environment must be created dynamically. Each function <em>call</em> gets
its own environment. Otherwise, recursion would break. If there are multiple
calls to the same function in play at the same time, each needs its <em>own</em>
environment, even though they are all calls to the same function.
此外，这个环境必须是动态创建的。每次函数<em>调用</em>都会获得自己的环境，否则，递归就会中断。如果在同一时刻对相同的函数有多次调用，那么每个调用都需要自身的环境，即便它们都是对相同函数的调用。</p>
<p>For example, here&rsquo;s a convoluted way to count to three:
举例来说，下面是一个计数到3的复杂方法：</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">count</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> &gt; <span class="n">1</span>) <span class="i">count</span>(<span class="i">n</span> - <span class="n">1</span>);
  <span class="k">print</span> <span class="i">n</span>;
}

<span class="i">count</span>(<span class="n">3</span>);
</pre></div>
<p>Imagine we pause the interpreter right at the point where it&rsquo;s about to print 1
in the innermost nested call. The outer calls to print 2 and 3 haven&rsquo;t printed
their values yet, so there must be environments somewhere in memory that still
store the fact that <code>n</code> is bound to 3 in one context, 2 in another, and 1 in the
innermost, like:
假设一下，如果我们在最内层的嵌套调用中即将打印1的时候暂停了解释器。打印2和3的外部调用还没有打印出它们的值，所以在内存的某个地方一定有环境仍然存储着这样的数据：n在一个上下文中被绑定到3，在另一个上下文中被绑定到2，而在最内层调用中绑定为1，比如：</p><img src="image/functions/recursion.png" alt="A separate environment for each recursive call." />
<p>That&rsquo;s why we create a new environment at each <em>call</em>, not at the function
<em>declaration</em>. The <code>call()</code> method we saw earlier does that. At the beginning of
the call, it creates a new environment. Then it walks the parameter and argument
lists in lockstep. For each pair, it creates a new variable with the parameter&rsquo;s
name and binds it to the argument&rsquo;s value.
这就是为什么我们在每次<em>调用</em>时创建一个新的环境，而不是在函数声明时创建。我们前面看到的<code>call()</code>方法就是这样做的。在调用开始的时候，它创建了一个新环境。然后它以同步的方式遍历形参和实参列表。对于每一对参数，它用形参的名字创建一个新的变量，并将其与实参的值绑定。</p>
<p>So, for a program like this:
所以，对于类似下面这样的代码：</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">add</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span> + <span class="i">c</span>;
}

<span class="i">add</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="n">3</span>);
</pre></div>
<p>At the point of the call to <code>add()</code>, the interpreter creates something like
this:
在调用<code>add()</code>时，解释器会创建类似下面这样的内容：</p><img src="image/functions/binding.png" alt="Binding arguments to their parameters." />
<p>Then <code>call()</code> tells the interpreter to execute the body of the function in this
new function-local environment. Up until now, the current environment was the
environment where the function was being called. Now, we teleport from there
inside the new parameter space we&rsquo;ve created for the function.
然后<code>call()</code>会告诉解释器在这个新的函数局部环境中执行函数体。在此之前，当前环境是函数被调用的位置所处的环境。现在，我们转入了为函数创建的新的参数空间中。</p>
<p>This is all that&rsquo;s required to pass data into the function. By using different
environments when we execute the body, calls to the same function with the
same code can produce different results.
这就是将数据传入函数所需的全部内容。通过在执行函数主体时使用不同的环境，用同样的代码调用相同的函数可以产生不同的结果。</p>
<p>Once the body of the function has finished executing, <code>executeBlock()</code> discards
that function-local environment and restores the previous one that was active
back at the callsite. Finally, <code>call()</code> returns <code>null</code>, which returns <code>nil</code> to
the caller. (We&rsquo;ll add return values later.)
一旦函数的主体执行完毕，<code>executeBlock()</code>就会丢弃该函数的本地环境，并恢复调用该函数前的活跃环境。最后，<code>call()</code>方法会返回<code>null</code>，它向调用者返回<code>nil</code>。（我们会在稍后添加返回值）</p>
<p>Mechanically, the code is pretty simple. Walk a couple of lists. Bind some new
variables. Call a method. But this is where the crystalline <em>code</em> of the
function declaration becomes a living, breathing <em>invocation</em>. This is one of my
favorite snippets in this entire book. Feel free to take a moment to meditate on
it if you&rsquo;re so inclined.
从机制上讲，这段代码是非常简单的。遍历几个列表，绑定一些新变量，调用一个方法。但这就是将代码块变成有生命力的调用执行的地方。这是我在整本书中最喜欢的片段之一。如果你愿意的话，可以花点时间好好思考一下。</p>
<p>Done? OK. Note when we bind the parameters, we assume the parameter and argument
lists have the same length. This is safe because <code>visitCallExpr()</code> checks the
arity before calling <code>call()</code>. It relies on the function reporting its arity to
do that.
完成了吗？好的。注意当我们绑定参数时，我们假设参数和参数列表具有相同的长度。这是安全的，因为<code>visitCallExpr()</code>在调用<code>call()</code>之前会检查元数。它依靠报告其元数的函数来做到这一点。</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
add after <em>LoxFunction</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">int</span> <span class="i">arity</span>() {
    <span class="k">return</span> <span class="i">declaration</span>.<span class="i">params</span>.<span class="i">size</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, add after <em>LoxFunction</em>()</div>

<p>That&rsquo;s most of our object representation. While we&rsquo;re in here, we may as well
implement <code>toString()</code>.
这基本就是我们的函数对象表示了。既然已经到了这一步，我们也可以实现toString()。</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
add after <em>LoxFunction</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">toString</span>() {
    <span class="k">return</span> <span class="s">&quot;&lt;fn &quot;</span> + <span class="i">declaration</span>.<span class="i">name</span>.<span class="i">lexeme</span> + <span class="s">&quot;&gt;&quot;</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, add after <em>LoxFunction</em>()</div>

<p>This gives nicer output if a user decides to print a function value.
如果用户要打印函数的值，该方法能提供一个更漂亮的输出值。</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">add</span>(<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span>;
}

<span class="k">print</span> <span class="i">add</span>; <span class="c">// &quot;&lt;fn add&gt;&quot;.</span>
</pre></div>
<h3><a href="#解释函数声明" id="解释函数声明"><small>10&#8202;.&#8202;4&#8202;.&#8202;1</small>解释函数声明</a></h3>
<p>We&rsquo;ll come back and refine LoxFunction soon, but that&rsquo;s enough to get started.
Now we can visit a function declaration.
我们很快就会回头来完善LoxFunction，但是现在已足够开始进行解释了。现在，我们可以访问函数声明节点了。</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitExpressionStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitFunctionStmt</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">stmt</span>) {
    <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">stmt</span>);
    <span class="i">environment</span>.<span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">function</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitExpressionStmt</em>()</div>

<p>This is similar to how we interpret other literal expressions. We take a
function <em>syntax node</em><span class="em">&mdash;</span>a compile-time representation of the function<span class="em">&mdash;</span>and
convert it to its runtime representation. Here, that&rsquo;s a LoxFunction that wraps
the syntax node.
这类似于我们介绍其它文本表达式的方式。我们会接收一个函数<em>语法</em>节点——函数的编译时表示形式——然后将其转换为运行时表示形式。在这里就是一个封装了语法节点的LoxFunction实例。</p>
<p>Function declarations are different from other literal nodes in that the
declaration <em>also</em> binds the resulting object to a new variable. So, after
creating the LoxFunction, we create a new binding in the current environment and
store a reference to it there.
函数声明与其它文本节点的不同之处在于，声明还会将结果对象绑定到一个新的变量。因此，在创建LoxFunction之后，我们在当前环境中创建一个新的绑定，并在其中保存对该函数的引用。</p>
<p>With that, we can define and call our own functions all within Lox. Give it a
try:
这样，我们就可以在Lox中定义和调用我们自己的函数。试一下：</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">sayHi</span>(<span class="i">first</span>, <span class="i">last</span>) {
  <span class="k">print</span> <span class="s">&quot;Hi, &quot;</span> + <span class="i">first</span> + <span class="s">&quot; &quot;</span> + <span class="i">last</span> + <span class="s">&quot;!&quot;</span>;
}

<span class="i">sayHi</span>(<span class="s">&quot;Dear&quot;</span>, <span class="s">&quot;Reader&quot;</span>);
</pre></div>
<p>I don&rsquo;t know about you, but that looks like an honest-to-God programming
language to me.
我不知道你怎么想的，但对我来说，这看起来像是一种虔诚的编程语言。</p>
<h2><a href="#return语句" id="return语句"><small>10&#8202;.&#8202;5</small>Return语句</a></h2>
<p>We can get data into functions by passing parameters, but we&rsquo;ve got no way to
get results back <span name="hotel"><em>out</em></span>. If Lox were an
expression-oriented language like Ruby or Scheme, the body would be an
expression whose value is implicitly the function&rsquo;s result. But in Lox, the body
of a function is a list of statements which don&rsquo;t produce values, so we need
dedicated syntax for emitting a result. In other words, <code>return</code> statements. I&rsquo;m
sure you can guess the grammar already.
我们可以通过传递参数将数据输入函数中，但是我们没有办法将结果<em>传出来</em>。如果Lox是像Ruby或Scheme那样的面向表达式的语言，那么函数体就是一个表达式，其值就隐式地作为函数的结果。但是在Lox中，函数体是一个不产生值的语句列表，所有我们需要专门的语句来发出结果。换句话说，就是<code>return</code>语句。我相信你已经能猜出语法了。</p>
<aside name="hotel">
<p>The Hotel California of data.
数据的加利福尼亚酒店</p>
</aside>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">returnStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">returnStmt</span>     → <span class="s">&quot;return&quot;</span> <span class="i">expression</span>? <span class="s">&quot;;&quot;</span> ;
</pre></div>
<p>We&rsquo;ve got one more<span class="em">&mdash;</span>the final, in fact<span class="em">&mdash;</span>production under the venerable
<code>statement</code> rule. A <code>return</code> statement is the <code>return</code> keyword followed by an
optional expression and terminated with a semicolon.
我们又得到一个<code>statement</code>规则下的新产生式（实际上也是最后一个）。一个<code>return</code>语句就是一个<code>return</code>关键字，后跟一个可选的表达式，并以一个分号结尾。</p>
<p>The return value is optional to support exiting early from a function that
doesn&rsquo;t return a useful value. In statically typed languages, &ldquo;void&rdquo; functions
don&rsquo;t return a value and non-void ones do. Since Lox is dynamically typed, there
are no true void functions. The compiler has no way of preventing you from
taking the result value of a call to a function that doesn&rsquo;t contain a <code>return</code>
statement.
返回值是可选的，用以支持从一个不返回有效值的函数中提前退出。在静态类型语言中，void函数不返回值，而非void函数返回值。由于Lox是动态类型的，所以没有真正的void函数。在调用一个不包含<code>return</code>语句的函数时，编译器没有办法阻止你获取其结果值。</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">procedure</span>() {
  <span class="k">print</span> <span class="s">&quot;don&#39;t return anything&quot;</span>;
}

<span class="k">var</span> <span class="i">result</span> = <span class="i">procedure</span>();
<span class="k">print</span> <span class="i">result</span>; <span class="c">// ?</span>
</pre></div>
<p>This means every Lox function must return <em>something</em>, even if it contains no
<code>return</code> statements at all. We use <code>nil</code> for this, which is why LoxFunction&rsquo;s
implementation of <code>call()</code> returns <code>null</code> at the end. In that same vein, if you
omit the value in a <code>return</code> statement, we simply treat it as equivalent to:
这意味着每个Lox函数都要返回一些内容，即使其中根本不包含<code>return</code>语句。我们使用<code>nil</code>，这就是为什么LoxFunction的<code>call()</code>实现在最后返回<code>null</code>。同样，如果你省略了<code>return</code>语句中的值，我们将其视为等价于：</p>
<div class="codehilite"><pre><span class="k">return</span> <span class="k">nil</span>;
</pre></div>
<p>Over in our AST generator, we add a <span name="return-ast">new node</span>.
在AST生成器中，添加一个新节点。</p>
<div class="codehilite"><pre class="insert-before">      &quot;Print      : Expr expression&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Return     : Token keyword, Expr value&quot;</span>,
</pre><pre class="insert-after">      &quot;Var        : Token name, Expr initializer&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="return-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#return-statement">Appendix II</a>.
新节点的生成代码在<a href="appendix-ii.html#return-statement">附录 II</a>。</p>
</aside>
<p>It keeps the <code>return</code> keyword token so we can use its location for error
reporting, and the value being returned, if any. We parse it like other
statements, first by recognizing the initial keyword.
其中保留了<code>return</code>关键字标记（这样我们可以使用该标记的位置来报告错误），以及返回的值（如果有的话）。我们像解析其它语句一样来解析它，首先识别起始的关键字。</p>
<div class="codehilite"><pre class="insert-before">    if (match(PRINT)) return printStatement();
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">RETURN</span>)) <span class="k">return</span> <span class="i">returnStatement</span>();
</pre><pre class="insert-after">    if (match(WHILE)) return whileStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>That branches out to:
分支会跳转到：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>printStatement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">returnStatement</span>() {
    <span class="t">Token</span> <span class="i">keyword</span> = <span class="i">previous</span>();
    <span class="t">Expr</span> <span class="i">value</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">value</span> = <span class="i">expression</span>();
    }

    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after return value.&quot;</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Return</span>(<span class="i">keyword</span>, <span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>printStatement</em>()</div>

<p>After snagging the previously consumed <code>return</code> keyword, we look for a value
expression. Since many different tokens can potentially start an expression,
it&rsquo;s hard to tell if a return value is <em>present</em>. Instead, we check if it&rsquo;s
<em>absent</em>. Since a semicolon can&rsquo;t begin an expression, if the next token is
that, we know there must not be a value.
在捕获先前消耗的<code>return</code>关键字之后，我们会寻找一个值表达式。因为很多不同的标记都可以引出一个表达式，所以很难判断是否存在返回值。相反，我们检查它是否不存在。因为分号不能作为表达式的开始，如果下一个标记是分号，我们就知道一定没有返回值。</p>
<h3><a href="#从函数调用中返回" id="从函数调用中返回"><small>10&#8202;.&#8202;5&#8202;.&#8202;1</small>从函数调用中返回</a></h3>
<p>Interpreting a <code>return</code> statement is tricky. You can return from anywhere within
the body of a function, even deeply nested inside other statements. When the
return is executed, the interpreter needs to jump all the way out of whatever
context it&rsquo;s currently in and cause the function call to complete, like some
kind of jacked up control flow construct.
解释<code>return</code>语句是很棘手的。你可以从函数体中的任何位置返回，甚至是深深嵌套在其它语句中的位置。当返回语句被执行时，解释器需要完全跳出当前所在的上下文，完成函数调用，就像某种顶层的控制流结构。</p>
<p>For example, say we&rsquo;re running this program and we&rsquo;re about to execute the
<code>return</code> statement:
举例来说，假设我们正在运行下面的代码，并且我们即将执行<code>return</code>语句：</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">count</span>(<span class="i">n</span>) {
  <span class="k">while</span> (<span class="i">n</span> &lt; <span class="n">100</span>) {
    <span class="k">if</span> (<span class="i">n</span> == <span class="n">3</span>) <span class="k">return</span> <span class="i">n</span>; <span class="c">// &lt;--</span>
    <span class="k">print</span> <span class="i">n</span>;
    <span class="i">n</span> = <span class="i">n</span> + <span class="n">1</span>;
  }
}

<span class="i">count</span>(<span class="n">1</span>);
</pre></div>
<p>The Java call stack currently looks roughly like this:
Java调用栈目前看起来大致如下所示：</p>
<div class="codehilite"><pre>Interpreter.visitReturnStmt()
Interpreter.visitIfStmt()
Interpreter.executeBlock()
Interpreter.visitBlockStmt()
Interpreter.visitWhileStmt()
Interpreter.executeBlock()
LoxFunction.call()
Interpreter.visitCallExpr()
</pre></div>
<p>We need to get from the top of the stack all the way back to <code>call()</code>. I don&rsquo;t
know about you, but to me that sounds like exceptions. When we execute a
<code>return</code> statement, we&rsquo;ll use an exception to unwind the interpreter past the
visit methods of all of the containing statements back to the code that began
executing the body.
我们需要从栈顶一直回退到<code>call()</code>。我不知道你怎么想，但是对我来说，这听起来很像是异常。当我们执行<code>return</code>语句时，我们会使用一个异常来解开解释器，经过所有函数内含语句的visit方法，一直回退到开始执行函数体的代码。</p>
<p>The visit method for our new AST node looks like this:
新的AST节点的visit方法如下所示：</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitPrintStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitReturnStmt</span>(<span class="t">Stmt</span>.<span class="t">Return</span> <span class="i">stmt</span>) {
    <span class="t">Object</span> <span class="i">value</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">value</span> != <span class="k">null</span>) <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">value</span>);

    <span class="k">throw</span> <span class="k">new</span> <span class="t">Return</span>(<span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitPrintStmt</em>()</div>

<p>If we have a return value, we evaluate it, otherwise, we use <code>nil</code>. Then we take
that value and wrap it in a custom exception class and throw it.
如果我们有返回值，就对其求值，否则就使用<code>nil</code>。然后我们取这个值并将其封装在一个自定义的异常类中，并抛出该异常。</p>
<div class="codehilite"><div class="source-file"><em>lox/Return.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">class</span> <span class="t">Return</span> <span class="k">extends</span> <span class="t">RuntimeException</span> {
  <span class="k">final</span> <span class="t">Object</span> <span class="i">value</span>;

  <span class="t">Return</span>(<span class="t">Object</span> <span class="i">value</span>) {
    <span class="k">super</span>(<span class="k">null</span>, <span class="k">null</span>, <span class="k">false</span>, <span class="k">false</span>);
    <span class="k">this</span>.<span class="i">value</span> = <span class="i">value</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/Return.java</em>, create new file</div>

<p>This class wraps the return value with the accoutrements Java requires for a
runtime exception class. The weird super constructor call with those <code>null</code> and
<code>false</code> arguments disables some JVM machinery that we don&rsquo;t need. Since we&rsquo;re
using our exception class for <span name="exception">control flow</span> and not
actual error handling, we don&rsquo;t need overhead like stack traces.
这个类使用Java运行时异常类来封装返回值。其中那个奇怪的带有<code>null</code>和<code>false</code>的父类构造器方法，禁用了一些我们不需要的JVM机制。因为我们只是使用该异常类来控制流，而不是真正的错误处理，所以我们不需要像堆栈跟踪这样的开销。</p>
<aside name="exception">
<p>For the record, I&rsquo;m not generally a fan of using exceptions for control flow.
But inside a heavily recursive tree-walk interpreter, it&rsquo;s the way to go. Since
our own syntax tree evaluation is so heavily tied to the Java call stack, we&rsquo;re
pressed to do some heavyweight call stack manipulation occasionally, and
exceptions are a handy tool for that.
郑重声明，我一般不喜欢在控制流中使用异常。但在重度递归的树形漫步解释器中，使用异常却是个不错的选择。由于我们自己的语法树评估与 Java 调用堆栈紧密相连，因此我们不得不偶尔进行一些重量级的调用堆栈操作，而异常就是一个方便的工具。</p>
</aside>
<p>We want this to unwind all the way to where the function call began, the
<code>call()</code> method in LoxFunction.
我们希望可以一直跳出到函数调用开始的地方，也就是LoxFunction中的<code>call()</code>方法。</p>
<div class="codehilite"><pre class="insert-before">          arguments.get(i));
    }

</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in <em>call</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">try</span> {
      <span class="i">interpreter</span>.<span class="i">executeBlock</span>(<span class="i">declaration</span>.<span class="i">body</span>, <span class="i">environment</span>);
    } <span class="k">catch</span> (<span class="t">Return</span> <span class="i">returnValue</span>) {
      <span class="k">return</span> <span class="i">returnValue</span>.<span class="i">value</span>;
    }
</pre><pre class="insert-after">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>call</em>(), replace 1 line</div>

<p>We wrap the call to <code>executeBlock()</code> in a try-catch block. When it catches a
return exception, it pulls out the value and makes that the return value from
<code>call()</code>. If it never catches one of these exceptions, it means the function
reached the end of its body without hitting a <code>return</code> statement. In that case,
it implicitly returns <code>nil</code>.
我们将对<code>executeBlock()</code>的调用封装在一个try-catch块中。当捕获一个返回异常时，它会取出其中的值并将其作为<code>call()</code>方法的返回值。如果没有捕获任何异常，意味着函数到达了函数体的末尾，而且没有遇到<code>return</code>语句。在这种情况下，隐式地返回<code>nil</code>。</p>
<p>Let&rsquo;s try it out. We finally have enough power to support this classic
example<span class="em">&mdash;</span>a recursive function to calculate Fibonacci numbers:
我们来试一下。我们终于有能力支持这个经典的例子——递归函数计算Fibonacci数：</p>
<p><span name="slow"></span></p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">fib</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> &lt;= <span class="n">1</span>) <span class="k">return</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">fib</span>(<span class="i">n</span> - <span class="n">2</span>) + <span class="i">fib</span>(<span class="i">n</span> - <span class="n">1</span>);
}

<span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="n">20</span>; <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>) {
  <span class="k">print</span> <span class="i">fib</span>(<span class="i">i</span>);
}
</pre></div>
<p>This tiny program exercises almost every language feature we have spent the past
several chapters implementing<span class="em">&mdash;</span>expressions, arithmetic, branching, looping,
variables, functions, function calls, parameter binding, and returns.
这个小程序练习了我们在过去几章中实现的几乎所有语言特性，包括表达式、算术运算、分支、循环、变量、函数、函数调用、参数绑定和返回。</p>
<aside name="slow">
<p>You might notice this is pretty slow. Obviously, recursion isn&rsquo;t the most
efficient way to calculate Fibonacci numbers, but as a microbenchmark, it does
a good job of stress testing how fast our interpreter implements function calls.
你可能会注意到这是很慢的。显然，递归并不是计算斐波那契数的最有效方法，但作为一个微基准测试，它很好地测试了我们的解释器实现函数调用的速度。</p>
<p>As you can see, the answer is &ldquo;not very fast&rdquo;. That&rsquo;s OK. Our C interpreter will
be faster.
如您所见，答案是 &ldquo;不快&ldquo;。没关系。我们的 C 语言解释器会更快。</p>
</aside>
<h2><a href="#局部函数和闭包" id="局部函数和闭包"><small>10&#8202;.&#8202;6</small>局部函数和闭包</a></h2>
<p>Our functions are pretty full featured, but there is one hole to patch. In fact,
it&rsquo;s a big enough gap that we&rsquo;ll spend most of the <a href="resolving-and-binding.html">next chapter</a> sealing it
up, but we can get started here.
我们的函数功能已经相当全面了，但是还有一个漏洞需要修补。实际上，这是一个很大的问题，我们将会在下一章中花费大部分时间来修补它，但是我们可以从这里开始。</p>
<p>LoxFunction&rsquo;s implementation of <code>call()</code> creates a new environment where it
binds the function&rsquo;s parameters. When I showed you that code, I glossed over one
important point: What is the <em>parent</em> of that environment?
LoxFunction中的<code>call()</code>实现创建了一个新的环境，并在其中绑定了函数的参数。当我向你展示这段代码时，我忽略了一个重要的问题：这个环境的父类是什么？</p>
<p>Right now, it is always <code>globals</code>, the top-level global environment. That way,
if an identifier isn&rsquo;t defined inside the function body itself, the interpreter
can look outside the function in the global scope to find it. In the Fibonacci
example, that&rsquo;s how the interpreter is able to look up the recursive call to
<code>fib</code> inside the function&rsquo;s own body<span class="em">&mdash;</span><code>fib</code> is a global variable.
目前，它始终是<code>globals</code>，即顶级的全局环境。这样，如果一个标识符不是在函数体内部定义的，解释器可以在函数外部的全局作用域中查找它。在Fibonacci的例子中，这就是解释器如何能够在函数体中实现对<code>fib</code>的递归调用——<code>fib</code>是一个全局变量。</p>
<p>But recall that in Lox, function declarations are allowed <em>anywhere</em> a name can
be bound. That includes the top level of a Lox script, but also the inside of
blocks or other functions. Lox supports <strong>local functions</strong> that are defined
inside another function, or nested inside a block.
但请记住，在Lox中，允许在可以绑定名字的<em>任何地方</em>进行函数声明。其中包括Lox脚本的顶层，但也包括块或其他函数的内部。Lox支持在另一个函数内定义或在一个块内嵌套的<strong>局部函数</strong>。</p>
<p>Consider this classic example:
考虑下面这个经典的例子：</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">makeCounter</span>() {
  <span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>;
  <span class="k">fun</span> <span class="i">count</span>() {
    <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>;
    <span class="k">print</span> <span class="i">i</span>;
  }

  <span class="k">return</span> <span class="i">count</span>;
}

<span class="k">var</span> <span class="i">counter</span> = <span class="i">makeCounter</span>();
<span class="i">counter</span>(); <span class="c">// &quot;1&quot;.</span>
<span class="i">counter</span>(); <span class="c">// &quot;2&quot;.</span>
</pre></div>
<p>Here, <code>count()</code> uses <code>i</code>, which is declared outside of itself in the containing
function <code>makeCounter()</code>. <code>makeCounter()</code> returns a reference to the <code>count()</code>
function and then its own body finishes executing completely.
这个例子中，<code>count()</code>使用了<code>i</code>，它是在该函数外部的 <code>makeCounter()</code>声明的。<code>makeCounter()</code> 返回对<code>count()</code>函数的引用，然后它的函数体就执行完成了。</p>
<p>Meanwhile, the top-level code invokes the returned <code>count()</code> function. That
executes the body of <code>count()</code>, which assigns to and reads <code>i</code>, even though the
function where <code>i</code> was defined has already exited.
同时，顶层代码调用了返回的<code>count()</code>函数。这就执行了<code>count()</code>函数的主体，它会对<code>i</code>赋值并读取<code>i</code>，尽管定义<code>i</code>的函数已经退出。</p>
<p>If you&rsquo;ve never encountered a language with nested functions before, this might
seem crazy, but users do expect it to work. Alas, if you run it now, you get an
undefined variable error in the call to <code>counter()</code> when the body of <code>count()</code>
tries to look up <code>i</code>. That&rsquo;s because the environment chain in effect looks like
this:
如果你以前从未遇到过带有嵌套函数的语言，那么这可能看起来很疯狂，但用户确实希望它能工作。唉，如果你现在运行它，当<code>count()</code>的函数体试图查找<code>i</code>时，会在对<code>counter()</code>的调用中得到一个未定义的变量错误，这是因为当前的环境链看起来像是这样的：</p><img src="image/functions/global.png" alt="The environment chain from count()'s body to the global scope." />
<p>When we call <code>count()</code> (through the reference to it stored in <code>counter</code>), we
create a new empty environment for the function body. The parent of that is the
global environment. We lost the environment for <code>makeCounter()</code> where <code>i</code> is
bound.
当我们调用<code>count()</code>时（通过<code>counter</code>中保存的引用），我们会为函数体创建一个新的空环境，它的父环境就是全局环境。我们丢失了<code>i</code>所在的<code>makeCounter()</code>环境。</p>
<p>Let&rsquo;s go back in time a bit. Here&rsquo;s what the environment chain looked like right
when we declared <code>count()</code> inside the body of <code>makeCounter()</code>:
我们把时间往回拨一点。我们在<code>makeCounter()</code>的函数体中声明<code>count()</code>时，环境链的样子是下面这样：</p><img src="image/functions/body.png" alt="The environment chain inside the body of makeCounter()." />
<p>So at the point where the function is declared, we can see <code>i</code>. But when we
return from <code>makeCounter()</code> and exit its body, the interpreter discards that
environment. Since the interpreter doesn&rsquo;t keep the environment surrounding
<code>count()</code> around, it&rsquo;s up to the function object itself to hang on to it.
所以，在函数声明的地方，我们可以看到<code>i</code>。但是当我们从 <code>makeCounter()</code> 返回并退出其主体时，解释器会丢弃这个环境。因为解释器不会保留<code>count()</code> 外围的环境，所以要靠函数对象本身来保存它。</p>
<p>This data structure is called a <span name="closure"><strong>closure</strong></span> because
it &ldquo;closes over&rdquo; and holds on to the surrounding variables where the function is
declared. Closures have been around since the early Lisp days, and language
hackers have come up with all manner of ways to implement them. For jlox, we&rsquo;ll
do the simplest thing that works. In LoxFunction, we add a field to store an
environment.
这种数据结构被称为<strong>闭包</strong>，因为它 &ldquo;封闭&rdquo; 并保留着函数声明的外围变量。闭包早在Lisp时代就已经存在了，语言黑客们想出了各种方法来实现闭包。在jlox中，我们将采用最简单的方式。在LoxFunction中，我们添加一个字段来存储环境。</p>
<aside name="closure">
<p>&ldquo;Closure&rdquo; is yet another term coined by Peter J. Landin. I assume before he came
along that computer scientists communicated with each other using only primitive
grunts and pawing hand gestures.
&ldquo;闭包&ldquo;(Closure) 是 Peter J. Landin 创造的又一个术语。我想，在他出现之前，计算机科学家之间只能用原始的咕哝声和比划手势进行交流。</p>
</aside>
<div class="codehilite"><pre class="insert-before">  private final Stmt.Function declaration;
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in class <em>LoxFunction</em></div>
<pre class="insert">  <span class="k">private</span> <span class="k">final</span> <span class="t">Environment</span> <span class="i">closure</span>;

</pre><pre class="insert-after">  LoxFunction(Stmt.Function declaration) {
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in class <em>LoxFunction</em></div>

<p>We initialize that in the constructor.
我们在构造函数中对其初始化。</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
constructor <em>LoxFunction</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">LoxFunction</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">declaration</span>, <span class="t">Environment</span> <span class="i">closure</span>) {
    <span class="k">this</span>.<span class="i">closure</span> = <span class="i">closure</span>;
</pre><pre class="insert-after">    this.declaration = declaration;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, constructor <em>LoxFunction</em>(), replace 1 line</div>

<p>When we create a LoxFunction, we capture the current environment.
当我们创建LoxFunction时，我们会捕获当前环境。</p>
<div class="codehilite"><pre class="insert-before">  public Void visitFunctionStmt(Stmt.Function stmt) {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitFunctionStmt</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">stmt</span>, <span class="i">environment</span>);
</pre><pre class="insert-after">    environment.define(stmt.name.lexeme, function);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitFunctionStmt</em>(), replace 1 line</div>

<p>This is the environment that is active when the function is <em>declared</em> not when
it&rsquo;s <em>called</em>, which is what we want. It represents the lexical scope
surrounding the function declaration. Finally, when we call the function, we use
that environment as the call&rsquo;s parent instead of going straight to <code>globals</code>.
这是函数声明时生效的环境，而不是函数被调用时的环境，这正是我们想要的。它代表了函数声明时的词法作用域。最后，当我们调用函数时，我们使用该环境作为调用的父环境，而不是直接使用<code>globals</code>。</p>
<div class="codehilite"><pre class="insert-before">                     List&lt;Object&gt; arguments) {
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in <em>call</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>(<span class="i">closure</span>);
</pre><pre class="insert-after">    for (int i = 0; i &lt; declaration.params.size(); i++) {
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>call</em>(), replace 1 line</div>

<p>This creates an environment chain that goes from the function&rsquo;s body out through
the environments where the function is declared, all the way out to the global
scope. The runtime environment chain matches the textual nesting of the source
code like we want. The end result when we call that function looks like this:
这样就创建了一个环境链，从函数体开始，经过函数被声明的环境，然后到全局作用域。运行时环境链与源代码的文本嵌套相匹配，跟我们想要的一致。当我们调用该函数时，最终的结果是这样的：</p><img src="image/functions/closure.png" alt="The environment chain with the closure." />
<p>Now, as you can see, the interpreter can still find <code>i</code> when it needs to because
it&rsquo;s in the middle of the environment chain. Try running that <code>makeCounter()</code>
example now. It works!
如你所见，现在解释器可以在需要的时候找到<code>i</code>，因为它在环境链中。现在尝试运行makeCounter()的例子，起作用了！</p>
<p>Functions let us abstract over, reuse, and compose code. Lox is much more
powerful than the rudimentary arithmetic calculator it used to be. Alas, in our
rush to cram closures in, we have let a tiny bit of dynamic scoping leak into
the interpreter. In the <a href="resolving-and-binding.html">next chapter</a>, we will explore deeper into lexical
scope and close that hole.
函数让我们对代码进行抽象、重用和编排。Lox比之前的初级算术计算器要强大得多。唉，在我们匆匆忙忙支持闭包时，已经让一小部分动态作用域泄露到解释器中了。在<a href="resolving-and-binding.html">下一章</a>中，我们将深入探索词法作用域，堵住这个漏洞。</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Our interpreter carefully checks that the number of arguments passed to a
function matches the number of parameters it expects. Since this check is
done at runtime on every call, it has a performance cost. Smalltalk
implementations don&rsquo;t have that problem. Why not?
1、解释器会仔细检查传给函数的实参数量是否与期望的形参数量匹配。由于该检查是在运行时，针对每一次调用执行的，所以会有性能成本。Smalltalk的实现则没有这个问题。为什么呢？</p>
</li>
<li>
<p>Lox&rsquo;s function declaration syntax performs two independent operations. It
creates a function and also binds it to a name. This improves usability for
the common case where you do want to associate a name with the function.
But in functional-styled code, you often want to create a function to
immediately pass it to some other function or return it. In that case, it
doesn&rsquo;t need a name.</p>
<p>Languages that encourage a functional style usually support <strong>anonymous
functions</strong> or <strong>lambdas</strong><span class="em">&mdash;</span>an expression syntax that creates a function
without binding it to a name. Add anonymous function syntax to Lox so that
this works:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">thrice</span>(<span class="i">fn</span>) {
  <span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">1</span>; <span class="i">i</span> &lt;= <span class="n">3</span>; <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>) {
    <span class="i">fn</span>(<span class="i">i</span>);
  }
}

<span class="i">thrice</span>(<span class="k">fun</span> (<span class="i">a</span>) {
  <span class="k">print</span> <span class="i">a</span>;
});
<span class="c">// &quot;1&quot;.</span>
<span class="c">// &quot;2&quot;.</span>
<span class="c">// &quot;3&quot;.</span>
</pre></div>
<p>How do you handle the tricky case of an anonymous function expression
occurring in an expression statement:</p>
<div class="codehilite"><pre><span class="k">fun</span> () {};
</pre></div>
</li>
<li>
<p>Is this program valid?</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">scope</span>(<span class="i">a</span>) {
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;local&quot;</span>;
}
</pre></div>
<p>In other words, are a function&rsquo;s parameters in the <em>same</em> scope as its local
variables, or in an outer scope? What does Lox do? What about other
languages you are familiar with? What do you think a language <em>should</em> do?</p>
</li>
</ol>
</div>

    <footer>
      <a href="resolving-and-binding.html" class="next">
        下一节: &ldquo;解析和绑定&rdquo; &rarr;
      </a>
      Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a
        href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy;
        2015&hairsp;&ndash;&hairsp;2021</a>
    </footer>
  </article>

  </div>
  </body>
  </html>
