<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Local Variables &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Local Variables<small>22</small></a></h3>

<ul>
    <li><a href="#representing-local-variables--表示局部变量"><small>22.1</small> Representing Local Variables  表示局部变量</a></li>
    <li><a href="#block-statements--块语句"><small>22.2</small> Block Statements  块语句</a></li>
    <li><a href="#declaring-local-variables--声明局部变量"><small>22.3</small> Declaring Local Variables  声明局部变量</a></li>
    <li><a href="#using-locals--使用局部变量"><small>22.4</small> Using Locals  使用局部变量</a></li>
    <li><a href="#习题"><small>22.5</small> 习题</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="global-variables.html" title="Global Variables" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="global-variables.html" title="Global Variables" class="prev">←</a>
<a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Local Variables<small>22</small></a></h3>

<ul>
    <li><a href="#representing-local-variables--表示局部变量"><small>22.1</small> Representing Local Variables  表示局部变量</a></li>
    <li><a href="#block-statements--块语句"><small>22.2</small> Block Statements  块语句</a></li>
    <li><a href="#declaring-local-variables--声明局部变量"><small>22.3</small> Declaring Local Variables  声明局部变量</a></li>
    <li><a href="#using-locals--使用局部变量"><small>22.4</small> Using Locals  使用局部变量</a></li>
    <li><a href="#习题"><small>22.5</small> 习题</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="global-variables.html" title="Global Variables" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">22</div>
  <h1>Local Variables</h1>

<blockquote>
<p>And as imagination bodies forth<br />
The forms of things unknown, the poet&rsquo;s pen<br />
Turns them to shapes and gives to airy nothing<br />
A local habitation and a name.</p>
<p><cite>William Shakespeare, <em>A Midsummer Night&rsquo;s Dream</em></cite>
<em>随着想象力的不断涌现</em>
<em>未知事物的形式，诗人的笔</em>
<em>把它们变成形状，变成虚无</em>
<em>当地的居住地和名字。</em>
（威廉·莎士比亚《仲夏夜之梦》）</p>
</blockquote>
<p>The <a href="global-variables.html">last chapter</a> introduced variables to clox, but only of the <span
name="global">global</span> variety. In this chapter, we&rsquo;ll extend that to
support blocks, block scope, and local variables. In jlox, we managed to pack
all of that and globals into one chapter. For clox, that&rsquo;s two chapters worth of
work partially because, frankly, everything takes more effort in C.</p>
<aside name="global">
<p>There&rsquo;s probably some dumb &ldquo;think globally, act locally&rdquo; joke here, but I&rsquo;m
struggling to find it.</p>
</aside>
<p>But an even more important reason is that our approach to local variables will
be quite different from how we implemented globals. Global variables are late
bound in Lox. &ldquo;Late&rdquo; in this context means &ldquo;resolved after compile time&rdquo;. That&rsquo;s
good for keeping the compiler simple, but not great for performance. Local
variables are one of the most-used <span name="params">parts</span> of a
language. If locals are slow, <em>everything</em> is slow. So we want a strategy for
local variables that&rsquo;s as efficient as possible.
但更重要的原因是，我们处理局部变量的方法与我们实现全局变量的方法截然不同。全局变量在Lox中是后期绑定的。这里的“后期”是指“在编译后分析”。这有利于保持编译器的简单性，但不利于性能。局部变量是语言中最常用的部分之一。如果局部变量很慢，那么<em>一切</em>都是缓慢的。因此，对于局部变量，我们希望采取尽可能高效的策略。</p>
<aside name="params">
<p>Function parameters are also heavily used. They work like local variables too,
so we&rsquo;ll use the same implementation technique for them.</p>
</aside>
<p>Fortunately, lexical scoping is here to help us. As the name implies, lexical
scope means we can resolve a local variable just by looking at the text of the
program<span class="em">&mdash;</span>locals are <em>not</em> late bound. Any processing work we do in the
compiler is work we <em>don&rsquo;t</em> have to do at runtime, so our implementation of
local variables will lean heavily on the compiler.
幸运的是，词法作用域可以帮助我们。顾名思义，词法作用域意味着我们可以通过查看程序文本来解析局部变量——局部变量<em>不是</em>后期绑定的。我们在编译器中所做的任何处理工作都不必在运行时完成，因此局部变量的实现将在很大程度上依赖于编译器。</p>
<h2><a href="#representing-local-variables--表示局部变量" id="representing-local-variables--表示局部变量"><small>22&#8202;.&#8202;1</small>Representing Local Variables  表示局部变量</a></h2>
<p>The nice thing about hacking on a programming language in modern times is
there&rsquo;s a long lineage of other languages to learn from. So how do C and Java
manage their local variables? Why, on the stack, of course! They typically use
the native stack mechanisms supported by the chip and OS. That&rsquo;s a little too
low level for us, but inside the virtual world of clox, we have our own stack we
can use.
在现代，实现一门编程语言的好处是，可以参考已经发展了很长时间的其它语言。那么，C和Java是如何管理它们的局部变量的呢？当然是在堆栈上！它们通常使用芯片和操作系统支持的本地堆栈机制。这对我们来说有点太底层了，但是在clox的虚拟世界中，我们有自己的堆栈可以使用。</p>
<p>Right now, we only use it for holding on to <strong>temporaries</strong><span class="em">&mdash;</span>short-lived blobs
of data that we need to remember while computing an expression. As long as we
don&rsquo;t get in the way of those, we can stuff our local variables onto the stack
too. This is great for performance. Allocating space for a new local requires
only incrementing the <code>stackTop</code> pointer, and freeing is likewise a decrement.
Accessing a variable from a known stack slot is an indexed array lookup.
现在，我们只使用它来保存<strong>临时变量</strong>——我们在计算表达式时需要记住的短期数据块。只要我们不妨碍这些数据，我们也可以把局部变量塞到栈中。这对性能很有帮助。为一个新的局部变量分配空间只需要递增<code>stackTop</code>指针，而释放也同样是递减的过程。从已知的栈槽访问变量是一种索引数组的查询。</p>
<p>We do need to be careful, though. The VM expects the stack to behave like, well,
a stack. We have to be OK with allocating new locals only on the top of the
stack, and we have to accept that we can discard a local only when nothing is
above it on the stack. Also, we need to make sure temporaries don&rsquo;t interfere.
不过，我们确实需要小心。虚拟机希望栈的行为就像，嗯，一个栈。我们必须接受只能在栈顶分配新的局部变量，而且我们必须接受只有局部变量上方的栈槽没有数据时，才能丢弃该变量。此外，我们还需要保证临时变量不受干扰。</p>
<p>Conveniently, the design of Lox is in <span name="harmony">harmony</span> with
these constraints. New locals are always created by declaration statements.
Statements don&rsquo;t nest inside expressions, so there are never any temporaries on
the stack when a statement begins executing. Blocks are strictly nested. When a
block ends, it always takes the innermost, most recently declared locals with
it. Since those are also the locals that came into scope last, they should be on
top of the stack where we need them.
方便的是，Lox的设计与这些约束条件是一致的。新的局部变量总是通过声明语句创建的。语句不会嵌套在表达式内，所以当一个语句开始执行时，栈中没有任何临时变量。代码块是严格嵌套的。当一个块结束时，它总会带走最内部、最近声明的局部变量。因为这些也是最后进入作用域的局部变量，所以它们应该位于栈顶（我们期望它所在的位置）。</p>
<aside name="harmony">
<p>This alignment obviously isn&rsquo;t coincidental. I designed Lox to be amenable to
single-pass compilation to stack-based bytecode. But I didn&rsquo;t have to tweak the
language too much to fit in those restrictions. Most of its design should feel
pretty natural.</p>
<p>This is in large part because the history of languages is deeply tied to
single-pass compilation and<span class="em">&mdash;</span>to a lesser degree<span class="em">&mdash;</span>stack-based architectures.
Lox&rsquo;s block scoping follows a tradition stretching back to BCPL. As programmers,
our intuition of what&rsquo;s &ldquo;normal&rdquo; in a language is informed even today by the
hardware limitations of yesteryear.</p>
</aside>
<p>Step through this example program and watch how the local variables come in and
go out of scope:
逐步执行这段示例代码，查看局部变量是如何进入和离开作用域的：</p><img src="image/local-variables/scopes.png" alt="A series of local variables come into and out of scope in a stack-like fashion." />
<p>See how they fit a stack perfectly? It seems that the stack will work for
storing locals at runtime. But we can go further than that. Not only do we know
<em>that</em> they will be on the stack, but we can even pin down precisely <em>where</em>
they will be on the stack. Since the compiler knows exactly which local
variables are in scope at any point in time, it can effectively simulate the
stack during compilation and note <span name="fn">where</span> in the stack each
variable lives.
看到它们如何完美地适应堆栈了吗？看来，栈可以在运行时存储局部变量。但是我们可以更进一步。我们不仅知道它们会在栈上，而且我们甚至可以确定它们在栈上的精确位置。因为编译器确切地知道任何时间点上有哪些局部变量在作用域中，因此它可以在编译过程中有效地模拟堆栈，并注意每个变量在栈中的位置。</p>
<p>We&rsquo;ll take advantage of this by using these stack offsets as operands for the
bytecode instructions that read and store local variables. This makes working
with locals deliciously fast<span class="em">&mdash;</span>as simple as indexing into an array.
我们将利用这一点，对于读取和存储局部变量的字节码指令，把这些栈偏移量作为其操作数。这使得局部变量非常快——就像索引数组一样简单。</p>
<aside name="fn">
<p>In this chapter, locals start at the bottom of the VM&rsquo;s stack array and are
indexed from there. When we add <a href="calls-and-functions.html">functions</a>, that scheme gets a little more
complex. Each function needs its own region of the stack for its parameters and
local variables. But, as we&rsquo;ll see, that doesn&rsquo;t add as much complexity as you
might expect.</p>
</aside>
<p>There&rsquo;s a lot of state we need to track in the compiler to make this whole thing
go, so let&rsquo;s get started there. In jlox, we used a linked chain of &ldquo;environment&rdquo;
HashMaps to track which local variables were currently in scope. That&rsquo;s sort of
the classic, schoolbook way of representing lexical scope. For clox, as usual,
we&rsquo;re going a little closer to the metal. All of the state lives in a new
struct.
我们需要在编译器中跟踪大量状态，以使整个程序运行起来，让我们就从那里开始。在jlox中，我们使用“环境”HashMap链来跟踪当前在作用域中的局部变量。这是一种经典的、教科书式的词法作用域表示方式。对于clox，像往常一样，我们更接近于硬件。所有的状态都保存了一个新的结构体中。</p>
<div class="codehilite"><pre class="insert-before">} ParseRule;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>ParseRule</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Local</span> <span class="i">locals</span>[<span class="a">UINT8_COUNT</span>];
  <span class="t">int</span> <span class="i">localCount</span>;
  <span class="t">int</span> <span class="i">scopeDepth</span>;
} <span class="t">Compiler</span>;
</pre><pre class="insert-after">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>ParseRule</em></div>

<p>We have a simple, flat array of all locals that are in scope during each point in
the compilation process. They are <span name="order">ordered</span> in the array
in the order that their declarations appear in the code. Since the instruction
operand we&rsquo;ll use to encode a local is a single byte, our VM has a hard limit on
the number of locals that can be in scope at once. That means we can also give
the locals array a fixed size.
我们有一个简单、扁平的数组，其中包含了编译过程中每个时间点上处于作用域内的所有局部变量。它们在数组中的顺序与它们的声明在代码中出现的顺序相同。由于我们用来编码局部变量的指令操作数是一个字节，所以我们的虚拟机对同时处于作用域内的局部变量的数量有一个硬性限制。这意味着我们也可以给局部变量数组一个固定的大小。</p>
<aside name="order">
<p>We&rsquo;re writing a single-pass compiler, so it&rsquo;s not like we have <em>too</em> many other
options for how to order them in the array.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#define DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert">

<span class="a">#define UINT8_COUNT (UINT8_MAX + 1)</span>
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>Back in the Compiler struct, the <code>localCount</code> field tracks how many locals are
in scope<span class="em">&mdash;</span>how many of those array slots are in use. We also track the &ldquo;scope
depth&rdquo;. This is the number of blocks surrounding the current bit of code we&rsquo;re
compiling.
回到Compiler结构体中，<code>localCount</code>字段记录了作用域中有多少局部变量——有多少个数组槽在使用。我们还会跟踪“作用域深度”。这指的是我们正在编译的当前代码外围的代码块数量。</p>
<p>Our Java interpreter used a chain of maps to keep each block&rsquo;s variables
separate from other blocks&rsquo;. This time, we&rsquo;ll simply number variables with the
level of nesting where they appear. Zero is the global scope, one is the first
top-level block, two is inside that, you get the idea. We use this to track
which block each local belongs to so that we know which locals to discard when a
block ends.
我们的Java解释器使用了一个map链将每个块的变量与其它块分开。这一次，我们根据变量出现的嵌套级别对其进行编号。0是全局作用域，1是第一个顶层块，2是它内部的块，你懂的。我们用它来跟踪每个局部变量属于哪个块，这样当一个块结束时，我们就知道该删除哪些局部变量。</p>
<p>Each local in the array is one of these:
数组中的每个局部变量都是这样的：</p>
<div class="codehilite"><pre class="insert-before">} ParseRule;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>ParseRule</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Token</span> <span class="i">name</span>;
  <span class="t">int</span> <span class="i">depth</span>;
} <span class="t">Local</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>ParseRule</em></div>

<p>We store the name of the variable. When we&rsquo;re resolving an identifier, we
compare the identifier&rsquo;s lexeme with each local&rsquo;s name to find a match. It&rsquo;s
pretty hard to resolve a variable if you don&rsquo;t know its name. The <code>depth</code> field
records the scope depth of the block where the local variable was declared.
That&rsquo;s all the state we need for now.
我们存储变量的名称。当我们解析一个标识符时，会将标识符的词素与每个局部变量名称进行比较，以找到一个匹配项。如果你不知道变量的名称，就很难解析它。<code>depth</code>字段记录了声明局部变量的代码块的作用域深度。这就是我们现在需要的所有状态。</p>
<p>This is a very different representation from what we had in jlox, but it still
lets us answer all of the same questions our compiler needs to ask of the
lexical environment. The next step is figuring out how the compiler <em>gets</em> at
this state. If we were <span name="thread">principled</span> engineers, we&rsquo;d
give each function in the front end a parameter that accepts a pointer to a
Compiler. We&rsquo;d create a Compiler at the beginning and carefully thread it
through each function call<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>but that would mean a lot of boring changes to
the code we already wrote, so here&rsquo;s a global variable instead:
这与我们在jlox中使用的表示方式非常不同，但我们用它仍然可以回答编译器需要向词法环境提出的所有相同的问题。下一步是弄清楚编译器如何获取这个状态。如果我们是有原则的工程师，我们应该给前端的每个函数添加一个参数，接受一个指向Compiler的指针。我们在一开始就创建一个Compiler，并小心地在将它贯穿于每个函数的调用中……但这意味着要对我们已经写好的代码进行大量无聊的修改，所以这里用一个全局变量代替：</p>
<aside name="thread">
<p>In particular, if we ever want to use our compiler in a multi-threaded
application, possibly with multiple compilers running in parallel, then using a
global variable is a <em>bad</em> idea.</p>
</aside>
<div class="codehilite"><pre class="insert-before">Parser parser;
</pre><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre class="insert"><span class="t">Compiler</span>* <span class="i">current</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">Chunk* compilingChunk;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>Here&rsquo;s a little function to initialize the compiler:
下面是一个用于初始化编译器的小函数：</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">initCompiler</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>) {
  <span class="i">compiler</span>-&gt;<span class="i">localCount</span> = <span class="n">0</span>;
  <span class="i">compiler</span>-&gt;<span class="i">scopeDepth</span> = <span class="n">0</span>;
  <span class="i">current</span> = <span class="i">compiler</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitConstant</em>()</div>

<p>When we first start up the VM, we call it to get everything into a clean state.
当我们第一次启动虚拟机时，我们会调用它使所有东西进入一个干净的状态。</p>
<div class="codehilite"><pre class="insert-before">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="t">Compiler</span> <span class="i">compiler</span>;
  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>);
</pre><pre class="insert-after">  compilingChunk = chunk;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>Our compiler has the data it needs, but not the operations on that data. There&rsquo;s
no way to create and destroy scopes, or add and resolve variables. We&rsquo;ll add
those as we need them. First, let&rsquo;s start building some language features.
我们的编译器有了它需要的数据，但还没有对这些数据的操作。没有办法创建或销毁作用域，添加和解析变量。我们会在需要的时候添加这些功能。首先，让我们开始构建一些语言特性。</p>
<h2><a href="#block-statements--块语句" id="block-statements--块语句"><small>22&#8202;.&#8202;2</small>Block Statements  块语句</a></h2>
<p>Before we can have any local variables, we need some local scopes. These come
from two things: function bodies and <span name="block">blocks</span>. Functions
are a big chunk of work that we&rsquo;ll tackle in <a href="calls-and-functions.html">a later chapter</a>, so
for now we&rsquo;re only going to do blocks. As usual, we start with the syntax. The
new grammar we&rsquo;ll introduce is:
在能够使用局部变量之前，我们需要一些局部作用域。它们来自于两方面：函数体和代码块。函数是一大块工作，我们在后面的章节中处理，因此现在我们只做块。和往常一样，我们从语法开始。我们要介绍的新语法是：</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">block</span>          → <span class="s">&quot;{&quot;</span> <span class="i">declaration</span>* <span class="s">&quot;}&quot;</span> ;
</pre></div>
<aside name="block">
<p>When you think about it, &ldquo;block&rdquo; is a weird name. Used metaphorically, &ldquo;block&rdquo;
usually means a small indivisible unit, but for some reason, the Algol 60
committee decided to use it to refer to a <em>compound</em> structure<span class="em">&mdash;</span>a series of
statements. It could be worse, I suppose. Algol 58 called <code>begin</code> and <code>end</code>
&ldquo;statement parentheses&rdquo;.</p><img src="image/local-variables/block.png" alt="A cinder block." class="above" />
</aside>
<p>Blocks are a kind of statement, so the rule for them goes in the <code>statement</code>
production. The corresponding code to compile one looks like this:
块是一种语句，所以它的规则是在<code>statement</code>生成式中。对应的编译代码如下：</p>
<div class="codehilite"><pre class="insert-before">  if (match(TOKEN_PRINT)) {
    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_LEFT_BRACE</span>)) {
    <span class="i">beginScope</span>();
    <span class="i">block</span>();
    <span class="i">endScope</span>();
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>After <span name="helper">parsing</span> the initial curly brace, we use this
helper function to compile the rest of the block:
解析完开头的花括号之后，我们使用这个辅助函数来编译块的其余部分：</p>
<aside name="helper">
<p>This function will come in handy later for compiling function bodies.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">block</span>() {
  <span class="k">while</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_BRACE</span>) &amp;&amp; !<span class="i">check</span>(<span class="a">TOKEN_EOF</span>)) {
    <span class="i">declaration</span>();
  }

  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_BRACE</span>, <span class="s">&quot;Expect &#39;}&#39; after block.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>It keeps parsing declarations and statements until it hits the closing brace. As
we do with any loop in the parser, we also check for the end of the token
stream. This way, if there&rsquo;s a malformed program with a missing closing curly,
the compiler doesn&rsquo;t get stuck in a loop.
它会一直解析声明和语句，直到遇见右括号。就像我们在解析器中的所有循环一样，我们也要检查标识流是否结束。这样一来，如果有一个格式不正确的程序缺少右括号，编译器也不会卡在循环里。</p>
<p>Executing a block simply means executing the statements it contains, one after
the other, so there isn&rsquo;t much to compiling them. The semantically interesting
thing blocks do is create scopes. Before we compile the body of a block, we call
this function to enter a new local scope:
执行代码块只是意味着一个接一个地执行其中包含的语句，所以不需要编译它们。从语义上讲，块所做的事就是创建作用域。在我们编译块的主体之前，我们会调用这个函数进入一个新的局部作用域：</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">beginScope</span>() {
  <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>In order to &ldquo;create&rdquo; a scope, all we do is increment the current depth. This is
certainly much faster than jlox, which allocated an entire new HashMap for
each one. Given <code>beginScope()</code>, you can probably guess what <code>endScope()</code> does.
为了“创建”一个作用域，我们所做的就是增加当前的深度。这当然比jlox快得多，因为jlox为每个作用域分配了全新的HashMap。有了<code>beginScope()</code>，你大概能猜到<code>endScope()</code>会做什么。</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>beginScope</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">endScope</span>() {
  <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>--;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>beginScope</em>()</div>

<p>That&rsquo;s it for blocks and scopes<span class="em">&mdash;</span>more or less<span class="em">&mdash;</span>so we&rsquo;re ready to stuff some
variables into them.
这就是块和作用域的全部内容——或多或少吧——现在我们准备在其中添加一些变量。</p>
<h2><a href="#declaring-local-variables--声明局部变量" id="declaring-local-variables--声明局部变量"><small>22&#8202;.&#8202;3</small>Declaring Local Variables  声明局部变量</a></h2>
<p>Usually we start with parsing here, but our compiler already supports parsing
and compiling variable declarations. We&rsquo;ve got <code>var</code> statements, identifier
expressions and assignment in there now. It&rsquo;s just that the compiler assumes
all variables are global. So we don&rsquo;t need any new parsing support, we just need
to hook up the new scoping semantics to the existing code.
通常我们会从解析开始，但是我们的编译器已经支持了解析和编译变量声明。我们现在已经有了<code>var</code>语句、标识符表达式和赋值语句。只是编译器假设所有的变量都是全局变量。所以，我们不需要任何新的解析支持，我们只需要将新的作用域语义与已有的代码连接起来。
<img src="22.局部变量/declaration.png" alt="The code flow within varDeclaration()." /></p><img src="image/local-variables/declaration.png" alt="The code flow within varDeclaration()." />
<p>Variable declaration parsing begins in <code>varDeclaration()</code> and relies on a couple
of other functions. First, <code>parseVariable()</code> consumes the identifier token for
the variable name, adds its lexeme to the chunk&rsquo;s constant table as a string,
and then returns the constant table index where it was added. Then, after
<code>varDeclaration()</code> compiles the initializer, it calls <code>defineVariable()</code> to emit
the bytecode for storing the variable&rsquo;s value in the global variable hash table.
变量声明的解析从<code>varDeclaration()</code>开始，并依赖于其它几个函数。首先，<code>parseVariable()</code>会使用标识符标识作为变量名称，将其词素作为字符串添加到字节码块的常量表中，然后返回它的常量表索引。接着，在<code>varDeclaration()</code>编译完初始化表达式后，会调用<code>defineVariable()</code>生成字节码，将变量的值存储到全局变量哈希表中。</p>
<p>Both of those helpers need a few changes to support local variables. In
<code>parseVariable()</code>, we add:
这两个辅助函数都需要一些调整以支持局部变量。在<code>parseVariable()</code>中，我们添加：</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_IDENTIFIER, errorMessage);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parseVariable</em>()</div>
<pre class="insert">

  <span class="i">declareVariable</span>();
  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> &gt; <span class="n">0</span>) <span class="k">return</span> <span class="n">0</span>;

</pre><pre class="insert-after">  return identifierConstant(&amp;parser.previous);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parseVariable</em>()</div>

<p>First, we &ldquo;declare&rdquo; the variable. I&rsquo;ll get to what that means in a second. After
that, we exit the function if we&rsquo;re in a local scope. At runtime, locals aren&rsquo;t
looked up by name. There&rsquo;s no need to stuff the variable&rsquo;s name into the
constant table, so if the declaration is inside a local scope, we return a dummy
table index instead.
首先，我们“声明”这个变量。我一会儿会说到这是什么意思。之后，如果我们在局部作用域中，则退出函数。在运行时，不会通过名称查询局部变量。不需要将变量的名称放入常量表中，所以如果声明在局部作用域内，则返回一个假的表索引。</p>
<p>Over in <code>defineVariable()</code>, we need to emit the code to store a local variable
if we&rsquo;re in a local scope. It looks like this:
在<code>defineVariable()</code>中，如果处于局部作用域内，就需要生成一个字节码来存储局部变量。它看起来是这样的：</p>
<div class="codehilite"><pre class="insert-before">static void defineVariable(uint8_t global) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>defineVariable</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> &gt; <span class="n">0</span>) {
    <span class="k">return</span>;
  }

</pre><pre class="insert-after">  emitBytes(OP_DEFINE_GLOBAL, global);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>defineVariable</em>()</div>

<p>Wait, what? Yup. That&rsquo;s it. There is no code to create a local variable at
runtime. Think about what state the VM is in. It has already executed the code
for the variable&rsquo;s initializer (or the implicit <code>nil</code> if the user omitted an
initializer), and that value is sitting right on top of the stack as the only
remaining temporary. We also know that new locals are allocated at the top of
the stack<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>right where that value already is. Thus, there&rsquo;s nothing to do. The
temporary simply <em>becomes</em> the local variable. It doesn&rsquo;t get much more
efficient than that.
等等，什么？是的，就是这样。没有代码会在运行时创建局部变量。想想虚拟机现在处于什么状态。它已经执行了变量初始化表达式的代码（如果用户省略了初始化，则是隐式的<code>nil</code>），并且该值作为唯一保留的临时变量位于栈顶。我们还知道，新的局部变量会被分配到栈顶……这个值已经在那里了。因此，没有什么可做的。临时变量直接<em>成为</em>局部变量。没有比这更有效的方法了。</p>
<p><span name="locals"></span></p><img src="image/local-variables/local-slots.png" alt="Walking through the bytecode execution showing that each initializer's result ends up in the local's slot." />
<aside name="locals">
<p>The code on the left compiles to the sequence of instructions on the right.</p>
</aside>
<p>OK, so what&rsquo;s &ldquo;declaring&rdquo; about? Here&rsquo;s what that does:
好的，那“声明”是怎么回事呢？它的作用如下：</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">declareVariable</span>() {
  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> == <span class="n">0</span>) <span class="k">return</span>;

  <span class="t">Token</span>* <span class="i">name</span> = &amp;<span class="i">parser</span>.<span class="i">previous</span>;
  <span class="i">addLocal</span>(*<span class="i">name</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>This is the point where the compiler records the existence of the variable. We
only do this for locals, so if we&rsquo;re in the top-level global scope, we just bail
out. Because global variables are late bound, the compiler doesn&rsquo;t keep track of
which declarations for them it has seen.
在这里，编译器记录变量的存在。我们只对局部变量这样做，所以如果在顶层全局作用域中，就直接退出。因为全局变量是后期绑定的，所以编译器不会跟踪它所看到的关于全局变量的声明。</p>
<p>But for local variables, the compiler does need to remember that the variable
exists. That&rsquo;s what declaring it does<span class="em">&mdash;</span>it adds it to the compiler&rsquo;s list of
variables in the current scope. We implement that using another new function.
但是对于局部变量，编译器确实需要记住变量的存在。这就是声明的作用——将变量添加到编译器在当前作用域内的变量列表中。我们使用另一个新函数来实现这一点。</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">addLocal</span>(<span class="t">Token</span> <span class="i">name</span>) {
  <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span>++];
  <span class="i">local</span>-&gt;<span class="i">name</span> = <span class="i">name</span>;
  <span class="i">local</span>-&gt;<span class="i">depth</span> = <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>This initializes the next available Local in the compiler&rsquo;s array of variables.
It stores the variable&rsquo;s <span name="lexeme">name</span> and the depth of the
scope that owns the variable.
这会初始化编译器变量数组中下一个可用的Local。它存储了变量的名称和持有变量的作用域的深度。</p>
<aside name="lexeme">
<p>Worried about the lifetime of the string for the variable&rsquo;s name? The Local
directly stores a copy of the Token struct for the identifier. Tokens store a
pointer to the first character of their lexeme and the lexeme&rsquo;s length. That
pointer points into the original source string for the script or REPL entry
being compiled.</p>
<p>As long as that string stays around during the entire compilation process<span class="em">&mdash;</span>which it must since, you know, we&rsquo;re compiling it<span class="em">&mdash;</span>then all of the tokens
pointing into it are fine.</p>
</aside>
<p>Our implementation is fine for a correct Lox program, but what about invalid
code? Let&rsquo;s aim to be robust. The first error to handle is not really the user&rsquo;s
fault, but more a limitation of the VM. The instructions to work with local
variables refer to them by slot index. That index is stored in a single-byte
operand, which means the VM only supports up to 256 local variables in scope at
one time.
我们的实现对于一个正确的Lox程序来说是没有问题的，但是对于无效的代码呢？我们还是以稳健为目标。第一个要处理的错误其实不是用户的错，而是虚拟机的限制。使用局部变量的指令通过槽的索引来引用变量。该索引存储在一个单字节操作数中，这意味着虚拟机一次最多只能支持256个局部变量。</p>
<p>If we try to go over that, not only could we not refer to them at runtime, but
the compiler would overwrite its own locals array, too. Let&rsquo;s prevent that.
如果我们试图超过这个范围，不仅不能在运行时引用变量，而且编译器也会覆盖自己的局部变量数组。我们要防止这种情况。</p>
<div class="codehilite"><pre class="insert-before">static void addLocal(Token name) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addLocal</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">localCount</span> == <span class="a">UINT8_COUNT</span>) {
    <span class="i">error</span>(<span class="s">&quot;Too many local variables in function.&quot;</span>);
    <span class="k">return</span>;
  }

</pre><pre class="insert-after">  Local* local = &amp;current-&gt;locals[current-&gt;localCount++];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>()</div>

<p>The next case is trickier. Consider:
接下来的情况就有点棘手了。考虑一下：</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;first&quot;</span>;
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;second&quot;</span>;
}
</pre></div>
<p>At the top level, Lox allows redeclaring a variable with the same name as a
previous declaration because that&rsquo;s useful for the REPL. But inside a local
scope, that&rsquo;s a pretty <span name="rust">weird</span> thing to do. It&rsquo;s likely
to be a mistake, and many languages, including our own Lox, enshrine that
assumption by making this an error.
在顶层，Lox允许使用与之前声明的变量相同的名称重新声明一个变量，因为这在REPL中很有用。但在局部作用域中，这就有些奇怪了。这很可能是一个误用，许多语言（包括我们的Lox）都把它作为一个错误。</p>
<aside name="rust">
<p>Interestingly, the Rust programming language <em>does</em> allow this, and idiomatic
code relies on it.</p>
</aside>
<p>Note that the above program is different from this one:
请注意，上面的代码跟这个是不同的：</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;outer&quot;</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;inner&quot;</span>;
  }
}
</pre></div>
<p>It&rsquo;s OK to have two variables with the same name in <em>different</em> scopes, even
when the scopes overlap such that both are visible at the same time. That&rsquo;s
shadowing, and Lox does allow that. It&rsquo;s only an error to have two variables
with the same name in the <em>same</em> local scope.
在<em>不同的</em>作用域中有两个同名变量是可以的，即使作用域重叠，以至于两个变量是同时可见的。这就是遮蔽，而Lox确实允许这样做。只有在<em>同一个</em>局部作用域中有两个同名的变量才是错误的。</p>
<p>We detect that error like so:
我们这样检测这个错误：</p>
<div class="codehilite"><pre class="insert-before">  Token* name = &amp;parser.previous;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declareVariable</em>()</div>
<pre class="insert">  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">local</span>-&gt;<span class="i">depth</span> != -<span class="n">1</span> &amp;&amp; <span class="i">local</span>-&gt;<span class="i">depth</span> &lt; <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>) {
      <span class="k">break</span>;<span name="negative"> </span>
    }

    <span class="k">if</span> (<span class="i">identifiersEqual</span>(<span class="i">name</span>, &amp;<span class="i">local</span>-&gt;<span class="i">name</span>)) {
      <span class="i">error</span>(<span class="s">&quot;Already a variable with this name in this scope.&quot;</span>);
    }
  }

</pre><pre class="insert-after">  addLocal(*name);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declareVariable</em>()</div>

<aside name="negative">
<p>Don&rsquo;t worry about that odd <code>depth != -1</code> part yet. We&rsquo;ll get to what that&rsquo;s
about later.</p>
</aside>
<p>Local variables are appended to the array when they&rsquo;re declared, which means the
current scope is always at the end of the array. When we declare a new variable,
we start at the end and work backward, looking for an existing variable with the
same name. If we find one in the current scope, we report the error. Otherwise,
if we reach the beginning of the array or a variable owned by another scope,
then we know we&rsquo;ve checked all of the existing variables in the scope.
局部变量在声明时被追加到数组中，这意味着当前作用域始终位于数组的末端。当我们声明一个新的变量时，我们从末尾开始，反向查找具有相同名称的已有变量。如果是当前作用域中找到，我们就报告错误。此外，如果我们已经到达了数组开头或另一个作用域中的变量，我们就知道已经检查了当前作用域中的所有现有变量。</p>
<p>To see if two identifiers are the same, we use this:
为了查看两个标识符是否相同，我们使用这个方法：</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">identifiersEqual</span>(<span class="t">Token</span>* <span class="i">a</span>, <span class="t">Token</span>* <span class="i">b</span>) {
  <span class="k">if</span> (<span class="i">a</span>-&gt;<span class="i">length</span> != <span class="i">b</span>-&gt;<span class="i">length</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">return</span> <span class="i">memcmp</span>(<span class="i">a</span>-&gt;<span class="i">start</span>, <span class="i">b</span>-&gt;<span class="i">start</span>, <span class="i">a</span>-&gt;<span class="i">length</span>) == <span class="n">0</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>Since we know the lengths of both lexemes, we check that first. That will fail
quickly for many non-equal strings. If the <span name="hash">lengths</span> are
the same, we check the characters using <code>memcmp()</code>. To get to <code>memcmp()</code>, we
need an include.
既然我们知道两个词素的长度，那我们首先检查它。对于很多不相等的字符串，在这一步就很快失败了。如果长度相同，我们就使用<code>memcmp()</code>检查字符。为了使用<code>memcmp()</code>，我们需要引入一下。</p>
<ul>
<li></li>
</ul>
<p>有了这个，我们就能创造出变量。但是，它们会停留在声明它们的作用域之外，像幽灵一样。当一个代码块结束时，我们需要让其中的变量安息。</p>
<aside name="hash">
<p>It would be a nice little optimization if we could check their hashes, but
tokens aren&rsquo;t full LoxStrings, so we haven&rsquo;t calculated their hashes yet.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#include &lt;stdlib.h&gt;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert"><span class="a">#include &lt;string.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>With this, we&rsquo;re able to bring variables into being. But, like ghosts, they
linger on beyond the scope where they are declared. When a block ends, we need
to put them to rest.</p>
<div class="codehilite"><pre class="insert-before">  current-&gt;scopeDepth--;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endScope</em>()</div>
<pre class="insert">

  <span class="k">while</span> (<span class="i">current</span>-&gt;<span class="i">localCount</span> &gt; <span class="n">0</span> &amp;&amp;
         <span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">depth</span> &gt;
            <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>) {
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
    <span class="i">current</span>-&gt;<span class="i">localCount</span>--;
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endScope</em>()</div>

<p>When we pop a scope, we walk backward through the local array looking for any
variables declared at the scope depth we just left. We discard them by simply
decrementing the length of the array.
当我们弹出一个作用域时，后向遍历局部变量数组，查找在刚刚离开的作用域深度上声明的所有变量。我们通过简单地递减数组长度来丢弃它们。</p>
<p>There is a runtime component to this too. Local variables occupy slots on the
stack. When a local variable goes out of scope, that slot is no longer needed
and should be freed. So, for each variable that we discard, we also emit an
<code>OP_POP</code> <span name="pop">instruction</span> to pop it from the stack.
这里也有一个运行时的因素。局部变量占用了堆栈中的槽位。当局部变量退出作用域时，这个槽就不再需要了，应该被释放。因此，对于我们丢弃的每一个变量，我们也要生成一条<code>OP_POP</code>指令，将其从栈中弹出。</p>
<aside name="pop">
<p>When multiple local variables go out of scope at once, you get a series of
<code>OP_POP</code> instructions that get interpreted one at a time. A simple optimization
you could add to your Lox implementation is a specialized <code>OP_POPN</code> instruction
that takes an operand for the number of slots to pop and pops them all at once.</p>
</aside>
<h2><a href="#using-locals--使用局部变量" id="using-locals--使用局部变量"><small>22&#8202;.&#8202;4</small>Using Locals  使用局部变量</a></h2>
<p>We can now compile and execute local variable declarations. At runtime, their
values are sitting where they should be on the stack. Let&rsquo;s start using them.
We&rsquo;ll do both variable access and assignment at the same time since they touch
the same functions in the compiler.
我们现在可以编译和执行局部变量的声明了。在运行时，它们的值就在栈中应在的位置上。让我们开始使用它们吧。我们会同时完成变量访问和赋值，因为它们在编译器中涉及相同的函数。</p>
<p>We already have code for getting and setting global variables, and<span class="em">&mdash;</span>like good
little software engineers<span class="em">&mdash;</span>we want to reuse as much of that existing code as
we can. Something like this:
我们已经有了获取和设置全局变量的代码，而且像优秀的小软件工程师一样，我们希望尽可能多地重用现有的代码。就像这样：</p>
<div class="codehilite"><pre class="insert-before">static void namedVariable(Token name, bool canAssign) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">uint8_t</span> <span class="i">getOp</span>, <span class="i">setOp</span>;
  <span class="t">int</span> <span class="i">arg</span> = <span class="i">resolveLocal</span>(<span class="i">current</span>, &amp;<span class="i">name</span>);
  <span class="k">if</span> (<span class="i">arg</span> != -<span class="n">1</span>) {
    <span class="i">getOp</span> = <span class="a">OP_GET_LOCAL</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_LOCAL</span>;
  } <span class="k">else</span> {
    <span class="i">arg</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">name</span>);
    <span class="i">getOp</span> = <span class="a">OP_GET_GLOBAL</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_GLOBAL</span>;
  }
</pre><pre class="insert-after">

  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>Instead of hardcoding the bytecode instructions emitted for variable access and
assignment, we use a couple of C variables. First, we try to find a local
variable with the given name. If we find one, we use the instructions for
working with locals. Otherwise, we assume it&rsquo;s a global variable and use the
existing bytecode instructions for globals.
我们不对变量访问和赋值对应的字节码指令进行硬编码，而是使用了一些C变量。首先，我们尝试查找具有给定名称的局部变量，如果我们找到了，就使用处理局部变量的指令。否则，我们就假定它是一个全局变量，并使用现有的处理全局变量的字节码。</p>
<p>A little further down, we use those variables to emit the right instructions.
For assignment:
再往下一点，我们使用这些变量来生成正确的指令。对于赋值：</p>
<div class="codehilite"><pre class="insert-before">  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
    expression();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">emitBytes</span>(<span class="i">setOp</span>, (<span class="t">uint8_t</span>)<span class="i">arg</span>);
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>And for access:
对于访问：</p>
<div class="codehilite"><pre class="insert-before">    emitBytes(setOp, (uint8_t)arg);
  } else {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">emitBytes</span>(<span class="i">getOp</span>, (<span class="t">uint8_t</span>)<span class="i">arg</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>The real heart of this chapter, the part where we resolve a local variable, is
here:
本章的核心，也就是解析局部变量的部分，在这里：</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifiersEqual</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">resolveLocal</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">Token</span>* <span class="i">name</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">compiler</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">compiler</span>-&gt;<span class="i">locals</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">identifiersEqual</span>(<span class="i">name</span>, &amp;<span class="i">local</span>-&gt;<span class="i">name</span>)) {
      <span class="k">return</span> <span class="i">i</span>;
    }
  }

  <span class="k">return</span> -<span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifiersEqual</em>()</div>

<p>For all that, it&rsquo;s straightforward. We walk the list of locals that are
currently in scope. If one has the same name as the identifier token, the
identifier must refer to that variable. We&rsquo;ve found it! We walk the array
backward so that we find the <em>last</em> declared variable with the identifier. That
ensures that inner local variables correctly shadow locals with the same name in
surrounding scopes.
尽管如此，它还是很直截了当的。我们会遍历当前在作用域内的局部变量列表。如果有一个名称与标识符相同，则标识符一定指向该变量。我们已经找到了它！我们后向遍历数组，这样就能找到最后一个带有该标识符的已声明变量。这可以确保内部的局部变量能正确地遮蔽外围作用域中的同名变量。</p>
<p>At runtime, we load and store locals using the stack slot index, so that&rsquo;s what
the compiler needs to calculate after it resolves the variable. Whenever a
variable is declared, we append it to the locals array in Compiler. That means
the first local variable is at index zero, the next one is at index one, and so
on. In other words, the locals array in the compiler has the <em>exact</em> same layout
as the VM&rsquo;s stack will have at runtime. The variable&rsquo;s index in the locals array
is the same as its stack slot. How convenient!
在运行时，我们使用栈中槽索引来加载和存储局部变量，因此编译器在解析变量之后需要计算索引。每当一个变量被声明，我们就将它追加到编译器的局部变量数组中。这意味着第一个局部变量在索引0的位置，下一个在索引1的位置，以此类推。换句话说，编译器中的局部变量数组的布局与虚拟机堆栈在运行时的布局完全相同。变量在局部变量数组中的索引与其在栈中的槽位相同。多么方便啊！</p>
<p>If we make it through the whole array without finding a variable with the given
name, it must not be a local. In that case, we return <code>-1</code> to signal that it
wasn&rsquo;t found and should be assumed to be a global variable instead.
如果我们在整个数组中都没有找到具有指定名称的变量，那它肯定不是局部变量。在这种情况下，我们返回<code>-1</code>，表示没有找到，应该假定它是一个全局变量。</p>
<h3><a href="#interpreting-local-variables--解释局部变量" id="interpreting-local-variables--解释局部变量"><small>22&#8202;.&#8202;4&#8202;.&#8202;1</small>Interpreting local variables  解释局部变量</a></h3>
<p>Our compiler is emitting two new instructions, so let&rsquo;s get them working. First
is loading a local variable:
我们的编译器发出了两条新指令，我们来让它们发挥作用。首先是加载一个局部变量：</p>
<div class="codehilite"><pre class="insert-before">  OP_POP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_LOCAL</span>,
</pre><pre class="insert-after">  OP_GET_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>And its implementation:
还有其实现：</p>
<div class="codehilite"><pre class="insert-before">      case OP_POP: pop(); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_LOCAL</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">push</span>(<span class="i">vm</span>.<span class="i">stack</span>[<span class="i">slot</span>]);<span name="slot"> </span>
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_GET_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>It takes a single-byte operand for the stack slot where the local lives. It
loads the value from that index and then pushes it on top of the stack where
later instructions can find it.
它接受一个单字节操作数，用作局部变量所在的栈槽。它从索引处加载值，然后将其压入栈顶，在后面的指令可以找到它。</p>
<aside name="slot">
<p>It seems redundant to push the local&rsquo;s value onto the stack since it&rsquo;s already
on the stack lower down somewhere. The problem is that the other bytecode
instructions only look for data at the <em>top</em> of the stack. This is the core
aspect that makes our bytecode instruction set <em>stack</em>-based.
<a href="a-virtual-machine.html#design-note">Register-based</a> bytecode instruction sets avoid this stack juggling at the
cost of having larger instructions with more operands.</p>
</aside>
<p>Next is assignment:
接下来是赋值：</p>
<div class="codehilite"><pre class="insert-before">  OP_GET_LOCAL,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_SET_LOCAL</span>,
</pre><pre class="insert-after">  OP_GET_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>You can probably predict the implementation.
你大概能预测到它的实现。</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_LOCAL</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">vm</span>.<span class="i">stack</span>[<span class="i">slot</span>] = <span class="i">peek</span>(<span class="n">0</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_GET_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>It takes the assigned value from the top of the stack and stores it in the stack
slot corresponding to the local variable. Note that it doesn&rsquo;t pop the value
from the stack. Remember, assignment is an expression, and every expression
produces a value. The value of an assignment expression is the assigned value
itself, so the VM just leaves the value on the stack.
它从栈顶获取所赋的值，然后存储到与局部变量对应的栈槽中。注意，它不会从栈中弹出值。请记住，赋值是一个表达式，而每个表达式都会产生一个值。赋值表达式的值就是所赋的值本身，所以虚拟机要把值留在栈上。</p>
<p>Our disassembler is incomplete without support for these two new instructions.
如果不支持这两条新指令，我们的反汇编程序就不完整了。</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_POP&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_LOCAL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_GET_LOCAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_LOCAL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_SET_LOCAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_GET_GLOBAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>The compiler compiles local variables to direct slot access. The local
variable&rsquo;s name never leaves the compiler to make it into the chunk at all.
That&rsquo;s great for performance, but not so great for introspection. When we
disassemble these instructions, we can&rsquo;t show the variable&rsquo;s name like we could
with globals. Instead, we just show the slot number.
编译器将局部变量编译为直接的槽访问。局部变量的名称永远不会离开编译器，根本不可能进入字节码块。这对性能很好，但对内省(自我观察)来说就不那么好了。当我们反汇编这些指令时，我们不能像全局变量那样使用变量名称。相反，我们只显示槽号。</p>
<aside name="debug">
<p>Erasing local variable names in the compiler is a real issue if we ever want to
implement a debugger for our VM. When users step through code, they expect to
see the values of local variables organized by their names. To support that,
we&rsquo;d need to output some additional information that tracks the name of each
local variable at each stack slot.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>simpleInstruction</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">byteInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>,
                           <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>];
  <span class="i">printf</span>(<span class="s">&quot;%-16s %4d</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">name</span>, <span class="i">slot</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">2</span>;<span name="debug"> </span>
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>simpleInstruction</em>()</div>

<h3><a href="#another-scope-edge-case--另一种作用域边界情况" id="another-scope-edge-case--另一种作用域边界情况"><small>22&#8202;.&#8202;4&#8202;.&#8202;2</small>Another scope edge case  另一种作用域边界情况</a></h3>
<p>We already sunk some time into handling a couple of weird edge cases around
scopes. We made sure shadowing works correctly. We report an error if two
variables in the same local scope have the same name. For reasons that aren&rsquo;t
entirely clear to me, variable scoping seems to have a lot of these wrinkles.
I&rsquo;ve never seen a language where it feels completely <span
name="elegant">elegant</span>.
我们已经花了一些时间来处理部分关于作用域的奇怪的边界情况。我们确保变量遮蔽能正确工作。如果同一个局部作用域中的两个变量具有相同的名称，我们会报告错误。由于我并不完全清楚的原因，变量作用域似乎有很多这样的问题。我从来没有见过一种语言让人感觉绝对优雅。</p>
<aside name="elegant">
<p>No, not even Scheme.</p>
</aside>
<p>We&rsquo;ve got one more edge case to deal with before we end this chapter. Recall this strange beastie we first met in <a href="resolving-and-binding.html#resolving-variable-declarations">jlox&rsquo;s implementation of variable resolution</a>:
在本章结束之前，我们还有一个边界情况需要处理。回顾一下我们第一次在jlox中实现变量解析时，遇到的这个奇怪的东西：</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;outer&quot;</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
  }
}
</pre></div>
<p>We slayed it then by splitting a variable&rsquo;s declaration into two phases, and
we&rsquo;ll do that again here:
我们当时通过将一个变量的声明拆分为两个阶段来解决这个问题，在这里我们也要这样做：</p><img src="image/local-variables/phases.png" alt="An example variable declaration marked 'declared uninitialized' before the variable name and 'ready for use' after the initializer." />
<p>As soon as the variable declaration begins<span class="em">&mdash;</span>in other words, before its
initializer<span class="em">&mdash;</span>the name is declared in the current scope. The variable exists,
but in a special &ldquo;uninitialized&rdquo; state. Then we compile the initializer. If at
any point in that expression we resolve an identifier that points back to this
variable, we&rsquo;ll see that it is not initialized yet and report an error. After we
finish compiling the initializer, we mark the variable as initialized and ready
for use.
一旦变量声明开始——换句话说，在它的初始化式之前——名称就会在当前作用域中声明。变量存在，但处于特殊的“未初始化”状态。然后我们编译初始化式。如果在表达式中的任何一个时间点，我们解析了一个指向该变量的标识符，我们会发现它还没有初始化，并报告错误。在我们完成初始化表达式的编译之后，把变量标记为已初始化并可供使用。</p>
<p>To implement this, when we declare a local, we need to indicate the
&ldquo;uninitialized&rdquo; state somehow. We could add a new field to Local, but let&rsquo;s be a
little more parsimonious with memory. Instead, we&rsquo;ll set the variable&rsquo;s scope
depth to a special sentinel value, <code>-1</code>.
为了实现这一点，当声明一个局部变量时，我们需要以某种方式表明“未初始化”状态。我们可以在Local中添加一个新字段，但我们还是在内存方面更节省一些。相对地，我们将变量的作用域深度设置为一个特殊的哨兵值<code>-1</code>。</p>
<div class="codehilite"><pre class="insert-before">  local-&gt;name = name;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addLocal</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">local</span>-&gt;<span class="i">depth</span> = -<span class="n">1</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>(), replace 1 line</div>

<p>Later, once the variable&rsquo;s initializer has been compiled, we mark it
initialized.
稍后，一旦变量的初始化式编译完成，我们将其标记为已初始化。</p>
<div class="codehilite"><pre class="insert-before">  if (current-&gt;scopeDepth &gt; 0) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>defineVariable</em>()</div>
<pre class="insert">    <span class="i">markInitialized</span>();
</pre><pre class="insert-after">    return;
  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>defineVariable</em>()</div>

<p>That is implemented like so:
实现如下：</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>parseVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">markInitialized</span>() {
  <span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">depth</span> =
      <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parseVariable</em>()</div>

<p>So this is <em>really</em> what &ldquo;declaring&rdquo; and &ldquo;defining&rdquo; a variable means in the
compiler. &ldquo;Declaring&rdquo; is when the variable is added to the scope, and &ldquo;defining&rdquo;
is when it becomes available for use.
所这就是编译器中“声明”和“定义”变量的真正含义。“声明”是指变量被添加到作用域中，而“定义”是变量可以被使用的时候。</p>
<p>When we resolve a reference to a local variable, we check the scope depth to see
if it&rsquo;s fully defined.
当解析指向局部变量的引用时，我们会检查作用域深度，看它是否被完全定义。</p>
<div class="codehilite"><pre class="insert-before">    if (identifiersEqual(name, &amp;local-&gt;name)) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>resolveLocal</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">local</span>-&gt;<span class="i">depth</span> == -<span class="n">1</span>) {
        <span class="i">error</span>(<span class="s">&quot;Can&#39;t read local variable in its own initializer.&quot;</span>);
      }
</pre><pre class="insert-after">      return i;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>resolveLocal</em>()</div>

<p>If the variable has the sentinel depth, it must be a reference to a variable in
its own initializer, and we report that as an error.
如果变量的深度是哨兵值，那这一定是在变量自身的初始化式中对该变量的引用，我们会将其报告为一个错误。</p>
<p>That&rsquo;s it for this chapter! We added blocks, local variables, and real,
honest-to-God lexical scoping. Given that we introduced an entirely different
runtime representation for variables, we didn&rsquo;t have to write a lot of code. The
implementation ended up being pretty clean and efficient.
这一章就讲到这里！我们添加了块、局部变量和真正的词法作用域。鉴于我们为变量引入了完全不同的运行时表示形式，我们不必编写很多代码。这个实现最终是相当干净和高效的。</p>
<p>You&rsquo;ll notice that almost all of the code we wrote is in the compiler. Over in
the runtime, it&rsquo;s just two little instructions. You&rsquo;ll see this as a continuing
<span name="static">trend</span> in clox compared to jlox. One of the biggest
hammers in the optimizer&rsquo;s toolbox is pulling work forward into the compiler so
that you don&rsquo;t have to do it at runtime. In this chapter, that meant resolving
exactly which stack slot every local variable occupies. That way, at runtime, no
lookup or resolution needs to happen.
你会注意到，我们写的几乎所有的代码都在编译器中。在运行时，只有两个小指令。你会看到，相比于jlox，这是clox中的一个持续的趋势。优化器工具箱中最大的锤子就是把工作提前到编译器中，这样你就不必在运行时做这些工作了。在本章中，这意味着要准确地解析每个局部变量占用的栈槽。这样，在运行时就不需要进行查找或解析。
: 函数参数也被大量使用。它们也像局部变量一样工作，因此我们将会对它们使用同样的实现技术。
: 这种排列方式显然不是巧合。我将Lox设计成可以单遍编译为基于堆栈的字节码。但我没必要为了适应这些限制对语言进行过多的调整。它的大部分设计应该感觉很自然。<BR>这在很大程度上是因为语言的历史与单次编译紧密联系在一起，其次是基于堆栈的架构。Lox的块作用域遵循的传统可以追溯到BCPL。作为程序员，我们对一门语言中什么是“正常”的直觉，即使在今天也会受到过去的硬件限制的影响。
: 在本章中，局部变量从虚拟机堆栈数组的底部开始，并在那里建立索引。当我们添加函数时，这个方案就变得有点复杂了。每个函数都需要自己的堆栈区域来存放参数和局部变量。但是，正如我们将看到的，这并没有如你所想那样增加太多的复杂性。
: 我们正在编写一个单遍编译器，所以对于如何在数组中对变量进行排序，我们并没有太多的选择。
: 特别说明，如果我们想在多线程应用程序中使用编译器（可能有多个编译器并行运行），那么使用全局变量是一个坏主意。
: 仔细想想，“块”是个奇怪的名字。作为比喻来说，“块”通常意味着一个不可分割的小单元，但出于某种原因，Algol 60委员会决定用它来指代一个复合结构——一系列语句。我想，还有更糟的情况，Algol 58将<code>begin</code>和<code>end</code>称为“语句括号”。
: 在后面编译函数体时，这个方法会派上用场。
: 担心作为变量名称的字符串的生命周期吗？Local直接存储了标识符对应Token结构体的副本。Token存储了一个指向其词素中第一个字符的指针，以及词素的长度。该指针指向正在编译的脚本或REPL输入语句的源字符串。<BR>只要这个字符串在整个编译过程中存在——你知道，它一定存在，我们正在编译它——那么所有指向它的标识都是正常的。
: 有趣的是，Rust语言确实允许这样做，而且惯用代码也依赖于此。
: 暂时先不用关心那个奇怪的<code>depth != -1</code>部分。我们稍后会讲到。
: 如果我们能检查它们的哈希值，将是一个不错的小优化，但标识不是完整的LoxString，所以我们还没有计算出它们的哈希值。
: 当多个局部变量同时退出作用域时，你会得到一系列的<code>OP_POP</code>指令，这些指令会被逐个解释。你可以在你的Lox实现中添加一个简单的优化，那就是专门的<code>OP_POPN</code>指令，该指令接受一个操作数，作为弹出的槽位的数量，并一次性弹出所有槽位。
: 把局部变量的值压到栈中似乎是多余的，因为它已经在栈中较低的某个位置了。问题是，其它字节码指令只能查找<em>栈顶</em>的数据。这也是我们的字节码指令集基于堆栈的主要表现。<a href="http://www.craftinginterpreters.com/a-virtual-machine.html#design-note">基于寄存器</a>的字节码指令集避免了这种堆栈技巧，其代价是有着更多操作数的大型指令。
: 如果我们想为虚拟机实现一个调试器，在编译器中擦除局部变量名称是一个真正的问题。当用户逐步执行代码时，他们希望看到局部变量的值按名称排列。为了支持这一点，我们需要输出一些额外的信息，以跟踪每个栈槽中的局部变量的名称。
: 没有，即便Scheme也不是。
: 你可以把静态类型看作是这种趋势的一个极端例子。静态类型语言将所有的类型分析和类型错误处理都在编译过程中进行了整理。这样，运行时就不必浪费时间来检查值是否具有适合其操作的类型。事实上，在一些静态类型语言（如C）中，你甚至不<em>知道</em>运行时的类型。编译器完全擦除值类型的任何表示，只留下空白的比特位。</p>
<h2><a href="#习题" id="习题"><small>22&#8202;.&#8202;5</small>习题</a></h2>
<ol>
<li>
<blockquote>
<p>Our simple local array makes it easy to calculate the stack slot of each local variable. But it means that when the compiler resolves a reference to a variable, we have to do a linear scan through the array.</p>
</blockquote>
</li>
</ol>
<aside name="static">
<p>You can look at static types as an extreme example of this trend. A statically
typed language takes all of the type analysis and type error handling and sorts
it all out during compilation. Then the runtime doesn&rsquo;t have to waste any time
checking that values have the proper type for their operation. In fact, in some
statically typed languages like C, you don&rsquo;t even <em>know</em> the type at runtime.
The compiler completely erases any representation of a value&rsquo;s type leaving just
the bare bits.</p>
</aside>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Our simple local array makes it easy to calculate the stack slot of each
local variable. But it means that when the compiler resolves a reference to
a variable, we have to do a linear scan through the array.</p>
<p>Come up with something more efficient. Do you think the additional
complexity is worth it?
我们这个简单的局部变量数组使得计算每个局部变量的栈槽很容易。但这意味着，当编译器解析一个变量的引用时，我们必须对数组进行线性扫描。
想出一些更有效的方法。你认为这种额外的复杂性是否值得？</p>
</li>
<li>
<blockquote>
<p>How do other languages handle code like this:
其它语言中如何处理这样的代码：</p>
</blockquote>
</li>
<li>
<p>How do other languages handle code like this:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
</pre></div>
<p>What would you do if it was your language? Why?
如果这是你的语言，你会怎么做？为什么？</p>
</li>
<li>
<blockquote>
<p>Many languages make a distinction between variables that can be reassigned and those that can’t. In Java, the <code>final</code> modifier prevents you from assigning to a variable. In JavaScript, a variable declared with <code>let</code> can be assigned, but one declared using <code>const</code> can’t. Swift treats <code>let</code> as single-assignment and uses <code>var</code> for assignable variables. Scala and Kotlin use <code>val</code> and <code>var</code>.</p>
</blockquote>
</li>
<li>
<p>Many languages make a distinction between variables that can be reassigned
and those that can&rsquo;t. In Java, the <code>final</code> modifier prevents you from
assigning to a variable. In JavaScript, a variable declared with <code>let</code> can
be assigned, but one declared using <code>const</code> can&rsquo;t. Swift treats <code>let</code> as
single-assignment and uses <code>var</code> for assignable variables. Scala and Kotlin
use <code>val</code> and <code>var</code>.</p>
<p>Pick a keyword for a single-assignment variable form to add to Lox. Justify
your choice, then implement it. An attempt to assign to a variable declared
using your new keyword should cause a compile error.
许多语言中，对可以重新赋值的变量与不能重新赋值的变量进行了区分。在Java中，<code>final</code>修饰符可以阻止你对变量进行赋值。在JavaScript中，用<code>let</code>声明的变量可以被赋值，但用<code>const</code>声明的变量不能被赋值。<code>Swift</code>将<code>let</code>视为单次赋值，并对可赋值变量使用<code>var</code>。<code>Scala</code>和<code>Kotlin</code>则使用<code>val</code>和<code>var</code>。
选一个关键字作为单次赋值变量的形式添加到Lox中。解释一下你的选择，然后实现它。试图赋值给一个用新关键字声明的变量应该会引起编译错误。</p>
</li>
<li>
<blockquote>
<p>Extend clox to allow more than 256 local variables to be in scope at a time.
扩展Lox，允许作用域中同时有超过256个局部变量。</p>
</blockquote>
</li>
<li>
<p>Extend clox to allow more than 256 local variables to be in scope at a time.</p>
</li>
</ol>
</div>

<footer>
<a href="jumping-back-and-forth.html" class="next">
  Next Chapter: &ldquo;Jumping Back and Forth&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
