<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>解析表达式 &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
        <h3><a href="#top">解析表达式<small>6</small></a></h3>
    
    <ul>
        <li><a href="#ambiguity-and-the-parsing-game--歧义与解析游戏"><small>6.1</small> Ambiguity and the Parsing Game  歧义与解析游戏</a></li>
        <li><a href="#recursive-descent-parsing--递归下降分析"><small>6.2</small> Recursive Descent Parsing  递归下降分析</a></li>
        <li><a href="#syntax-errors--语法错误"><small>6.3</small> Syntax Errors  语法错误</a></li>
        <li><a href="#wiring-up-the-parser--调整解析器"><small>6.4</small> Wiring up the Parser  调整解析器</a></li>
        <li class="divider"></li>
        <li class="end-part"><a href="#challenges">Challenges</a></li>
        <li class="end-part"><a href="#design-note"><small>note</small>Logic Versus History</a></li>
    </ul>
    
    
        <div class="prev-next">
        <a href="representing-code.html" title="代码表示" class="left">&larr;&nbsp;Previous</a>
        <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
        <a href="evaluating-expressions.html" title="求值表达式" class="right">Next&nbsp;&rarr;</a>
    </div> </div>
</nav>

<nav class="narrow">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <a href="representing-code.html" title="代码表示" class="prev">←</a>
  <a href="evaluating-expressions.html" title="求值表达式" class="next">→</a>
</nav>

<div class="page">
  <div class="nav-wrapper">
    <nav class="floating">
      <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
      <div class="expandable">
        <h3><a href="#top">解析表达式<small>6</small></a></h3>
        
        <ul>
            <li><a href="#ambiguity-and-the-parsing-game--歧义与解析游戏"><small>6.1</small> Ambiguity and the Parsing Game  歧义与解析游戏</a></li>
            <li><a href="#recursive-descent-parsing--递归下降分析"><small>6.2</small> Recursive Descent Parsing  递归下降分析</a></li>
            <li><a href="#syntax-errors--语法错误"><small>6.3</small> Syntax Errors  语法错误</a></li>
            <li><a href="#wiring-up-the-parser--调整解析器"><small>6.4</small> Wiring up the Parser  调整解析器</a></li>
            <li class="divider"></li>
            <li class="end-part"><a href="#challenges">Challenges</a></li>
            <li class="end-part"><a href="#design-note"><small>note</small>Logic Versus History</a></li>
        </ul>
        
        
                <div class="prev-next">
            <a href="representing-code.html" title="代码表示" class="left">&larr;&nbsp;Previous</a>
            <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
            <a href="evaluating-expressions.html" title="求值表达式" class="right">Next&nbsp;&rarr;</a>
        </div>      </div>
      <a id="expand-nav">≡</a>
    </nav>
  </div>

  <article class="chapter">

    <div class="number">6</div>
    <h1>解析表达式</h1>

    <blockquote>
<p>Grammar, which knows how to control even kings.
<cite>Molière</cite></p>
</blockquote>
<p><span name="parse">This</span> chapter marks the first major milestone of the
book. Many of us have cobbled together a mishmash of regular expressions and
substring operations to extract some sense out of a pile of text. The code was
probably riddled with bugs and a beast to maintain. Writing a <em>real</em> parser<span class="em">&mdash;</span>one with decent error handling, a coherent internal structure, and the ability
to robustly chew through a sophisticated syntax<span class="em">&mdash;</span>is considered a rare,
impressive skill. In this chapter, you will <span name="attain">attain</span>
it.
本章是本书的第一个重要里程碑。我们中的许多人都曾将正则表达式和字符串操作糅合在一起，以便从一堆文本中提取一些信息。这些代码可能充满了错误，而且很难维护。编写一个真正的解析器——具有良好的错误处理、一致的内部结构和能够健壮地分析复杂语法的能力——被认为是一种罕见的、令人印象深刻的技能。在这一章中，你将获得这种技能。</p>
<aside name="parse">
<p>&ldquo;Parse&rdquo; comes to English from the Old French &ldquo;pars&rdquo; for &ldquo;part of speech&rdquo;. It
means to take a text and map each word to the grammar of the language. We use it
here in the same sense, except that our language is a little more modern than
Old French.</p>
</aside>
<aside name="attain">
<p>Like many rites of passage, you&rsquo;ll probably find it looks a little smaller, a
little less daunting when it&rsquo;s behind you than when it loomed ahead.</p>
</aside>
<p>It&rsquo;s easier than you think, partially because we front-loaded a lot of the hard
work in the <a href="representing-code.html">last chapter</a>. You already know your way around a formal grammar.
You&rsquo;re familiar with syntax trees, and we have some Java classes to represent
them. The only remaining piece is parsing<span class="em">&mdash;</span>transmogrifying a sequence of
tokens into one of those syntax trees.</p>
<p>Some CS textbooks make a big deal out of parsers. In the &rsquo;60s, computer
scientists<span class="em">&mdash;</span>understandably tired of programming in assembly language<span class="em">&mdash;</span>started designing more sophisticated, <span name="human">human</span>-friendly
languages like Fortran and ALGOL. Alas, they weren&rsquo;t very <em>machine</em>-friendly
for the primitive computers of the time.
一些CS教科书在解析器上大做文章。在60年代，计算机科学家——他们理所当然地厌倦了用汇编语言编程——开始设计更复杂的、对人类友好的语言，比如Fortran和ALGOL。唉，对于当时原始的计算机来说，这些语言对机器并不友好。</p>
<aside name="human">
<p>Imagine how harrowing assembly programming on those old machines must have been
that they considered <em>Fortran</em> to be an improvement.</p>
</aside>
<p>These pioneers designed languages that they honestly weren&rsquo;t even sure how to
write compilers for, and then did groundbreaking work inventing parsing and
compiling techniques that could handle these new, big languages on those old, tiny
machines.
这些先驱们设计了一些语言，说实话，他们甚至不知道如何编写编译器。然后他们做了开创性的工作，发明了解析和编译技术，可以在那些老旧、小型的机器上处理这些新的、大型的语言。</p>
<p>Classic compiler books read like fawning hagiographies of these heroes and their
tools. The cover of <em>Compilers: Principles, Techniques, and Tools</em> literally has
a dragon labeled &ldquo;complexity of compiler design&rdquo; being slain by a knight bearing
a sword and shield branded &ldquo;LALR parser generator&rdquo; and &ldquo;syntax directed
translation&rdquo;. They laid it on thick.
经典的编译书读起来就像是对这些英雄和他们的工具的吹捧传记。《编译器:原理、技术和工具》（<em>Compilers: Principles, Techniques, and Tools</em>）的封面上有一条标记着“编译器设计复杂性”的龙，被一个手持剑和盾的骑士杀死，剑和盾上标记着“LALR解析器生成器”和“语法制导翻译”。他们在过分吹捧。</p>
<p>A little self-congratulation is well-deserved, but the truth is you don&rsquo;t need
to know most of that stuff to bang out a high quality parser for a modern
machine. As always, I encourage you to broaden your education and take it in
later, but this book omits the trophy case.
稍微的自我祝贺是当之无愧的，但事实是，你不需要知道其中的大部分知识，就可以为现代机器制作出高质量的解析器。一如既往，我鼓励你先扩大学习范围，以后再慢慢接受它，但这本书省略了奖杯箱。</p>
<h2><a href="#ambiguity-and-the-parsing-game--歧义与解析游戏" id="ambiguity-and-the-parsing-game--歧义与解析游戏"><small>6&#8202;.&#8202;1</small>Ambiguity and the Parsing Game  歧义与解析游戏</a></h2>
<p>In the last chapter, I said you can &ldquo;play&rdquo; a context-free grammar like a game in
order to <em>generate</em> strings. Parsers play that game in reverse. Given a string<span class="em">&mdash;</span>a series of tokens<span class="em">&mdash;</span>we map those tokens to terminals in the grammar to
figure out which rules could have generated that string.
在上一章中，我说过你可以像“玩”游戏一样使用上下文无关的语法来<em>生成</em>字符串。解析器则以相反的方式玩游戏。给定一个字符串(一系列语法标记)，我们将这些标记映射到语法中的终止符，以确定哪些规则可能生成该字符串。</p>
<p>The &ldquo;could have&rdquo; part is interesting. It&rsquo;s entirely possible to create a grammar
that is <em>ambiguous</em>, where different choices of productions can lead to the same
string. When you&rsquo;re using the grammar to <em>generate</em> strings, that doesn&rsquo;t matter
much. Once you have the string, who cares how you got to it?
&ldquo;可能产生 &ldquo;这部分很有意思。我们完全有可能创建一个<em>模棱两可</em>的语法，在这个语法中，不同的生成式可能会得到同一个字符串。当你使用该语法来<em>生成</em>字符串时，这一点不太重要。一旦你有了字符串，谁还会在乎你是怎么得到它的呢？</p>
<p>When parsing, ambiguity means the parser may misunderstand the user&rsquo;s code. As
we parse, we aren&rsquo;t just determining if the string is valid Lox code, we&rsquo;re
also tracking which rules match which parts of it so that we know what part of
the language each token belongs to. Here&rsquo;s the Lox expression grammar we put
together in the last chapter:
但是在解析时，歧义意味着解析器可能会误解用户的代码。当我们进行解析时，我们不仅要确定字符串是不是有效的Lox代码，还要记录哪些规则与代码的哪些部分相匹配，以便我们知道每个标记属于语言的哪一部分。下面是我们在上一章整理的Lox表达式语法：</p>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">literal</span>
               | <span class="i">unary</span>
               | <span class="i">binary</span>
               | <span class="i">grouping</span> ;

<span class="i">literal</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">&quot;true&quot;</span> | <span class="s">&quot;false&quot;</span> | <span class="s">&quot;nil&quot;</span> ;
<span class="i">grouping</span>       → <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> ;
<span class="i">unary</span>          → ( <span class="s">&quot;-&quot;</span> | <span class="s">&quot;!&quot;</span> ) <span class="i">expression</span> ;
<span class="i">binary</span>         → <span class="i">expression</span> <span class="i">operator</span> <span class="i">expression</span> ;
<span class="i">operator</span>       → <span class="s">&quot;==&quot;</span> | <span class="s">&quot;!=&quot;</span> | <span class="s">&quot;&lt;&quot;</span> | <span class="s">&quot;&lt;=&quot;</span> | <span class="s">&quot;&gt;&quot;</span> | <span class="s">&quot;&gt;=&quot;</span>
               | <span class="s">&quot;+&quot;</span>  | <span class="s">&quot;-&quot;</span>  | <span class="s">&quot;*&quot;</span> | <span class="s">&quot;/&quot;</span> ;
</pre></div>
<p>This is a valid string in that grammar:
下面是一个满足语法的有效字符串：</p><img src="image/parsing-expressions/tokens.png" alt="6 / 3 - 1" />
<p>But there are two ways we could have generated it. One way is:
但是，有两种方式可以生成该字符串。其一是：</p>
<ol>
<li>Starting at <code>expression</code>, pick <code>binary</code>.</li>
<li>For the left-hand <code>expression</code>, pick <code>NUMBER</code>, and use <code>6</code>.</li>
<li>For the operator, pick <code>"/"</code>.</li>
<li>For the right-hand <code>expression</code>, pick <code>binary</code> again.</li>
<li>In that nested <code>binary</code> expression, pick <code>3 - 1</code>.</li>
<li>从<code>expression</code>开始，选择<code>binary</code>。</li>
<li>对于左边的<code>expression</code>，选择<code>NUMBER</code>，并且使用<code>6</code>。</li>
<li>对于操作符，选择<code>/</code>。</li>
<li>对于右边的<code>expression</code>，再次选择<code>binary</code>。</li>
<li>在内层的<code>binary</code> 表达式中，选择<code>3-1</code>。</li>
</ol>
<p>Another is:
其二是：</p>
<ol>
<li>Starting at <code>expression</code>, pick <code>binary</code>.</li>
<li>For the left-hand <code>expression</code>, pick <code>binary</code> again.</li>
<li>In that nested <code>binary</code> expression, pick <code>6 / 3</code>.</li>
<li>Back at the outer <code>binary</code>, for the operator, pick <code>"-"</code>.</li>
<li>For the right-hand <code>expression</code>, pick <code>NUMBER</code>, and use <code>1</code>.</li>
<li>从<code>expression</code>开始，选择<code>binary</code>。</li>
<li>对于左边的<code>expression</code>，再次选择<code>binary</code>。</li>
<li>在内层的<code>binary</code> 表达式中，选择<code>6/3</code>。</li>
<li>返回外层的<code>binary</code> ，对于操作符，选择<code>-</code>。</li>
<li>对于右边的<code>expression</code>，选择<code>NUMBER</code>，并且使用<code>1</code>。</li>
</ol>
<p>Those produce the same <em>strings</em>, but not the same <em>syntax trees</em>:
它们产生相同的字符串，但对应的是不同的<em>语法树</em>：
<img src="6.解析表达式/syntax-trees.png" alt="Two valid syntax trees: (6 / 3) - 1 and 6 / (3 - 1)" /></p><img src="image/parsing-expressions/syntax-trees.png" alt="Two valid syntax trees: (6 / 3) - 1 and 6 / (3 - 1)" />
<p>In other words, the grammar allows seeing the expression as <code>(6 / 3) - 1</code> or <code>6 / (3 - 1)</code>. The <code>binary</code> rule lets operands nest any which way you want. That in
turn affects the result of evaluating the parsed tree. The way mathematicians
have addressed this ambiguity since blackboards were first invented is by
defining rules for precedence and associativity.
换句话说，这个语法可以将该表达式看作是 <code>(6 / 3) - 1</code>或<code>6 / (3 - 1)</code>。<code>binary</code> 规则运行操作数以任意方式嵌套，这反过来又会影响解析数的计算结果。自从黑板被发明以来，数学家们解决这种模糊性的方法就是定义优先级和结合性规则。</p>
<ul>
<li>
<blockquote>
<p><strong>Precedence</strong> determines which operator is evaluated first in an expression containing a mixture of different operators. Precedence rules tell us that we evaluate the <code>/</code> before the <code>-</code> in the above example. Operators with higher precedence are evaluated before operators with lower precedence. Equivalently, higher precedence operators are said to “bind tighter”.</p>
</blockquote>
</li>
<li><strong>优先级</strong>决定了在一个包含不同运算符的混合表达式中，哪个运算符先被执行。优先级规则告诉我们，在上面的例子中，我们在<code>-</code>之前先计算<code>/</code>。优先级较高的运算符在优先级较低的运算符之前计算。同样，优先级较高的运算符被称为 &ldquo;更严格的绑定&ldquo;。</li>
<li>
<blockquote>
<p><strong>Associativity</strong> determines which operator is evaluated first in a series of the <em>same</em> operator. When an operator is <strong>left-associative</strong> (think “left-to-right”), operators on the left evaluate before those on the right. Since <code>-</code> is left-associative, this expression:</p>
</blockquote>
</li>
<li><strong>结合性</strong>决定在一系列相同操作符中先计算哪个操作符。如果一个操作符是<strong>左结合</strong>的(可以认为是“从左到右”)时，左边的操作符在右边的操作符之前计算。因为<code>-</code>是左结合的，下面的表达式：</li>
</ul>
<ul>
<li>
<p><span name="nonassociative"><strong>Precedence</strong></span> determines which operator
is evaluated first in an expression containing a mixture of different
operators. Precedence rules tell us that we evaluate the <code>/</code> before the <code>-</code>
in the above example. Operators with higher precedence are evaluated
before operators with lower precedence. Equivalently, higher precedence
operators are said to &ldquo;bind tighter&rdquo;.</p>
</li>
<li>
<p><strong>Associativity</strong> determines which operator is evaluated first in a series
of the <em>same</em> operator. When an operator is <strong>left-associative</strong> (think
&ldquo;left-to-right&rdquo;), operators on the left evaluate before those on the right.
Since <code>-</code> is left-associative, this expression:</p>
<div class="codehilite"><pre><span class="n">5</span> - <span class="n">3</span> - <span class="n">1</span>
</pre></div>
<p>is equivalent to:
等价于：</p>
<div class="codehilite"><pre>(<span class="n">5</span> - <span class="n">3</span>) - <span class="n">1</span>
</pre></div>
<p>Assignment, on the other hand, is <strong>right-associative</strong>. This:
另一方面，赋值是<strong>右结合</strong>的。如：</p>
<div class="codehilite"><pre><span class="i">a</span> = <span class="i">b</span> = <span class="i">c</span>
</pre></div>
<p>is equivalent to:
等价于：</p>
<div class="codehilite"><pre><span class="i">a</span> = (<span class="i">b</span> = <span class="i">c</span>)
</pre></div>
</li>
</ul>
<aside name="nonassociative">
<p>While not common these days, some languages specify that certain pairs of
operators have <em>no</em> relative precedence. That makes it a syntax error to mix
those operators in an expression without using explicit grouping.</p>
<p>Likewise, some operators are <strong>non-associative</strong>. That means it&rsquo;s an error to
use that operator more than once in a sequence. For example, Perl&rsquo;s range
operator isn&rsquo;t associative, so <code>a .. b</code> is OK, but <code>a .. b .. c</code> is an error.</p>
</aside>
<p>Without well-defined precedence and associativity, an expression that uses
multiple operators is ambiguous<span class="em">&mdash;</span>it can be parsed into different syntax trees,
which could in turn evaluate to different results. We&rsquo;ll fix that in Lox by
applying the same precedence rules as C, going from lowest to highest.
如果没有明确定义的优先级和结合性，使用多个运算符的表达式可能就会变得有歧义——它可以被解析为不同的语法树，而这些语法树又可能会计算出不同的结果。我们在Lox中会解决这个问题，使用与C语言相同的优先级规则，从低到高分别是：
| Name | Operators | Associates |
| | | |
| Equality 等于 | <code>==</code> <code>!=</code> | Left 左结合 |
| Comparison 比较 | <code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code> | Left 左结合 |
| Term 加减运算 | <code>-</code> <code>+</code> | Left 左结合 |
| Factor 乘除运算 | <code>/</code> <code>*</code> | Left 左结合 |
| Unary 一元运算符 | <code>!</code> <code>-</code> | Right 右结合 |</p><table>
<thead>
<tr>
  <td>Name</td>
  <td>Operators</td>
  <td>Associates</td>
</tr>
</thead>
<tbody>
<tr>
  <td>Equality</td>
  <td><code>==</code> <code>!=</code></td>
  <td>Left</td>
</tr>
<tr>
  <td>Comparison</td>
  <td><code>&gt;</code> <code>&gt;=</code>
      <code>&lt;</code> <code>&lt;=</code></td>
  <td>Left</td>
</tr>
<tr>
  <td>Term</td>
  <td><code>-</code> <code>+</code></td>
  <td>Left</td>
</tr>
<tr>
  <td>Factor</td>
  <td><code>/</code> <code>*</code></td>
  <td>Left</td>
</tr>
<tr>
  <td>Unary</td>
  <td><code>!</code> <code>-</code></td>
  <td>Right</td>
</tr>
</tbody>
</table>
<p>Right now, the grammar stuffs all expression types into a single <code>expression</code>
rule. That same rule is used as the non-terminal for operands, which lets the
grammar accept any kind of expression as a subexpression, regardless of whether
the precedence rules allow it.
现在，该语法将所有表达式类型都添加到一个 <code>expression</code>规则中。这条规则同样作用于操作数中的非终止符，这使得语法中可以接受任何类型的表达式作为子表达式，而不管优先级规则是否允许。</p>
<p>We fix that by <span name="massage">stratifying</span> the grammar. We define a
separate rule for each precedence level.
我们通过对语法进行分层来解决这个问题。我们为每个优先级定义一个单独的规则。</p>
<div class="codehilite"><pre><span class="i">expression</span>     → ...
<span class="i">equality</span>       → ...
<span class="i">comparison</span>     → ...
<span class="i">term</span>           → ...
<span class="i">factor</span>         → ...
<span class="i">unary</span>          → ...
<span class="i">primary</span>        → ...
</pre></div>
<aside name="massage">
<p>Instead of baking precedence right into the grammar rules, some parser
generators let you keep the same ambiguous-but-simple grammar and then add in a
little explicit operator precedence metadata on the side in order to
disambiguate.</p>
</aside>
<p>Each rule here only matches expressions at its precedence level or higher. For
example, <code>unary</code> matches a unary expression like <code>!negated</code> or a primary
expression like <code>1234</code>. And <code>term</code> can match <code>1 + 2</code> but also <code>3 * 4 / 5</code>. The
final <code>primary</code> rule covers the highest-precedence forms<span class="em">&mdash;</span>literals and
parenthesized expressions.
此处的每个规则仅匹配其当前优先级或更高优先级的表达式。 例如，<code>unary</code> 匹配一元表达式（如 <code>!negated</code>）或主表达式（如<code>1234</code>）。<code>term</code>可以匹配<code>1 + 2</code>，但也可以匹配<code>3 * 4 /5</code>。最后的<code>primary</code> 规则涵盖优先级最高的形式——字面量和括号表达式。</p>
<p>We just need to fill in the productions for each of those rules. We&rsquo;ll do the
easy ones first. The top <code>expression</code> rule matches any expression at any
precedence level. Since <span name="equality"><code>equality</code></span> has the lowest
precedence, if we match that, then it covers everything.
我们只需要填写每条规则的生成式。我们先从简单的开始。顶级的<code>expression</code> 规则可以匹配任何优先级的表达式。由于<code>equality</code>的优先级最低，只要我们匹配了它，就涵盖了一切。</p>
<aside name="equality">
<p>We could eliminate <code>expression</code> and simply use <code>equality</code> in the other rules
that contain expressions, but using <code>expression</code> makes those other rules read a
little better.</p>
<p>Also, in later chapters when we expand the grammar to include assignment and
logical operators, we&rsquo;ll only need to change the production for <code>expression</code>
instead of touching every rule that contains an expression.</p>
</aside>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">equality</span>
</pre></div>
<p>Over at the other end of the precedence table, a primary expression contains
all the literals and grouping expressions.
在优先级表的另一端，<code>primary</code>表达式包括所有的字面量和分组表达式。</p>
<div class="codehilite"><pre><span class="i">primary</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">&quot;true&quot;</span> | <span class="s">&quot;false&quot;</span> | <span class="s">&quot;nil&quot;</span>
               | <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> ;
</pre></div>
<p>A unary expression starts with a unary operator followed by the operand. Since
unary operators can nest<span class="em">&mdash;</span><code>!!true</code> is a valid if weird expression<span class="em">&mdash;</span>the
operand can itself be a unary operator. A recursive rule handles that nicely.
一元表达式以一元操作符开头，后跟操作数。因为一元操作符可以嵌套——<code>!!true</code>虽奇怪也是可用的表达式——这个操作数本身可以是一个一元表达式。递归规则可以很好地解决这个问题。</p>
<div class="codehilite"><pre><span class="i">unary</span>          → ( <span class="s">&quot;!&quot;</span> | <span class="s">&quot;-&quot;</span> ) <span class="i">unary</span> ;
</pre></div>
<p>But this rule has a problem. It never terminates.
但是这条规则有一个问题，它永远不会终止。</p>
<p>Remember, each rule needs to match expressions at that precedence level <em>or
higher</em>, so we also need to let this match a primary expression.
请记住，每个规则都需要匹配该优先级或更高优先级的表达式，因此我们还需要使其与主表达式匹配。</p>
<div class="codehilite"><pre><span class="i">unary</span>          → ( <span class="s">&quot;!&quot;</span> | <span class="s">&quot;-&quot;</span> ) <span class="i">unary</span>
               | <span class="i">primary</span> ;
</pre></div>
<p>That works.
这样就可以了。</p>
<p>The remaining rules are all binary operators. We&rsquo;ll start with the rule for
multiplication and division. Here&rsquo;s a first try:
剩下的规则就是二元运算符。我们先从乘法和除法的规则开始。下面是第一次尝试：</p>
<div class="codehilite"><pre><span class="i">factor</span>         → <span class="i">factor</span> ( <span class="s">&quot;/&quot;</span> | <span class="s">&quot;*&quot;</span> ) <span class="i">unary</span>
               | <span class="i">unary</span> ;
</pre></div>
<p>The rule recurses to match the left operand. That enables the rule to match a
series of multiplication and division expressions like <code>1 * 2 / 3</code>. Putting the
recursive production on the left side and <code>unary</code> on the right makes the rule
<span name="mult">left-associative</span> and unambiguous.
该规则递归匹配左操作数，这样一来，就可以匹配一系列乘法和除法表达式，例如 <code>1 * 2 / 3</code>。将递归生成式放在左侧并将<code>unary</code> 放在右侧，可以使该规则具有左关联性和明确性。</p>
<aside name="mult">
<p>In principle, it doesn&rsquo;t matter whether you treat multiplication as left- or
right-associative<span class="em">&mdash;</span>you get the same result either way. Alas, in the real world
with limited precision, roundoff and overflow mean that associativity can affect
the result of a sequence of multiplications. Consider:</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="n">0.1</span> * (<span class="n">0.2</span> * <span class="n">0.3</span>);
<span class="k">print</span> (<span class="n">0.1</span> * <span class="n">0.2</span>) * <span class="n">0.3</span>;
</pre></div>
<p>In languages like Lox that use <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 754</a> double-precision floating-point
numbers, the first evaluates to <code>0.006</code>, while the second yields
<code>0.006000000000000001</code>. Sometimes that tiny difference matters.
<a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">This</a> is a good place to learn more.</p>
</aside>
<p>All of this is correct, but the fact that the first symbol in the body of the
rule is the same as the head of the rule means this production is
<strong>left-recursive</strong>. Some parsing techniques, including the one we&rsquo;re going to
use, have trouble with left recursion. (Recursion elsewhere, like we have in
<code>unary</code> and the indirect recursion for grouping in <code>primary</code> are not a problem.)
所有这些都是正确的，但规则主体中的第一个符号与规则头部相同意味着这个生成式是<strong>左递归</strong>的。一些解析技术，包括我们将要使用的解析技术，在处理左递归时会遇到问题。(其他地方的递归，比如在<code>unary</code>中，以及在<code>primary</code>分组中的间接递归都不是问题。)</p>
<p>There are many grammars you can define that match the same language. The choice
for how to model a particular language is partially a matter of taste and
partially a pragmatic one. This rule is correct, but not optimal for how we
intend to parse it. Instead of a left recursive rule, we&rsquo;ll use a different one.
你可以定义很多符合同一种语言的语法。如何对某一特定语言进行建模，一部分是品味问题，一部分是实用主义问题。这个规则是正确的，但对于我们后续的解析来说它并不是最优的。我们将使用不同的规则来代替左递归规则。</p>
<div class="codehilite"><pre><span class="i">factor</span>         → <span class="i">unary</span> ( ( <span class="s">&quot;/&quot;</span> | <span class="s">&quot;*&quot;</span> ) <span class="i">unary</span> )* ;
</pre></div>
<p>We define a factor expression as a flat <em>sequence</em> of multiplications
and divisions. This matches the same syntax as the previous rule, but better
mirrors the code we&rsquo;ll write to parse Lox. We use the same structure for all of
the other binary operator precedence levels, giving us this complete expression
grammar:
我们将因子表达式定义为乘法和除法的扁平<em>序列</em>。这与前面的规则语法相同，但更好地反映了我们将编写的解析Lox的代码。我们对其它二元运算符的优先级使用相同的结构，从而得到下面这个完整的表达式语法：
This grammar is more complex than the one we had before, but in return we have eliminated the previous one’s ambiguity. It’s just what we need to make a parser.
这个语法比我们以前的那个更复杂，但反过来我们也消除了前一个语法定义中的歧义。这正是我们制作解析器时所需要的。</p>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">equality</span> ;
<span class="i">equality</span>       → <span class="i">comparison</span> ( ( <span class="s">&quot;!=&quot;</span> | <span class="s">&quot;==&quot;</span> ) <span class="i">comparison</span> )* ;
<span class="i">comparison</span>     → <span class="i">term</span> ( ( <span class="s">&quot;&gt;&quot;</span> | <span class="s">&quot;&gt;=&quot;</span> | <span class="s">&quot;&lt;&quot;</span> | <span class="s">&quot;&lt;=&quot;</span> ) <span class="i">term</span> )* ;
<span class="i">term</span>           → <span class="i">factor</span> ( ( <span class="s">&quot;-&quot;</span> | <span class="s">&quot;+&quot;</span> ) <span class="i">factor</span> )* ;
<span class="i">factor</span>         → <span class="i">unary</span> ( ( <span class="s">&quot;/&quot;</span> | <span class="s">&quot;*&quot;</span> ) <span class="i">unary</span> )* ;
<span class="i">unary</span>          → ( <span class="s">&quot;!&quot;</span> | <span class="s">&quot;-&quot;</span> ) <span class="i">unary</span>
               | <span class="i">primary</span> ;
<span class="i">primary</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">&quot;true&quot;</span> | <span class="s">&quot;false&quot;</span> | <span class="s">&quot;nil&quot;</span>
               | <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> ;
</pre></div>
<p>This grammar is more complex than the one we had before, but in return we have
eliminated the previous one&rsquo;s ambiguity. It&rsquo;s just what we need to make a
parser.</p>
<h2><a href="#recursive-descent-parsing--递归下降分析" id="recursive-descent-parsing--递归下降分析"><small>6&#8202;.&#8202;2</small>Recursive Descent Parsing  递归下降分析</a></h2>
<p>There is a whole pack of parsing techniques whose names are mostly combinations
of &ldquo;L&rdquo; and &ldquo;R&rdquo;<span class="em">&mdash;</span><a href="https://en.wikipedia.org/wiki/LL_parser">LL(k)</a>, <a href="https://en.wikipedia.org/wiki/LR_parser">LR(1)</a>, <a href="https://en.wikipedia.org/wiki/LALR_parser">LALR</a><span class="em">&mdash;</span>along with more exotic
beasts like <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinators</a>, <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parsers</a>, <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">the shunting yard
algorithm</a>, and <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">packrat parsing</a>. For our first interpreter, one
technique is more than sufficient: <strong>recursive descent</strong>.</p>
<p>Recursive descent is the simplest way to build a parser, and doesn&rsquo;t require
using complex parser generator tools like Yacc, Bison or ANTLR. All you need is
straightforward handwritten code. Don&rsquo;t be fooled by its simplicity, though.
Recursive descent parsers are fast, robust, and can support sophisticated
error handling. In fact, GCC, V8 (the JavaScript VM in Chrome), Roslyn (the C#
compiler written in C#) and many other heavyweight production language
implementations use recursive descent. It rocks.
递归下降是构建解析器最简单的方法，不需要使用复杂的解析器生成工具，如Yacc、Bison或ANTLR。你只需要直接手写代码。但是不要被它的简单性所欺骗，递归下降解析器速度快、健壮，并且可以支持复杂的错误处理。事实上，GCC、V8 (Chrome中的JavaScript VM)、Roslyn(用c#编写的c#编译器)和许多其他重量级产品语言实现都使用了递归下降技术。它很好用。</p>
<p>Recursive descent is considered a <strong>top-down parser</strong> because it starts from the
top or outermost grammar rule (here <code>expression</code>) and works its way <span
name="descent">down</span> into the nested subexpressions before finally
reaching the leaves of the syntax tree. This is in contrast with bottom-up
parsers like LR that start with primary expressions and compose them into larger
and larger chunks of syntax.
递归下降被认为是一种<strong>自顶向下解析器</strong>，因为它从最顶部或最外层的语法规则(这里是<code>expression</code>)开始，一直向下进入嵌套子表达式，最后到达语法树的叶子。这与LR等自下而上的解析器形成鲜明对比，后者从初级表达式(primary)开始，将其组成越来越大的语法块。</p>
<aside name="descent">
<p>It&rsquo;s called &ldquo;recursive <em>descent</em>&rdquo; because it walks <em>down</em> the grammar.
Confusingly, we also use direction metaphorically when talking about &ldquo;high&rdquo; and
&ldquo;low&rdquo; precedence, but the orientation is reversed. In a top-down parser, you
reach the lowest-precedence expressions first because they may in turn contain
subexpressions of higher precedence.</p><img src="image/parsing-expressions/direction.png" alt="Top-down grammar rules in order of increasing precedence." />
<p>CS people really need to get together and straighten out their metaphors. Don&rsquo;t
even get me started on which direction a stack grows or why trees have their
roots on top.</p>
</aside>
<p>A recursive descent parser is a literal translation of the grammar&rsquo;s rules
straight into imperative code. Each rule becomes a function. The body of the
rule translates to code roughly like:
递归下降解析器是一种将语法规则直接翻译成命令式代码的文本翻译器。每个规则都会变成一个函数，规则主体翻译成代码大致是这样的：
| Grammar notation | Code representation |
| | |
| Terminal | Code to match and consume a token 匹配并消费一个语法标记 |
| Nonterminal | Call to that rule’s function 调用规则对应的函数 |
| <code>|</code> | <code>if</code> or <code>switch</code> statement if或switch语句 |
| <code>*</code> or <code>+</code> | <code>while</code> or <code>for</code> loop while或for循环 |
| <code>?</code> | <code>if</code> statement if语句 |</p><table>
<thead>
<tr>
  <td>Grammar notation</td>
  <td>Code representation</td>
</tr>
</thead>
<tbody>
  <tr><td>Terminal</td><td>Code to match and consume a token</td></tr>
  <tr><td>Nonterminal</td><td>Call to that rule&rsquo;s function</td></tr>
  <tr><td><code>|</code></td><td><code>if</code> or <code>switch</code> statement</td></tr>
  <tr><td><code>*</code> or <code>+</code></td><td><code>while</code> or <code>for</code> loop</td></tr>
  <tr><td><code>?</code></td><td><code>if</code> statement</td></tr>
</tbody>
</table>
<p>The descent is described as &ldquo;recursive&rdquo; because when a grammar rule refers to
itself<span class="em">&mdash;</span>directly or indirectly<span class="em">&mdash;</span>that translates to a recursive function
call.
下降被“递归”修饰是因为，如果一个规则引用自身（直接或间接）就会变为递归的函数调用。</p>
<h3><a href="#the-parser-class--parser类" id="the-parser-class--parser类"><small>6&#8202;.&#8202;2&#8202;.&#8202;1</small>The parser class  Parser类</a></h3>
<p>Each grammar rule becomes a method inside this new class:
每个语法规则都成为新类中的一个方法:</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.List</span>;

<span class="k">import static</span> <span class="i">com.craftinginterpreters.lox.TokenType.*</span>;

<span class="k">class</span> <span class="t">Parser</span> {
  <span class="k">private</span> <span class="k">final</span> <span class="t">List</span>&lt;<span class="t">Token</span>&gt; <span class="i">tokens</span>;
  <span class="k">private</span> <span class="t">int</span> <span class="i">current</span> = <span class="n">0</span>;

  <span class="t">Parser</span>(<span class="t">List</span>&lt;<span class="t">Token</span>&gt; <span class="i">tokens</span>) {
    <span class="k">this</span>.<span class="i">tokens</span> = <span class="i">tokens</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, create new file</div>

<p>Like the scanner, the parser consumes a flat input sequence, only now we&rsquo;re
reading tokens instead of characters. We store the list of tokens and use
<code>current</code> to point to the next token eagerly waiting to be parsed.
与扫描器一样，解析器也是消费一个扁平的输入序列，只是这次我们要读取的是语法标记而不是字符。我们会保存标记列表并使用<code>current</code>指向待解析的下一个标记。</p>
<p>We&rsquo;re going to run straight through the expression grammar now and translate
each rule to Java code. The first rule, <code>expression</code>, simply expands to the
<code>equality</code> rule, so that&rsquo;s straightforward.
我们现在要直接执行表达式语法，并将每一条规则翻译为Java代码。第一条规则<code>expression</code>，简单地展开为<code>equality</code>规则，所以很直接：
<u><em>lox/Parser.java，在 Parser()方法添加：</em></u></p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>Parser</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">expression</span>() {
    <span class="k">return</span> <span class="i">equality</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>Parser</em>()</div>

<p>Each method for parsing a grammar rule produces a syntax tree for that rule and
returns it to the caller. When the body of the rule contains a nonterminal<span class="em">&mdash;</span>a
reference to another rule<span class="em">&mdash;</span>we <span name="left">call</span> that other rule&rsquo;s
method.
每个解析语法规则的方法都会生成该规则对应的语法树，并将其返回给调用者。当规则主体中包含一个非终止符——对另一条规则的引用时，我们就会调用另一条规则对应的方法。</p>
<aside name="left">
<p>This is why left recursion is problematic for recursive descent. The function
for a left-recursive rule immediately calls itself, which calls itself again,
and so on, until the parser hits a stack overflow and dies.</p>
</aside>
<p>The rule for equality is a little more complex.
<code>equality</code>规则有一点复杂：</p>
<div class="codehilite"><pre><span class="i">equality</span>       → <span class="i">comparison</span> ( ( <span class="s">&quot;!=&quot;</span> | <span class="s">&quot;==&quot;</span> ) <span class="i">comparison</span> )* ;
</pre></div>
<p>In Java, that becomes:
在Java中，这会变成：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>expression</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">equality</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">comparison</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">BANG_EQUAL</span>, <span class="i">EQUAL_EQUAL</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">comparison</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expression</em>()</div>

<p>Let&rsquo;s step through it. The first <code>comparison</code> nonterminal in the body translates
to the first call to <code>comparison()</code> in the method. We take that result and store
it in a local variable.
让我们一步步来。规则体中的第一个<code>comparison</code>非终止符变成了方法中对 <code>comparison()</code>的第一次调用。我们获取结果并将其保存在一个局部变量中。</p>
<p>Then, the <code>( ... )*</code> loop in the rule maps to a <code>while</code> loop. We need to know
when to exit that loop. We can see that inside the rule, we must first find
either a <code>!=</code> or <code>==</code> token. So, if we <em>don&rsquo;t</em> see one of those, we must be done
with the sequence of equality operators. We express that check using a handy
<code>match()</code> method.
然后，规则中的<code>( ... )*</code>循环映射为一个<code>while</code>循环。我们需要知道何时退出这个循环。可以看到，在规则体中，我们必须先找到一个<code>!=</code> 或<code>==</code>标记。因此，如果我们<em>没有</em>看到其中任一标记，我们必须结束相等(不相等)运算符的序列。我们使用一个方便的<code>match()</code>方法来执行这个检查。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>equality</em>()</div>
<pre>  <span class="k">private</span> <span class="t">boolean</span> <span class="i">match</span>(<span class="t">TokenType</span>... <span class="i">types</span>) {
    <span class="k">for</span> (<span class="t">TokenType</span> <span class="i">type</span> : <span class="i">types</span>) {
      <span class="k">if</span> (<span class="i">check</span>(<span class="i">type</span>)) {
        <span class="i">advance</span>();
        <span class="k">return</span> <span class="k">true</span>;
      }
    }

    <span class="k">return</span> <span class="k">false</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>equality</em>()</div>

<p>This checks to see if the current token has any of the given types. If so, it
consumes the token and returns <code>true</code>. Otherwise, it returns <code>false</code> and leaves
the current token alone. The <code>match()</code> method is defined in terms of two more
fundamental operations.
这个检查会判断当前的标记是否属于给定的类型之一。如果是，则消费该标记并返回<code>true</code>；否则，就返回<code>false</code>并保留当前标记。<code>match()</code>方法是由两个更基本的操作来定义的。</p>
<p>The <code>check()</code> method returns <code>true</code> if the current token is of the given type.
Unlike <code>match()</code>, it never consumes the token, it only looks at it.
如果当前标记属于给定类型，则<code>check()</code>方法返回<code>true</code>。与<code>match()</code>不同的是，它从不消费标记，只是读取。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>match</em>()</div>
<pre>  <span class="k">private</span> <span class="t">boolean</span> <span class="i">check</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
    <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="k">false</span>;
    <span class="k">return</span> <span class="i">peek</span>().<span class="i">type</span> == <span class="i">type</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>match</em>()</div>

<p>The <code>advance()</code> method consumes the current token and returns it, similar to how
our scanner&rsquo;s corresponding method crawled through characters.
<code>advance()</code>方法会消费当前的标记并返回它，类似于扫描器中对应方法处理字符的方式。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>check</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Token</span> <span class="i">advance</span>() {
    <span class="k">if</span> (!<span class="i">isAtEnd</span>()) <span class="i">current</span>++;
    <span class="k">return</span> <span class="i">previous</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>check</em>()</div>

<p>These methods bottom out on the last handful of primitive operations.
这些方法最后都归结于几个基本操作。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>advance</em>()</div>
<pre>  <span class="k">private</span> <span class="t">boolean</span> <span class="i">isAtEnd</span>() {
    <span class="k">return</span> <span class="i">peek</span>().<span class="i">type</span> == <span class="i">EOF</span>;
  }

  <span class="k">private</span> <span class="t">Token</span> <span class="i">peek</span>() {
    <span class="k">return</span> <span class="i">tokens</span>.<span class="i">get</span>(<span class="i">current</span>);
  }

  <span class="k">private</span> <span class="t">Token</span> <span class="i">previous</span>() {
    <span class="k">return</span> <span class="i">tokens</span>.<span class="i">get</span>(<span class="i">current</span> - <span class="n">1</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>advance</em>()</div>

<p><code>isAtEnd()</code> checks if we&rsquo;ve run out of tokens to parse. <code>peek()</code> returns the
current token we have yet to consume, and <code>previous()</code> returns the most recently
consumed token. The latter makes it easier to use <code>match()</code> and then access the
just-matched token.
<code>isAtEnd()</code>检查我们是否处理完了待解析的标记。<code>peek()</code>方法返回我们还未消费的当前标记，而<code>previous()</code>会返回最近消费的标记。后者让我们更容易使用<code>match()</code>，然后访问刚刚匹配的标记。</p>
<p>That&rsquo;s most of the parsing infrastructure we need. Where were we? Right, so if
we are inside the <code>while</code> loop in <code>equality()</code>, then we know we have found a
<code>!=</code> or <code>==</code> operator and must be parsing an equality expression.
这就是我们需要的大部分解析基本工具。我们说到哪里了？对，如果我们在<code>equality()</code>的<code>while</code>循环中，也就能知道我们已经找到了一个<code>!=</code>或<code>==</code>操作符，并且一定是在解析一个等式表达式。</p>
<p>We grab the matched operator token so we can track which kind of equality
expression we have. Then we call <code>comparison()</code> again to parse the right-hand
operand. We combine the operator and its two operands into a new <code>Expr.Binary</code>
syntax tree node, and then loop around. For each iteration, we store the
resulting expression back in the same <code>expr</code> local variable. As we zip through a
sequence of equality expressions, that creates a left-associative nested tree of
binary operator nodes.
我们获取到匹配的操作符标记，这样就可以知道我们要处理哪一类等式表达式。之后，我们再次调用<code>comparison()</code>解析右边的操作数。我们将操作符和它的两个操作数组合成一个新的<code>Expr.Binary</code>语法树节点，然后开始循环。对于每一次迭代，我们都将结果表达式存储在同一个<code>expr</code>局部变量中。在对等式表达式序列进行压缩时，会创建一个由二元操作符节点组成的左结合嵌套树。</p>
<p><span name="sequence"></span></p><img src="image/parsing-expressions/sequence.png" alt="The syntax tree created by parsing 'a == b == c == d == e'" />
<aside name="sequence">
<p>Parsing <code>a == b == c == d == e</code>. For each iteration, we create a new binary
expression using the previous one as the left operand.</p>
</aside>
<p>The parser falls out of the loop once it hits a token that&rsquo;s not an equality
operator. Finally, it returns the expression. Note that if the parser never
encounters an equality operator, then it never enters the loop. In that case,
the <code>equality()</code> method effectively calls and returns <code>comparison()</code>. In that
way, this method matches an equality operator <em>or anything of higher
precedence</em>.
一旦解析器遇到一个不是等式操作符的标记，就会退出循环。最后，它会返回对应的表达式。请注意，如果解析器从未遇到过等式操作符，它就永远不会进入循环。在这种情况下，<code>equality()</code>方法有效地调用并返回<code>comparison()</code>。这样一来，这个方法就会匹配一个等式运算符或<em>任何更高优先级的表达式</em>。</p>
<p>Moving on to the next rule<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>
继续看下一个规则。</p>
<div class="codehilite"><pre><span class="i">comparison</span>     → <span class="i">term</span> ( ( <span class="s">&quot;&gt;&quot;</span> | <span class="s">&quot;&gt;=&quot;</span> | <span class="s">&quot;&lt;&quot;</span> | <span class="s">&quot;&lt;=&quot;</span> ) <span class="i">term</span> )* ;
</pre></div>
<p>Translated to Java:
翻译成Java：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>equality</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">comparison</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">term</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">GREATER</span>, <span class="i">GREATER_EQUAL</span>, <span class="i">LESS</span>, <span class="i">LESS_EQUAL</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">term</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>equality</em>()</div>

<p>The grammar rule is virtually <span name="handle">identical</span> to <code>equality</code>
and so is the corresponding code. The only differences are the token types for
the operators we match, and the method we call for the operands<span class="em">&mdash;</span>now
<code>term()</code> instead of <code>comparison()</code>. The remaining two binary operator rules
follow the same pattern.
语法规则与<code>equality</code>几乎完全相同，相应的代码也是如此。唯一的区别是匹配的操作符的标记类型，而且现在获取操作数时调用的方法是<code>term()</code>而不是<code>comparison()</code>。其余两个二元操作符规则遵循相同的模式。</p>
<p>In order of precedence, first addition and subtraction:
按照优先级顺序，先做加减法：</p>
<aside name="handle">
<p>If you wanted to do some clever Java 8, you could create a helper method for
parsing a left-associative series of binary operators given a list of token
types, and an operand method handle to simplify this redundant code.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>comparison</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">term</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">factor</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">MINUS</span>, <span class="i">PLUS</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">factor</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>comparison</em>()</div>

<p>And finally, multiplication and division:
最后，是乘除法：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>term</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">factor</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">unary</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">SLASH</span>, <span class="i">STAR</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">unary</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>term</em>()</div>

<p>That&rsquo;s all of the binary operators, parsed with the correct precedence and
associativity. We&rsquo;re crawling up the precedence hierarchy and now we&rsquo;ve reached
the unary operators.
这就是所有的二元运算符，已经按照正确的优先级和结合性进行了解析。接下来，按照优先级层级，我们要处理一元运算符了。</p>
<div class="codehilite"><pre><span class="i">unary</span>          → ( <span class="s">&quot;!&quot;</span> | <span class="s">&quot;-&quot;</span> ) <span class="i">unary</span>
               | <span class="i">primary</span> ;
</pre></div>
<p>The code for this is a little different.
该规则对应的代码有些不同。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>factor</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">unary</span>() {
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">BANG</span>, <span class="i">MINUS</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">unary</span>();
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Unary</span>(<span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">primary</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>factor</em>()</div>

<p>Again, we look at the <span name="current">current</span> token to see how to
parse. If it&rsquo;s a <code>!</code> or <code>-</code>, we must have a unary expression. In that case, we
grab the token and then recursively call <code>unary()</code> again to parse the operand.
Wrap that all up in a unary expression syntax tree and we&rsquo;re done.
同样的，我们先检查当前的标记以确认要如何进行解析。如果是<code>!</code>或<code>-</code>，我们一定有一个一元表达式。在这种情况下，我们使用当前的标记递归调用<code>unary()</code>来解析操作数。将所有这些都包装到一元表达式语法树中，我们就完成了。</p>
<aside name="current">
<p>The fact that the parser looks ahead at upcoming tokens to decide how to parse
puts recursive descent into the category of <strong>predictive parsers</strong>.</p>
</aside>
<p>Otherwise, we must have reached the highest level of precedence, primary
expressions.
否则，我们就达到了最高级别的优先级，即基本表达式。</p>
<div class="codehilite"><pre><span class="i">primary</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">&quot;true&quot;</span> | <span class="s">&quot;false&quot;</span> | <span class="s">&quot;nil&quot;</span>
               | <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> ;
</pre></div>
<p>Most of the cases for the rule are single terminals, so parsing is
straightforward.
该规则中大部分都是终止符，可以直接进行解析。</p>
<ul>
<li></li>
</ul>
<p>The interesting branch is the one for handling parentheses. After we match an opening <code>(</code> and parse the expression inside it, we <em>must</em> find a <code>)</code> token. If we don’t, that’s an error.
有趣的一点是处理括号的分支。当我们匹配了一个开头<code>(</code>并解析了里面的表达式后，我们必须找到一个<code>)</code>标记。如果没有找到，那就是一个错误。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>unary</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">primary</span>() {
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">FALSE</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">false</span>);
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">TRUE</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">true</span>);
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">NIL</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">null</span>);

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">NUMBER</span>, <span class="i">STRING</span>)) {
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="i">previous</span>().<span class="i">literal</span>);
    }

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">LEFT_PAREN</span>)) {
      <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">expression</span>();
      <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after expression.&quot;</span>);
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Grouping</span>(<span class="i">expr</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>unary</em>()</div>

<p>The interesting branch is the one for handling parentheses. After we match an
opening <code>(</code> and parse the expression inside it, we <em>must</em> find a <code>)</code> token. If
we don&rsquo;t, that&rsquo;s an error.</p>
<h2><a href="#syntax-errors--语法错误" id="syntax-errors--语法错误"><small>6&#8202;.&#8202;3</small>Syntax Errors  语法错误</a></h2>
<p>A parser really has two jobs:
解析器实际上有两项工作：</p>
<ol>
<li>
<blockquote>
<p>Given a valid sequence of tokens, produce a corresponding syntax tree.
给定一个有效的标记序列，生成相应的语法树。</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Given an <em>invalid</em> sequence of tokens, detect any errors and tell the user about their mistakes.
给定一个<em>无效</em>的标记序列，检测错误并告知用户。</p>
</blockquote>
</li>
<li>
<p>Given a valid sequence of tokens, produce a corresponding syntax tree.</p>
</li>
<li>
<p>Given an <em>invalid</em> sequence of tokens, detect any errors and tell the
user about their mistakes.</p>
</li>
</ol>
<p>Don&rsquo;t underestimate how important the second job is! In modern IDEs and editors,
the parser is constantly reparsing code<span class="em">&mdash;</span>often while the user is still editing
it<span class="em">&mdash;</span>in order to syntax highlight and support things like auto-complete. That
means it will encounter code in incomplete, half-wrong states <em>all the time.</em>
不要低估第二项工作的重要性！在现代的IDE和编辑器中，为了语法高亮显示和支持自动补齐等功能，当用户还在编辑代码时，解析器就会不断地重新解析代码。这也意味着解析器<em>总是</em>会遇到不完整的、半错误状态的代码。</p>
<p>When the user doesn&rsquo;t realize the syntax is wrong, it is up to the parser to
help guide them back onto the right path. The way it reports errors is a large
part of your language&rsquo;s user interface. Good syntax error handling is hard. By
definition, the code isn&rsquo;t in a well-defined state, so there&rsquo;s no infallible way
to know what the user <em>meant</em> to write. The parser can&rsquo;t read your <span
name="telepathy">mind</span>.
当用户没有意识到语法错误时，解析器要帮助引导他们回到正确的道路上。在你的语言的人机交互中，错误反馈占据了很大的比重。良好的语法错误处理是很难的。根据定义，代码并不是处于良好定义的状态，所以没有可靠的方法能够知道用户<em>想要</em>写什么。解析器无法读懂你的思想。</p>
<aside name="telepathy">
<p>Not yet at least. With the way things are going in machine learning these days,
who knows what the future will bring?</p>
</aside>
<p>There are a couple of hard requirements for when the parser runs into a syntax
error. A parser must:
当解析器遇到语法错误时，有几个硬性要求。解析器必须能够：</p>
<ul>
<li>
<blockquote>
<p><strong>Detect and report the error.</strong> If it doesn’t detect the error and passes the resulting malformed syntax tree on to the interpreter, all manner of horrors may be summoned.
**检测并报告错误。**如果它没有检测到错误，并将由此产生的畸形语法树传递给解释器，就会出现各种可怕的情况。</p>
</blockquote>
</li>
<li>
<blockquote>
<p><strong>Avoid crashing or hanging.</strong> Syntax errors are a fact of life, and language tools have to be robust in the face of them. Segfaulting or getting stuck in an infinite loop isn’t allowed. While the source may not be valid <em>code</em>, it’s still a valid <em>input to the parser</em> because users use the parser to learn what syntax is allowed.
**避免崩溃或挂起。**语法错误是生活中不可避免的事实，面对语法错误，语言工具必须非常健壮。段错误或陷入无限循环是不允许的。虽然源代码可能不是有效的<em>代码</em>，但它仍然是<em>解析器的有效输入</em>，因为用户使用解析器来了解什么是允许的语法。</p>
</blockquote>
</li>
</ul>
<ul>
<li>
<p><strong>Detect and report the error.</strong> If it doesn&rsquo;t detect the <span
name="error">error</span> and passes the resulting malformed syntax tree on
to the interpreter, all manner of horrors may be summoned.</p>
<aside name="error">
<p>Philosophically speaking, if an error isn&rsquo;t detected and the interpreter
runs the code, is it <em>really</em> an error?</p>
</aside></li>
<li>
<p><strong>Avoid crashing or hanging.</strong> Syntax errors are a fact of life, and
language tools have to be robust in the face of them. Segfaulting or getting
stuck in an infinite loop isn&rsquo;t allowed. While the source may not be valid
<em>code</em>, it&rsquo;s still a valid <em>input to the parser</em> because users use the
parser to learn what syntax is allowed.</p>
</li>
</ul>
<p>Those are the table stakes if you want to get in the parser game at all, but you
really want to raise the ante beyond that. A decent parser should:
如果你想参与到解析器的游戏中来，这些就是桌面的筹码，但你真的想提高赌注，除了这些。一个像样的解析器还应该：</p>
<ul>
<li>
<blockquote>
<p><strong>Be fast.</strong> Computers are thousands of times faster than they were when parser technology was first invented. The days of needing to optimize your parser so that it could get through an entire source file during a coffee break are over. But programmer expectations have risen as quickly, if not faster. They expect their editors to reparse files in milliseconds after every keystroke.
**要快。**计算机的速度比最初发明解析器技术时快了几千倍。那种需要优化解析器，以便它能在喝咖啡的时候处理完整个源文件的日子已经一去不复返了。但是程序员的期望值也上升得同样快，甚至更快。他们希望他们的编辑器能在每次击键后的几毫秒内回复文件。</p>
</blockquote>
</li>
<li>
<blockquote>
<p><strong>Report as many distinct errors as there are.</strong> Aborting after the first error is easy to implement, but it’s annoying for users if every time they fix what they think is the one error in a file, a new one appears. They want to see them all.
<strong>尽可能多地报告出不同的错误</strong>。在第一个错误后中止是很容易实现的，但是如果每次当用户修复文件中的一个错误时，又出现了另一个新的错误，这对用户来说是很烦人的。他们希望一次看到所有的错误。</p>
</blockquote>
</li>
<li>
<blockquote>
<p><strong>Minimize *cascaded* errors.</strong> Once a single error is found, the parser no longer really knows what’s going on. It tries to get itself back on track and keep going, but if it gets confused, it may report a slew of ghost errors that don’t indicate other real problems in the code. When the first error is fixed, those phantoms disappear, because they reflect only the parser’s own confusion. Cascaded errors are annoying because they can scare the user into thinking their code is in a worse state than it is.
<strong>最小化<em>级联</em>错误</strong>。一旦发现一个错误，解析器就不再能知道发生了什么。它会试图让自己回到正轨并继续工作，但如果它感到混乱，它可能会报告大量的幽灵错误，而这些错误并不表明代码中存在其它问题。当第一个错误被修正后，这些幽灵错误就消失了，因为它们只反映了解析器自身的混乱。级联错误很烦人，因为它们会让用户害怕，让用户认为自己的代码比实际情况更糟糕。</p>
</blockquote>
</li>
</ul>
<ul>
<li>
<p><strong>Be fast.</strong> Computers are thousands of times faster than they were when
parser technology was first invented. The days of needing to optimize your
parser so that it could get through an entire source file during a coffee
break are over. But programmer expectations have risen as quickly, if not
faster. They expect their editors to reparse files in milliseconds after
every keystroke.</p>
</li>
<li>
<p><strong>Report as many distinct errors as there are.</strong> Aborting after the first
error is easy to implement, but it&rsquo;s annoying for users if every time they
fix what they think is the one error in a file, a new one appears. They
want to see them all.</p>
</li>
<li>
<p><strong>Minimize <em>cascaded</em> errors.</strong> Once a single error is found, the parser no
longer really knows what&rsquo;s going on. It tries to get itself back on track
and keep going, but if it gets confused, it may report a slew of ghost
errors that don&rsquo;t indicate other real problems in the code. When the first
error is fixed, those phantoms disappear, because they reflect only the
parser&rsquo;s own confusion. Cascaded errors are annoying because they can scare
the user into thinking their code is in a worse state than it is.</p>
</li>
</ul>
<p>The last two points are in tension. We want to report as many separate errors as
we can, but we don&rsquo;t want to report ones that are merely side effects of an
earlier one.
最后两点是相互矛盾的。我们希望尽可能多地报告单独的错误，但我们不想报告那些只是由早期错误的副作用导致的错误。</p>
<p>The way a parser responds to an error and keeps going to look for later errors
is called <strong>error recovery</strong>. This was a hot research topic in the &rsquo;60s. Back
then, you&rsquo;d hand a stack of punch cards to the secretary and come back the next
day to see if the compiler succeeded. With an iteration loop that slow, you
<em>really</em> wanted to find every single error in your code in one pass.
解析器对一个错误做出反应，并继续去寻找后面的错误的方式叫做<strong>错误恢复</strong>。这在60年代是一个热门的研究课题。那时，你需要把一叠打孔卡交给秘书，第二天再来看看编译器是否成功。在迭代循环如此缓慢的情况下，你真的会想在一次执行中找到代码中的每个错误。</p>
<p>Today, when parsers complete before you&rsquo;ve even finished typing, it&rsquo;s less of an
issue. Simple, fast error recovery is fine.
如今，解析器在您甚至还没有完成输入之前就完成解析了，这不再是一个问题。 简单，快速的错误恢复就可以了。</p>
<h3><a href="#panic-mode-error-recovery--恐慌模式错误恢复" id="panic-mode-error-recovery--恐慌模式错误恢复"><small>6&#8202;.&#8202;3&#8202;.&#8202;1</small>Panic mode error recovery  恐慌模式错误恢复</a></h3>
<aside name="panic">
<p>You know you want to push it.</p><img src="image/parsing-expressions/panic.png" alt="A big shiny 'PANIC' button." />
</aside>
<p>Of all the recovery techniques devised in yesteryear, the one that best stood
the test of time is called<span class="em">&mdash;</span>somewhat alarmingly<span class="em">&mdash;</span><span name="panic"><strong>panic
mode</strong></span>. As soon as the parser detects an error, it enters panic mode. It
knows at least one token doesn&rsquo;t make sense given its current state in the
middle of some stack of grammar productions.
在过去设计的所有恢复技术中，最能经受住时间考验的一种叫做<strong>恐慌模式</strong>（有点令人震惊）。一旦解析器检测到一个错误，它就会进入恐慌模式。它知道至少有一个token是没有意义的，因为它目前的状态是在一些语法生成式的堆栈中间。</p>
<p>Before it can get back to parsing, it needs to get its state and the sequence of
forthcoming tokens aligned such that the next token does match the rule being
parsed. This process is called <strong>synchronization</strong>.
在程序继续进行解析之前，它需要将自己的状态和即将到来的标记序列对齐，使下一个标记能够匹配正则解析的规则。这个过程称为<strong>同步</strong>。</p>
<p>To do that, we select some rule in the grammar that will mark the
synchronization point. The parser fixes its parsing state by jumping out of any
nested productions until it gets back to that rule. Then it synchronizes the
token stream by discarding tokens until it reaches one that can appear at that
point in the rule.
为此，我们在语法中选择一些规则来标记同步点。解析器会跳出所有嵌套的生成式直到回退至该规则中，来修复其解析状态。然后，它会丢弃标记，直到遇到一个可以匹配该规则的标记，以此来同步标记流。</p>
<p>Any additional real syntax errors hiding in those discarded tokens aren&rsquo;t
reported, but it also means that any mistaken cascaded errors that are side
effects of the initial error aren&rsquo;t <em>falsely</em> reported either, which is a decent
trade-off.
这些被丢弃的标记中隐藏的其它真正的语法错误都不会被报告，但是这也意味着由初始错误引起的其它级联错误也不会被<em>错误地</em>报告出来，这是个不错的权衡。</p>
<p>The traditional place in the grammar to synchronize is between statements. We
don&rsquo;t have those yet, so we won&rsquo;t actually synchronize in this chapter, but
we&rsquo;ll get the machinery in place for later.
语法中传统的要同步的地方是语句之间。我们还没有这些，所以我们不会在这一章中真正地同步，但我们会在以后把这些机制准备好。</p>
<h3><a href="#entering-panic-mode--进入恐慌模式" id="entering-panic-mode--进入恐慌模式"><small>6&#8202;.&#8202;3&#8202;.&#8202;2</small>Entering panic mode  进入恐慌模式</a></h3>
<p>Back before we went on this side trip around error recovery, we were writing the
code to parse a parenthesized expression. After parsing the expression, the
parser looks for the closing <code>)</code> by calling <code>consume()</code>. Here, finally, is that
method:
在我们讨论错误恢复之前，我们正在编写解析括号表达式的代码。在解析表达式之后，会调用<code>consume()</code>方法查找收尾的<code>)</code>。这里，终于可以实现那个方法了：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>match</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Token</span> <span class="i">consume</span>(<span class="t">TokenType</span> <span class="i">type</span>, <span class="t">String</span> <span class="i">message</span>) {
    <span class="k">if</span> (<span class="i">check</span>(<span class="i">type</span>)) <span class="k">return</span> <span class="i">advance</span>();

    <span class="k">throw</span> <span class="i">error</span>(<span class="i">peek</span>(), <span class="i">message</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>match</em>()</div>

<p>It&rsquo;s similar to <code>match()</code> in that it checks to see if the next token is of the
expected type. If so, it consumes the token and everything is groovy. If some
other token is there, then we&rsquo;ve hit an error. We report it by calling this:
它和 <code>match()</code>方法类似，检查下一个标记是否是预期的类型。如果是，它就会消费该标记，一切都很顺利。如果是其它的标记，那么我们就遇到了错误。我们通过调用下面的方法来报告错误：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>previous</em>()</div>
<pre>  <span class="k">private</span> <span class="t">ParseError</span> <span class="i">error</span>(<span class="t">Token</span> <span class="i">token</span>, <span class="t">String</span> <span class="i">message</span>) {
    <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">token</span>, <span class="i">message</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">ParseError</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>previous</em>()</div>

<p>First, that shows the error to the user by calling:
首先，通过调用下面的方法向用户展示错误信息：</p>
<div class="codehilite"><div class="source-file"><em>lox/Lox.java</em><br>
add after <em>report</em>()</div>
<pre>  <span class="k">static</span> <span class="t">void</span> <span class="i">error</span>(<span class="t">Token</span> <span class="i">token</span>, <span class="t">String</span> <span class="i">message</span>) {
    <span class="k">if</span> (<span class="i">token</span>.<span class="i">type</span> == <span class="t">TokenType</span>.<span class="i">EOF</span>) {
      <span class="i">report</span>(<span class="i">token</span>.<span class="i">line</span>, <span class="s">&quot; at end&quot;</span>, <span class="i">message</span>);
    } <span class="k">else</span> {
      <span class="i">report</span>(<span class="i">token</span>.<span class="i">line</span>, <span class="s">&quot; at &#39;&quot;</span> + <span class="i">token</span>.<span class="i">lexeme</span> + <span class="s">&quot;&#39;&quot;</span>, <span class="i">message</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, add after <em>report</em>()</div>

<p>This reports an error at a given token. It shows the token&rsquo;s location and the
token itself. This will come in handy later since we use tokens throughout the
interpreter to track locations in code.
该方法会报告给定标记处的错误。它显示了标记的位置和标记本身。这在以后会派上用场，因为我们在整个解释器中使用标记来跟踪代码中的位置。</p>
<p>After we report the error, the user knows about their mistake, but what does the
<em>parser</em> do next? Back in <code>error()</code>, we create and return a ParseError, an
instance of this new class:
在我们报告错误后，用户知道了他们的错误，但接下来解析器要做什么呢？回到<code>error()</code>方法中，我们创建并返回了一个<code>ParseError</code>，是下面这个新类的实例:</p>
<div class="codehilite"><pre class="insert-before">class Parser {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
nest inside class <em>Parser</em></div>
<pre class="insert">  <span class="k">private</span> <span class="k">static</span> <span class="k">class</span> <span class="t">ParseError</span> <span class="k">extends</span> <span class="t">RuntimeException</span> {}

</pre><pre class="insert-after">  private final List&lt;Token&gt; tokens;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, nest inside class <em>Parser</em></div>

<p>This is a simple sentinel class we use to unwind the parser. The <code>error()</code>
method <em>returns</em> the error instead of <em>throwing</em> it because we want to let the
calling method inside the parser decide whether to unwind or not. Some parse
errors occur in places where the parser isn&rsquo;t likely to get into a weird state
and we don&rsquo;t need to <span name="production">synchronize</span>. In those
places, we simply report the error and keep on truckin&rsquo;.
这是一个简单的哨兵类，我们用它来帮助解析器摆脱错误。<code>error()</code>方法是<em>返回</em>错误而不是<em>抛出</em>错误，因为我们希望解析器内的调用方法决定是否要跳脱出该错误。有些解析错误发生在解析器不可能进入异常状态的地方，这时我们就不需要同步。在这些地方，我们只需要报告错误，然后继续解析。</p>
<p>For example, Lox limits the number of arguments you can pass to a function. If
you pass too many, the parser needs to report that error, but it can and should
simply keep on parsing the extra arguments instead of freaking out and going
into panic mode.
例如，Lox限制了你可以传递给一个函数的参数数量。如果你传递的参数太多，解析器需要报告这个错误，但它可以而且应该继续解析额外的参数，而不是惊慌失措，进入恐慌模式。</p>
<aside name="production">
<p>Another way to handle common syntax errors is with <strong>error productions</strong>. You
augment the grammar with a rule that <em>successfully</em> matches the <em>erroneous</em>
syntax. The parser safely parses it but then reports it as an error instead of
producing a syntax tree.</p>
<p>For example, some languages have a unary <code>+</code> operator, like <code>+123</code>, but Lox does
not. Instead of getting confused when the parser stumbles onto a <code>+</code> at the
beginning of an expression, we could extend the unary rule to allow it.</p>
<div class="codehilite"><pre><span class="i">unary</span> → ( <span class="s">&quot;!&quot;</span> | <span class="s">&quot;-&quot;</span> | <span class="s">&quot;+&quot;</span> ) <span class="i">unary</span>
      | <span class="i">primary</span> ;
</pre></div>
<p>This lets the parser consume <code>+</code> without going into panic mode or leaving the
parser in a weird state.</p>
<p>Error productions work well because you, the parser author, know <em>how</em> the code
is wrong and what the user was likely trying to do. That means you can give a
more helpful message to get the user back on track, like, &ldquo;Unary &lsquo;+&rsquo; expressions
are not supported.&rdquo; Mature parsers tend to accumulate error productions like
barnacles since they help users fix common mistakes.</p>
</aside>
<p>In our case, though, the syntax error is nasty enough that we want to panic and
synchronize. Discarding tokens is pretty easy, but how do we synchronize the
parser&rsquo;s own state?
但是，在我们的例子中，语法错误非常严重，以至于我们要进入恐慌模式并进行同步。丢弃标记非常简单，但是我们如何同步解析器自己的状态呢？</p>
<h3><a href="#synchronizing-a-recursive-descent-parser--同步递归下降解析器" id="synchronizing-a-recursive-descent-parser--同步递归下降解析器"><small>6&#8202;.&#8202;3&#8202;.&#8202;3</small>Synchronizing a recursive descent parser  同步递归下降解析器</a></h3>
<p>With recursive descent, the parser&rsquo;s state<span class="em">&mdash;</span>which rules it is in the middle of
recognizing<span class="em">&mdash;</span>is not stored explicitly in fields. Instead, we use Java&rsquo;s
own call stack to track what the parser is doing. Each rule in the middle of
being parsed is a call frame on the stack. In order to reset that state, we need
to clear out those call frames.
在递归下降中，解析器的状态（即它正在识别哪个规则）不是显式存储在字段中的。相反，我们使用Java自身的调用栈来跟踪解析器正在做什么。每一条正在被解析的规则都是栈上的一个调用帧。为了重置状态，我们需要清除这些调用帧。</p>
<p>The natural way to do that in Java is exceptions. When we want to synchronize,
we <em>throw</em> that ParseError object. Higher up in the method for the grammar rule
we are synchronizing to, we&rsquo;ll catch it. Since we synchronize on statement
boundaries, we&rsquo;ll catch the exception there. After the exception is caught, the
parser is in the right state. All that&rsquo;s left is to synchronize the tokens.
在Java中，最自然的实现方式是异常。当我们想要同步时，我们抛出ParseError对象。在我们正同步的语法规则的方法上层，我们将捕获它。因为我们在语句边界上同步，所以我们可以在那里捕获异常。捕获异常后，解析器就处于正确的状态。剩下的就是同步标记了。</p>
<p>We want to discard tokens until we&rsquo;re right at the beginning of the next
statement. That boundary is pretty easy to spot<span class="em">&mdash;</span>it&rsquo;s one of the main reasons
we picked it. <em>After</em> a semicolon, we&rsquo;re <span name="semicolon">probably</span>
finished with a statement. Most statements start with a keyword<span class="em">&mdash;</span><code>for</code>, <code>if</code>,
<code>return</code>, <code>var</code>, etc. When the <em>next</em> token is any of those, we&rsquo;re probably
about to start a statement.
我们想要丢弃标记，直至达到下一条语句的开头。这个边界很容易发现——这也是我们选其作为边界的原因。在<em>分号</em>之后，我们可能就结束了一条语句。大多数语句都通过一个关键字开头——<code>for</code>、 <code>if</code>、 <code>return</code>、 <code>var</code>等等。当下一个标记是其中之一时，我们可能就要开始一条新语句了。</p>
<aside name="semicolon">
<p>I say &ldquo;probably&rdquo; because we could hit a semicolon separating clauses in a <code>for</code>
loop. Our synchronization isn&rsquo;t perfect, but that&rsquo;s OK. We&rsquo;ve already reported
the first error precisely, so everything after that is kind of &ldquo;best effort&rdquo;.</p>
</aside>
<p>This method encapsulates that logic:
下面的方法封装了这个逻辑：</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>error</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">synchronize</span>() {
    <span class="i">advance</span>();

    <span class="k">while</span> (!<span class="i">isAtEnd</span>()) {
      <span class="k">if</span> (<span class="i">previous</span>().<span class="i">type</span> == <span class="i">SEMICOLON</span>) <span class="k">return</span>;

      <span class="k">switch</span> (<span class="i">peek</span>().<span class="i">type</span>) {
        <span class="k">case</span> <span class="i">CLASS</span>:
        <span class="k">case</span> <span class="i">FUN</span>:
        <span class="k">case</span> <span class="i">VAR</span>:
        <span class="k">case</span> <span class="i">FOR</span>:
        <span class="k">case</span> <span class="i">IF</span>:
        <span class="k">case</span> <span class="i">WHILE</span>:
        <span class="k">case</span> <span class="i">PRINT</span>:
        <span class="k">case</span> <span class="i">RETURN</span>:
          <span class="k">return</span>;
      }

      <span class="i">advance</span>();
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>error</em>()</div>

<p>It discards tokens until it thinks it has found a statement boundary. After
catching a ParseError, we&rsquo;ll call this and then we are hopefully back in sync.
When it works well, we have discarded tokens that would have likely caused
cascaded errors anyway, and now we can parse the rest of the file starting at
the next statement.
该方法会不断丢弃标记，直到它发现一个语句的边界。在捕获一个ParseError后，我们会调用该方法，然后我们就有望回到同步状态。当它工作顺利时，我们就已经丢弃了无论如何都可能会引起级联错误的语法标记，现在我们可以从下一条语句开始解析文件的其余部分。</p>
<p>Alas, we don&rsquo;t get to see this method in action, since we don&rsquo;t have statements
yet. We&rsquo;ll get to that <a href="statements-and-state.html">in a couple of chapters</a>. For now, if an
error occurs, we&rsquo;ll panic and unwind all the way to the top and stop parsing.
Since we can parse only a single expression anyway, that&rsquo;s no big loss.</p>
<h2><a href="#wiring-up-the-parser--调整解析器" id="wiring-up-the-parser--调整解析器"><small>6&#8202;.&#8202;4</small>Wiring up the Parser  调整解析器</a></h2>
<p>We are mostly done parsing expressions now. There is one other place where we
need to add a little error handling. As the parser descends through the parsing
methods for each grammar rule, it eventually hits <code>primary()</code>. If none of the
cases in there match, it means we are sitting on a token that can&rsquo;t start an
expression. We need to handle that error too.
我们现在基本上已经完成了对表达式的解析。我们还需要在另一个地方添加一些错误处理。当解析器在每个语法规则的解析方法中下降时，它最终会进入<code>primary()</code>。如果该方法中的case都不匹配，就意味着我们正面对一个不是表达式开头的语法标记。我们也需要处理这个错误。</p>
<div class="codehilite"><pre class="insert-before">    if (match(LEFT_PAREN)) {
      Expr expr = expression();
      consume(RIGHT_PAREN, &quot;Expect ')' after expression.&quot;);
      return new Expr.Grouping(expr);
    }
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>primary</em>()</div>
<pre class="insert">

    <span class="k">throw</span> <span class="i">error</span>(<span class="i">peek</span>(), <span class="s">&quot;Expect expression.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>primary</em>()</div>

<p>With that, all that remains in the parser is to define an initial method to kick
it off. That method is called, naturally enough, <code>parse()</code>.
这样，解析器中剩下的工作就是定义一个初始方法来启动它。这个方法自然应该叫做<code>parse()</code>。</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>Parser</em>()</div>
<pre>  <span class="t">Expr</span> <span class="i">parse</span>() {
    <span class="k">try</span> {
      <span class="k">return</span> <span class="i">expression</span>();
    } <span class="k">catch</span> (<span class="t">ParseError</span> <span class="i">error</span>) {
      <span class="k">return</span> <span class="k">null</span>;
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>Parser</em>()</div>

<p>We&rsquo;ll revisit this method later when we add statements to the language. For now,
it parses a single expression and returns it. We also have some temporary code
to exit out of panic mode. Syntax error recovery is the parser&rsquo;s job, so we
don&rsquo;t want the ParseError exception to escape into the rest of the interpreter.
稍后在向语言中添加语句时，我们将重新审视这个方法。目前，它只解析一个表达式并返回它。我们还有一些临时代码用于退出恐慌模式。语法错误恢复是解析器的工作，所以我们不希望ParseError异常逃逸到解释器的其它部分。</p>
<p>When a syntax error does occur, this method returns <code>null</code>. That&rsquo;s OK. The
parser promises not to crash or hang on invalid syntax, but it doesn&rsquo;t promise
to return a <em>usable syntax tree</em> if an error is found. As soon as the parser
reports an error, <code>hadError</code> gets set, and subsequent phases are skipped.
当确实出现语法错误时，该方法会返回<code>null</code>。这没关系。解析器承诺不会因为无效语法而崩溃或挂起，但它不承诺在发现错误时返回一个<em>可用的语法树</em>。一旦解析器报告错误，就会对<code>hadError</code>赋值，然后跳过后续阶段。</p>
<p>Finally, we can hook up our brand new parser to the main Lox class and try it
out. We still don&rsquo;t have an interpreter, so for now, we&rsquo;ll parse to a syntax
tree and then use the AstPrinter class from the <a href="representing-code.html#a-not-very-pretty-printer">last chapter</a> to
display it.
最后，我们可以将全新的解析器挂到Lox主类并进行试验。我们仍然还没有解释器，所以现在，我们将表达式解析为一个语法树，然后使用上一章中的AstPrinter类来显示它。</p>
<p>Delete the old code to print the scanned tokens and replace it with this:
删除打印已扫描标记的旧代码，将其替换为：</p>
<div class="codehilite"><pre class="insert-before">    List&lt;Token&gt; tokens = scanner.scanTokens();
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>run</em>()<br>
replace 5 lines</div>
<pre class="insert">    <span class="t">Parser</span> <span class="i">parser</span> = <span class="k">new</span> <span class="t">Parser</span>(<span class="i">tokens</span>);
    <span class="t">Expr</span> <span class="i">expression</span> = <span class="i">parser</span>.<span class="i">parse</span>();

    <span class="c">// Stop if there was a syntax error.</span>
    <span class="k">if</span> (<span class="i">hadError</span>) <span class="k">return</span>;

    <span class="t">System</span>.<span class="i">out</span>.<span class="i">println</span>(<span class="k">new</span> <span class="t">AstPrinter</span>().<span class="i">print</span>(<span class="i">expression</span>));
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>(), replace 5 lines</div>

<p>Congratulations, you have crossed the <span name="harder">threshold</span>! That
really is all there is to handwriting a parser. We&rsquo;ll extend the grammar in
later chapters with assignment, statements, and other stuff, but none of that is
any more complex than the binary operators we tackled here.
祝贺你，你已经跨过了门槛!这就是手写解析器的全部内容。我们将在后面的章节中扩展赋值、语句和其它特性对应的语法，但这些都不会比我们本章处理的二元操作符更复杂。</p>
<aside name="harder">
<p>It is possible to define a more complex grammar than Lox&rsquo;s that&rsquo;s difficult to
parse using recursive descent. Predictive parsing gets tricky when you may need
to look ahead a large number of tokens to figure out what you&rsquo;re sitting on.</p>
<p>In practice, most languages are designed to avoid that. Even in cases where they
aren&rsquo;t, you can usually hack around it without too much pain. If you can parse
C++ using recursive descent<span class="em">&mdash;</span>which many C++ compilers do<span class="em">&mdash;</span>you can parse
anything.</p>
</aside>
<p>Fire up the interpreter and type in some expressions. See how it handles
precedence and associativity correctly? Not bad for less than 200 lines of code.
启动解释器并输入一些表达式。查看它是如何正确处理优先级和结合性的?这对于不到200行代码来说已经很不错了。
: 英语中的&ldquo;Parse &ldquo;来自古法语 &ldquo;pars&rdquo;，意为 &ldquo;语言的一部分&ldquo;。它的意思是取一篇文章，把每一个词都映射到语言的语法上。我们在这里使用它也是这个意思，只不过我们的语言比古法语更现代一些。
: 可以想见，在那些老机器上进行汇编编程是多么痛苦，以至于他们认为Fortran是一种改进。
: 虽然现在并不常见，但有些语言规定某些运算符之间没有相对优先级。这种语言中，在表达式中混合使用这些操作符而不使用显式分组是一种语法错误。同样，有些运算符是<strong>非结合</strong>的。这意味着在语句序列中多次使用该操作符是错误的。例如，Perl的范围操作符是非结合的，所以<code>a ..b</code>是可以的，但是<code>a ..b . .c</code>是错误的。
: 一些解析器生成器并没有将优先级直接写入语法规则中，而是允许你保持同样的模糊但简单的语法，然后在旁边添加一点明确的操作符优先级元数据，以消除歧义。
: 我们可以取消<code>expression</code>，而只是在其他包含表达式的规则中使用<code>equality</code>，但使用<code>expression</code>会使这些其他规则可读性更好。另外，在后面的章节中，当我们将语法扩展到包括赋值和逻辑运算符时，我们只需要改变<code>expression</code>的生成式，而不需要修改每条包含<code>expression</code>的规则。
: 原则上，你把乘法当作左关联还是右关联都没有关系——无论你使用哪种方式都可以得到相同的结果。但是，在精度有限的情况下，舍入和溢出意味着关联性会影响乘法序列的计算结果。如<code>print 0. 1 * (0. 2 * 0. 3);</code>和<code>print (0.1 * 0.2) * 0.3;</code>，在Lox等使用<a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 754</a>双精度浮点数的语言中，第一个算式的计算结果是<code>0.006</code>，而第二个算式的计算结果是<code>0.006000000000000001</code>。有时，这种微小的差异很重要。可以在<a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">这里</a>了解更多信息。
: 该方法之所以被称为“递归<em>下降</em>”，是因为它是沿着语法<em>向下</em>运行的。令人困惑的是，在谈论“高”和“低”优先级时，我们也使用方向来比喻，但是方向却是相反的。在自顶向下的解析器中，首先达到优先级最低的表达式，因为其中可能包含优先级更高的子表达式。&lt;br/>&lt;br/>CS的人真的需要聚在一起理清他们的隐喻。甚至不要让我开始讨论堆栈向哪个方向生长，或者为什么树的根在上面。
: 这就是为什么左递归对于递归下降是有问题的。左递归规则的函数会立即调用自身，并循环往复，直到解析器遇到堆栈溢出并崩溃。
: 解析<code>a==b==c==d</code>。对于每一次迭代，使用前一个子式结果作为左操作数并创建一个新的二元表达式。
: 解析器提前观察即将到来的标记来决定如何解析，这就把递归下降纳入了<strong>预测性解析器</strong>的范畴。
: 另一种处理常见语法错误的方法是<strong>错误生成式</strong>。你可以使用一个能<em>成功</em>匹配<em>错误</em>语法的规则来扩充语法。解析器可以对其进行安全地解析，但是不会生成语法树，而是会报告一个错误。&lt;br/>举例来说，有些语言中有一元运算符<code>+</code>，如<code>+123</code>，但是Lox不支持。当解析器在表达式的开头遇到一个<code>+</code>时，我们不必感到困惑，我们可以扩展一元规则来允许该语法。&lt;br/><code>unary → ( "!" | "-" | "+" ) unary | primary ;</code>&lt;br/>这样解析器就会消费<code>+</code>标记，而不是进入恐慌模式或让解析器陷入奇怪的状态。&lt;br/>错误生成式的效果很好。因为你作为解析器的作者，知道代码的<em>如何</em>出错的以及用户想要做什么。这意味着你可以给出一个更有用的信息来帮助用户回到正轨，比如，&ldquo;不支持一元&rsquo;+&rsquo;表达式&ldquo;。成熟的解析器往往会积累错误生成式，因为它们可以帮助用户修复常见的错误。
: 我说 &ldquo;可能 &ldquo;是因为我们可以在for循环中碰到分隔子句的分号。我们的同步并不完美，但这没关系。我们已经准确地报告了第一个错误，所以之后的一切都算是 &ldquo;尽力而为 &ldquo;了。
: 你可能会定义一个比Lox更复杂的语法，使用递归下降法难以对其解析。当你可能需要预先查看大量的标记以弄清你面临的情况时，预测性解析就变得很棘手。实际上，大多数语言都是为了避免这种情况而设计的。 即使情况并非如此，您通常也可以毫不费力地解决问题。 既然您可以使用递归下降来解析C ++（许多C ++编译器都可以做到），那么您就可以解析任何内容。</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>In C, a block is a statement form that allows you to pack a series of
statements where a single one is expected. The <a href="https://en.wikipedia.org/wiki/Comma_operator">comma operator</a> is an
analogous syntax for expressions. A comma-separated series of expressions
can be given where a single expression is expected (except inside a function
call&rsquo;s argument list). At runtime, the comma operator evaluates the left
operand and discards the result. Then it evaluates and returns the right
operand.</p>
<p>Add support for comma expressions. Give them the same precedence and
associativity as in C. Write the grammar, and then implement the necessary
parsing code.</p>
</li>
<li>
<p>Likewise, add support for the C-style conditional or &ldquo;ternary&rdquo; operator
<code>?:</code>. What precedence level is allowed between the <code>?</code> and <code>:</code>? Is the whole
operator left-associative or right-associative?
2、同样，添加对C风格的条件操作符或 &ldquo;三元 &ldquo;操作符<code>?:</code>的支持。在<code>?</code>和<code>:</code>之间采用什么优先级顺序？整个操作符是左关联还是右关联？</p>
</li>
<li>
<p>Add error productions to handle each binary operator appearing without a
left-hand operand. In other words, detect a binary operator appearing at the
beginning of an expression. Report that as an error, but also parse and
discard a right-hand operand with the appropriate precedence.
3、添加错误生成式处理没有左操作数的二元操作符。换句话说，检测出现在表达式开头的二元操作符。将其作为错误报告给用户，同时也要解析并丢弃具有相应优先级的右操作数。</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: Logic Versus History</a></h2>
<p>Let&rsquo;s say we decide to add bitwise <code>&amp;</code> and <code>|</code> operators to Lox. Where should we
put them in the precedence hierarchy? C<span class="em">&mdash;</span>and most languages that follow in C&rsquo;s
footsteps<span class="em">&mdash;</span>place them below <code>==</code>. This is widely considered a mistake because
it means common operations like testing a flag require parentheses.</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">flags</span> &amp; <span class="a">FLAG_MASK</span> == <span class="a">SOME_FLAG</span>) { ... } <span class="c">// Wrong.</span>
<span class="k">if</span> ((<span class="i">flags</span> &amp; <span class="a">FLAG_MASK</span>) == <span class="a">SOME_FLAG</span>) { ... } <span class="c">// Right.</span>
</pre></div>
<p>Should we fix this for Lox and put bitwise operators higher up the precedence
table than C does? There are two strategies we can take.</p>
<p>You almost never want to use the result of an <code>==</code> expression as the operand to
a bitwise operator. By making bitwise bind tighter, users don&rsquo;t need to
parenthesize as often. So if we do that, and users assume the precedence is
chosen logically to minimize parentheses, they&rsquo;re likely to infer it correctly.</p>
<p>This kind of internal consistency makes the language easier to learn because
there are fewer edge cases and exceptions users have to stumble into and then
correct. That&rsquo;s good, because before users can use our language, they have to
load all of that syntax and semantics into their heads. A simpler, more rational
language <em>makes sense</em>.</p>
<p>But, for many users there is an even faster shortcut to getting our language&rsquo;s
ideas into their wetware<span class="em">&mdash;</span><em>use concepts they already know</em>. Many newcomers to
our language will be coming from some other language or languages. If our
language uses some of the same syntax or semantics as those, there is much less
for the user to learn (and <em>unlearn</em>).</p>
<p>This is particularly helpful with syntax. You may not remember it well today,
but way back when you learned your very first programming language, code
probably looked alien and unapproachable. Only through painstaking effort did
you learn to read and accept it. If you design a novel syntax for your new
language, you force users to start that process all over again.</p>
<p>Taking advantage of what users already know is one of the most powerful tools
you can use to ease adoption of your language. It&rsquo;s almost impossible to
overestimate how valuable this is. But it faces you with a nasty problem: What
happens when the thing the users all know <em>kind of sucks</em>? C&rsquo;s bitwise operator
precedence is a mistake that doesn&rsquo;t make sense. But it&rsquo;s a <em>familiar</em> mistake
that millions have already gotten used to and learned to live with.</p>
<p>Do you stay true to your language&rsquo;s own internal logic and ignore history? Do
you start from a blank slate and first principles? Or do you weave your language
into the rich tapestry of programming history and give your users a leg up by
starting from something they already know?</p>
<p>There is no perfect answer here, only trade-offs. You and I are obviously biased
towards liking novel languages, so our natural inclination is to burn the
history books and start our own story.</p>
<p>In practice, it&rsquo;s often better to make the most of what users already know.
Getting them to come to your language requires a big leap. The smaller you can
make that chasm, the more people will be willing to cross it. But you can&rsquo;t
<em>always</em> stick to history, or your language won&rsquo;t have anything new and
compelling to give people a <em>reason</em> to jump over.</p>
</div>

    <footer>
      <a href="evaluating-expressions.html" class="next">
        下一节: &ldquo;求值表达式&rdquo; &rarr;
      </a>
      Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a
        href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy;
        2015&hairsp;&ndash;&hairsp;2021</a>
    </footer>
  </article>

  </div>
  </body>
  </html>
