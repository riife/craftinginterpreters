<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>值类型 &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
        <h3><a href="#top">值类型<small>18</small></a></h3>
    
    <ul>
        <li><a href="#带标签的联合体"><small>18.1</small> 带标签的联合体</a></li>
        <li><a href="#lox的值和c语言的值"><small>18.2</small> Lox的值和C语言的值</a></li>
        <li><a href="#动态类型数字"><small>18.3</small> 动态类型数字</a></li>
        <li><a href="#两个新类型"><small>18.4</small> 两个新类型</a></li>
        <li class="divider"></li>
        <li class="end-part"><a href="#challenges">Challenges</a></li>
    </ul>
    
    
        <div class="prev-next">
        <a href="compiling-expressions.html" title="编译表达式" class="left">&larr;&nbsp;Previous</a>
        <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
        <a href="strings.html" title="字符串" class="right">Next&nbsp;&rarr;</a>
    </div> </div>
</nav>

<nav class="narrow">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <a href="compiling-expressions.html" title="编译表达式" class="prev">←</a>
  <a href="strings.html" title="字符串" class="next">→</a>
</nav>

<div class="page">
  <div class="nav-wrapper">
    <nav class="floating">
      <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
      <div class="expandable">
        <h3><a href="#top">值类型<small>18</small></a></h3>
        
        <ul>
            <li><a href="#带标签的联合体"><small>18.1</small> 带标签的联合体</a></li>
            <li><a href="#lox的值和c语言的值"><small>18.2</small> Lox的值和C语言的值</a></li>
            <li><a href="#动态类型数字"><small>18.3</small> 动态类型数字</a></li>
            <li><a href="#两个新类型"><small>18.4</small> 两个新类型</a></li>
            <li class="divider"></li>
            <li class="end-part"><a href="#challenges">Challenges</a></li>
        </ul>
        
        
                <div class="prev-next">
            <a href="compiling-expressions.html" title="编译表达式" class="left">&larr;&nbsp;Previous</a>
            <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
            <a href="strings.html" title="字符串" class="right">Next&nbsp;&rarr;</a>
        </div>      </div>
      <a id="expand-nav">≡</a>
    </nav>
  </div>

  <article class="chapter">

    <div class="number">18</div>
    <h1>值类型</h1>

    <blockquote>
<p>When you are a Bear of Very Little Brain, and you Think of Things, you find
sometimes that a Thing which seemed very Thingish inside you is quite
different when it gets out into the open and has other people looking at it.</p>
<p><cite>A. A. Milne, <em>Winnie-the-Pooh</em></cite>
你要是一只脑子很小的熊，当你想事情的时候，你会发现，有时在你心里看起来很像回事的事情，当它展示出来，让别人看着它的时候，就完全不同了。（A. A.米尔恩，《小熊维尼》）</p>
</blockquote>
<p>The past few chapters were huge, packed full of complex techniques and pages of
code. In this chapter, there&rsquo;s only one new concept to learn and a scattering of
straightforward code. You&rsquo;ve earned a respite.
前面的几章篇幅很长，充满了复杂的技术和一页又一页的代码。在本章中，只需要学习一个新概念和一些简单的代码。你获得了喘息的机会。</p>
<p>Lox is <span name="unityped">dynamically</span> typed. A single variable can
hold a Boolean, number, or string at different points in time. At least, that&rsquo;s
the idea. Right now, in clox, all values are numbers. By the end of the chapter,
it will also support Booleans and <code>nil</code>. While those aren&rsquo;t super interesting,
they force us to figure out how our value representation can dynamically handle
different types.
Lox是动态类型的。一个变量可以在不同的时间点持有布尔值、数字或字符串。至少，我们的想法是如此。现在，在clox中，所有的值都是数字。到本章结束时，它还将支持布尔值和<code>nil</code>。虽然这些不是特别有趣，但它们迫使我们弄清楚值表示如何动态地处理不同类型。</p>
<aside name="unityped">
<p>There is a third category next to statically typed and dynamically typed:
<strong>unityped</strong>. In that paradigm, all variables have a single type, usually a
machine register integer. Unityped languages aren&rsquo;t common today, but some
Forths and BCPL, the language that inspired C, worked like this.</p>
<p>As of this moment, clox is unityped.</p>
</aside>
<h2><a href="#带标签的联合体" id="带标签的联合体"><small>18&#8202;.&#8202;1</small>带标签的联合体</a></h2>
<p>The nice thing about working in C is that we can build our data structures from
the raw bits up. The bad thing is that we <em>have</em> to do that. C doesn&rsquo;t give you
much for free at compile time and even less at runtime. As far as C is
concerned, the universe is an undifferentiated array of bytes. It&rsquo;s up to us to
decide how many of those bytes to use and what they mean.
使用C语言工作的好处是，我们可以从最基础的比特位开始构建数据结构。坏处是，我们必须这样做。C语言在编译时并没有提供多少免费的东西，在运行时就更少了。对C语言来说，宇宙是一个无差别的字节数组。由我们来决定使用多少个字节以及它们的含义。</p>
<p>In order to choose a value representation, we need to answer two key questions:
为了选择一种值的表示形式，我们需要先回答两个关键问题：</p>
<ol>
<li>
<blockquote>
<p><strong>How do we represent the type of a value?</strong> If you try to, say, multiply a number by <code>true</code>, we need to detect that error at runtime and report it. In order to do that, we need to be able to tell what a value’s type is.
<strong>我们如何表示一个值的类型？</strong> 比如说，如果你将一个数字乘以<code>true</code>，我们需要在运行时检测到这个错误并报告它。为此，我们需要知道值的类型是什么？</p>
</blockquote>
</li>
<li>
<blockquote>
<p><strong>How do we store the value itself?</strong> We need to not only be able to tell that three is a number, but that it’s different from the number four. I know, seems obvious, right? But we’re operating at a level where it’s good to spell these things out.
<strong>我们如何存储该值本身？</strong> 我们不仅要能分辨出3是一个数字，还要能分辨出它与4是不同的。我知道，这是显而易见的对吧？但是在我们所讨论的层面，最好把这些事情说清楚。</p>
</blockquote>
</li>
<li>
<p><strong>How do we represent the type of a value?</strong> If you try to, say, multiply a
number by <code>true</code>, we need to detect that error at runtime and report it. In
order to do that, we need to be able to tell what a value&rsquo;s type is.</p>
</li>
<li>
<p><strong>How do we store the value itself?</strong> We need to not only be able to tell
that three is a number, but that it&rsquo;s different from the number four. I
know, seems obvious, right? But we&rsquo;re operating at a level where it&rsquo;s good
to spell these things out.</p>
</li>
</ol>
<p>Since we&rsquo;re not just designing this language but building it ourselves, when
answering these two questions we also have to keep in mind the implementer&rsquo;s
eternal quest: to do it <em>efficiently</em>.
因为我们不仅仅是设计这门语言，还要自己构建它，所以在回答这两个问题时，我们还必须牢记实现者们永恒的追求：<em>高效</em>地完成它。</p>
<p>Language hackers over the years have come up with a variety of clever ways to
pack the above information into as few bits as possible. For now, we&rsquo;ll start
with the simplest, classic solution: a <strong>tagged union</strong>. A value contains two
parts: a type &ldquo;tag&rdquo;, and a payload for the actual value. To store the value&rsquo;s
type, we define an enum for each kind of value the VM supports.
多年来，语言黑客们想出了各种巧妙的方法，将上述信息打包成尽可能少的比特。现在，我们将从最简单、最经典的解决方案开始：<strong>带标签的联合体</strong>。一个值包含两个部分：一个类型“标签”，和一个实际值的有效载荷。为了存储值的类型，我们要为虚拟机支持的每一种值定义一个枚举。</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;

</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">VAL_BOOL</span>,
  <span class="a">VAL_NIL</span>,<span name="user-types"> </span>
  <span class="a">VAL_NUMBER</span>,
} <span class="t">ValueType</span>;

</pre><pre class="insert-after">typedef double Value;
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<aside name="user-types">
<p>The cases here cover each kind of value that has <em>built-in support in the VM</em>.
When we get to adding classes to the language, each class the user defines
doesn&rsquo;t need its own entry in this enum. As far as the VM is concerned, every
instance of a class is the same type: &ldquo;instance&rdquo;.</p>
<p>In other words, this is the VM&rsquo;s notion of &ldquo;type&rdquo;, not the user&rsquo;s.</p>
</aside>
<p>For now, we have only a couple of cases, but this will grow as we add strings,
functions, and classes to clox. In addition to the type, we also need to store
the data for the value<span class="em">&mdash;</span>the <code>double</code> for a number, <code>true</code> or <code>false</code> for a
Boolean. We could define a struct with fields for each possible type.
现在，我们只有这几种情况，但随着我们向clox中添加字符串、函数和类，这里也会越来越多。除了类型之外，我们还需要存储值的数据——数字是<code>double</code>值，Boolean是<code>true</code>或<code>false</code>。我们可以定义一个结构体，其中包含每种可能的类型所对应的字段。</p><img src="image/types-of-values/struct.png" alt="A struct with two fields laid next to each other in memory." />
<p>But this is a waste of memory. A value can&rsquo;t simultaneously be both a number and
a Boolean. So at any point in time, only one of those fields will be used. C
lets you optimize this by defining a <span name="sum">union</span>. A union
looks like a struct except that all of its fields overlap in memory.
但这是对内存的一种浪费。一个值不可能同时是数字和布尔值。所以在任何时候，这些字段中只有一个会被使用。C语言中允许定义联合体来优化这一点。联合体看起来很像是结构体，区别在于其中的所有字段在内存中是重叠的。</p>
<aside name="sum">
<p>If you&rsquo;re familiar with a language in the ML family, structs and unions in C
roughly mirror the difference between product and sum types, between tuples
and algebraic data types.</p>
</aside><img src="image/types-of-values/union.png" alt="A union with two fields overlapping in memory." />
<p>The size of a union is the size of its largest field. Since the fields all reuse
the same bits, you have to be very careful when working with them. If you store
data using one field and then access it using <span
name="reinterpret">another</span>, you will reinterpret what the underlying bits
mean.
联合体的大小就是其最大字段的大小。由于这些字段都复用相同的比特位，你在使用它们时必须要非常小心。如果你使用一个字段存储数据，然后用另一个字段访问数据，那你需要重新解释底层比特位的含义。</p>
<aside name="reinterpret">
<p>Using a union to interpret bits as different types is the quintessence of C. It
opens up a number of clever optimizations and lets you slice and dice each byte
of memory in ways that memory-safe languages disallow. But it is also wildly
unsafe and will happily saw your fingers off if you don&rsquo;t watch out.</p>
</aside>
<p>As the name &ldquo;tagged union&rdquo; implies, our new value representation combines these
two parts into a single struct.
顾名思义，“带标签的联合体”说明，我们新的值表示形式中将这两部分合并成一个结构体。</p>
<div class="codehilite"><pre class="insert-before">} ValueType;

</pre><div class="source-file"><em>value.h</em><br>
add after enum <em>ValueType</em><br>
replace 1 line</div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ValueType</span> <span class="i">type</span>;
  <span class="k">union</span> {
    <span class="t">bool</span> <span class="i">boolean</span>;
    <span class="t">double</span> <span class="i">number</span>;
  } <span class="i">as</span>;<span name="as"> </span>
} <span class="t">Value</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after enum <em>ValueType</em>, replace 1 line</div>

<p>There&rsquo;s a field for the type tag, and then a second field containing the union
of all of the underlying values. On a 64-bit machine with a typical C compiler,
the layout looks like this:
有一个字段用作类型标签，然后是第二个字段，一个包含所有底层值的联合体。在使用典型的C语言编译器的64位机器上，布局看起来如下：</p>
<aside name="as">
<p>A smart language hacker gave me the idea to use &ldquo;as&rdquo; for the name of the union
field because it reads nicely, almost like a cast, when you pull the various
values out.</p>
</aside><img src="image/types-of-values/value.png" alt="The full value struct, with the type and as fields next to each other in memory." />
<p>The four-byte type tag comes first, then the union. Most architectures prefer
values be aligned to their size. Since the union field contains an eight-byte
double, the compiler adds four bytes of <span name="pad">padding</span> after
the type field to keep that double on the nearest eight-byte boundary. That
means we&rsquo;re effectively spending eight bytes on the type tag, which only needs
to represent a number between zero and three. We could stuff the enum in a
smaller size, but all that would do is increase the padding.
首先是4字节的类型标签，然后是联合体。大多数体系结构都喜欢将值与它们的字长对齐。由于联合体字段中包含一个8字节的double值，所以编译器在类型字段后添加了4个字节的填充，以使该double值保持在最近的8字节边界上。这意味着我们实际在类型标签上花费了8个字节，而它只需要表示0到3之间的数字。我们可以把枚举放在一个占位更少的变量中，但这样做只会增加填充量。</p>
<aside name="pad">
<p>We could move the tag field <em>after</em> the union, but that doesn&rsquo;t help much
either. Whenever we create an array of Values<span class="em">&mdash;</span>which is where most of our
memory usage for Values will be<span class="em">&mdash;</span>the C compiler will insert that same padding
<em>between</em> each Value to keep the doubles aligned.</p>
</aside>
<p>So our Values are 16 bytes, which seems a little large. We&rsquo;ll improve it
<a href="optimization.html">later</a>. In the meantime, they&rsquo;re still small enough to store on
the C stack and pass around by value. Lox&rsquo;s semantics allow that because the
only types we support so far are <strong>immutable</strong>. If we pass a copy of a Value
containing the number three to some function, we don&rsquo;t need to worry about the
caller seeing modifications to the value. You can&rsquo;t &ldquo;modify&rdquo; three. It&rsquo;s three
forever.
所以我们的Value是16个字节，这似乎有点大。我们稍后会改进它。同时，它们也足够小，可以存储在C语言的堆栈中，并按值传递。Lox的语义允许这样做，因为到目前为止我们只支持<strong>不可变</strong>类型。如果我们把一个包含数字3的Value的副本传递给某个函数，我们不需要担心调用者会看到对该值的修改。你不能“修改”3，它永远都是3。</p>
<h2><a href="#lox的值和c语言的值" id="lox的值和c语言的值"><small>18&#8202;.&#8202;2</small>Lox的值和C语言的值</a></h2>
<p>That&rsquo;s our new value representation, but we aren&rsquo;t done. Right now, the rest of
clox assumes Value is an alias for <code>double</code>. We have code that does a straight C
cast from one to the other. That code is all broken now. So sad.
这就是我们新的值表示形式，但是我们还没有做完。现在，clox的其余部分都假定了Value是<code>double</code>的别名。我们有一些代码是直接用C语言将一个值转换为另一个值。这些代码现在都被破坏了，好伤心。</p>
<p>With our new representation, a Value can <em>contain</em> a double, but it&rsquo;s not
<em>equivalent</em> to it. There is a mandatory conversion step to get from one to the
other. We need to go through the code and insert those conversions to get clox
working again.
在我们新的表示形式中，Value可以<em>包含</em>一个double值，但它并不等同于double类型。有一个强制性的转换步骤可以实现从一个值到另一个值的转换。我们需要遍历代码并插入这些转换步骤，以使clox重新工作。</p>
<p>We&rsquo;ll implement these conversions as a handful of macros, one for each type and
operation. First, to promote a native C value to a clox Value:
我们会用少量的宏来实现这些转换，每个宏对应一个类型和操作。首先，将原生的C值转换为clox Value：</p>
<div class="codehilite"><pre class="insert-before">} Value;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert">

<span class="a">#define BOOL_VAL(value)   ((Value){VAL_BOOL, {.boolean = value}})</span>
<span class="a">#define NIL_VAL           ((Value){VAL_NIL, {.number = 0}})</span>
<span class="a">#define NUMBER_VAL(value) ((Value){VAL_NUMBER, {.number = value}})</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<p>Each one of these takes a C value of the appropriate type and produces a Value
that has the correct type tag and contains the underlying value. This hoists
statically typed values up into clox&rsquo;s dynamically typed universe. In order to
<em>do</em> anything with a Value, though, we need to unpack it and get the C value
back out.
其中每个宏都接收一个适当类型的C值，并生成一个Value，其具有正确类型标签并包含底层的值。这就把静态类型的值提升到了clox的动态类型的世界。但是为了能对Value做任何操作，我们需要将其拆包并取出对应的C值。</p>
<div class="codehilite"><pre class="insert-before">} Value;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert">

<span class="a">#define AS_BOOL(value)    ((value).as.boolean)</span>
<span class="a">#define AS_NUMBER(value)  ((value).as.number)</span>
</pre><pre class="insert-after">

#define BOOL_VAL(value)   ((Value){VAL_BOOL, {.boolean = value}})
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<aside name="as-null">
<p>There&rsquo;s no <code>AS_NIL</code> macro because there is only one <code>nil</code> value, so a Value with
type <code>VAL_NIL</code> doesn&rsquo;t carry any extra data.</p>
</aside>
<p><span name="as-null">These</span> macros go in the opposite direction. Given a
Value of the right type, they unwrap it and return the corresponding raw C
value. The &ldquo;right type&rdquo; part is important! These macros directly access the
union fields. If we were to do something like:
这些宏的作用是反方向的。给定一个正确类型的Value，它们会将其解包并返回对应的原始C值。“正确类型”很重要！这些宏会直接访问联合体字段。如果我们要这样做：</p>
<div class="codehilite"><pre><span class="t">Value</span> <span class="i">value</span> = <span class="a">BOOL_VAL</span>(<span class="k">true</span>);
<span class="t">double</span> <span class="i">number</span> = <span class="a">AS_NUMBER</span>(<span class="i">value</span>);
</pre></div>
<p>Then we may open a smoldering portal to the Shadow Realm. It&rsquo;s not safe to use
any of the <code>AS_</code> macros unless we know the Value contains the appropriate type.
To that end, we define a last few macros to check a Value&rsquo;s type.
那我们可能会打开一个通往暗影王国的阴燃之门。除非我们知道Value包含适当的类型，否则使用任何的<code>AS_</code>宏都是不安全的。为此，我们定义最后几个宏来检查Value的类型。</p>
<div class="codehilite"><pre class="insert-before">} Value;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert">

<span class="a">#define IS_BOOL(value)    ((value).type == VAL_BOOL)</span>
<span class="a">#define IS_NIL(value)     ((value).type == VAL_NIL)</span>
<span class="a">#define IS_NUMBER(value)  ((value).type == VAL_NUMBER)</span>
</pre><pre class="insert-after">

#define AS_BOOL(value)    ((value).as.boolean)
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<p><span name="universe">These</span> macros return <code>true</code> if the Value has that
type. Any time we call one of the <code>AS_</code> macros, we need to guard it behind a
call to one of these first. With these eight macros, we can now safely shuttle
data between Lox&rsquo;s dynamic world and C&rsquo;s static one.
如果Value具有对应类型，这些宏会返回<code>true</code>。每当我们调用一个<code>AS_</code>宏时，我们都需要保证首先调用了这些宏。有了这8个宏，我们现在可以安全地在Lox的动态世界和C的静态世界之间传输数据了。</p>
<aside name="universe"><img src="image/types-of-values/universe.png" alt="The earthly C firmament with the Lox heavens above." />
<p>The <code>_VAL</code> macros lift a C value into the heavens. The <code>AS_</code> macros bring it
back down.</p>
</aside>
<h2><a href="#动态类型数字" id="动态类型数字"><small>18&#8202;.&#8202;3</small>动态类型数字</a></h2>
<p>We&rsquo;ve got our value representation and the tools to convert to and from it. All
that&rsquo;s left to get clox running again is to grind through the code and fix every
place where data moves across that boundary. This is one of those sections of
the book that isn&rsquo;t exactly mind-blowing, but I promised I&rsquo;d show you every
single line of code, so here we are.
我们已经有了值的表示形式和转换的工具。要想让clox重新运行起来，剩下的工作就是仔细检查代码，修复每个数据跨边界传递的地方。这是本书中不太让人兴奋的章节之一，但我保证会给你展示每一行代码，所以我们开始吧。</p>
<p>The first values we create are the constants generated when we compile number
literals. After we convert the lexeme to a C double, we simply wrap it in a
Value before storing it in the constant table.
我们创建的第一个值是在编译数值字面量时生成的常量。在我们将词素转换为C语言的double之后，我们简单地将其包装在一个Value中，然后再存储到常量表中。</p>
<div class="codehilite"><pre class="insert-before">  double value = strtod(parser.previous.start, NULL);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>number</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">emitConstant</span>(<span class="a">NUMBER_VAL</span>(<span class="i">value</span>));
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>number</em>(), replace 1 line</div>

<p>Over in the runtime, we have a function to print values.
在运行时，我们有一个函数来打印值。</p>
<div class="codehilite"><pre class="insert-before">void printValue(Value value) {
</pre><div class="source-file"><em>value.c</em><br>
in <em>printValue</em>()<br>
replace 1 line</div>
<pre class="insert"> <span class="i">printf</span>(<span class="s">&quot;%g&quot;</span>, <span class="a">AS_NUMBER</span>(<span class="i">value</span>));
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>printValue</em>(), replace 1 line</div>

<p>Right before we send the Value to <code>printf()</code>, we unwrap it and extract the
double value. We&rsquo;ll revisit this function shortly to add the other types, but
let&rsquo;s get our existing code working first.
在我们将Value发送给<code>printf()</code>之前，我们将其拆装并提取出double值。我们很快会重新回顾这个函数并添加其它类型，但是我们先让现有的代码工作起来。</p>
<h3><a href="#一元取负与运行时错误" id="一元取负与运行时错误"><small>18&#8202;.&#8202;3&#8202;.&#8202;1</small>一元取负与运行时错误</a></h3>
<p>The next simplest operation is unary negation. It pops a value off the stack,
negates it, and pushes the result. Now that we have other types of values, we
can&rsquo;t assume the operand is a number anymore. The user could just as well do:
接下来最简单的操作是一元取负。它会从栈中弹出一个值，对其取负，并将结果压入栈。现在我们有了其它类型的值，我们不能再假设操作数是一个数字。用户也可以这样做：</p>
<div class="codehilite"><pre><span class="k">print</span> -<span class="k">false</span>; <span class="c">// Uh...</span>
</pre></div>
<p>We need to handle that gracefully, which means it&rsquo;s time for <em>runtime errors</em>.
Before performing an operation that requires a certain type, we need to make
sure the Value <em>is</em> that type.
我们需要优雅地处理这个问题，这意味着是时候讨论运行时错误了。在执行需要特定类型的操作之前，我们需要确保Value是该类型。</p>
<p>For unary negation, the check looks like this:
对于一元取负来说，检查是这样的：</p>
<div class="codehilite"><pre class="insert-before">      case OP_DIVIDE:   BINARY_OP(/); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NEGATE</span>:
        <span class="k">if</span> (!<span class="a">IS_NUMBER</span>(<span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Operand must be a number.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="i">push</span>(<span class="a">NUMBER_VAL</span>(-<span class="a">AS_NUMBER</span>(<span class="i">pop</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>First, we check to see if the Value on top of the stack is a number. If it&rsquo;s
not, we report the runtime error and <span name="halt">stop</span> the
interpreter. Otherwise, we keep going. Only after this validation do we unwrap
the operand, negate it, wrap the result and push it.
首先，我们检查栈顶的Value是否是一个数字。如果不是，则报告运行时错误并停止解释器。否则，我们就继续运行。只有在验证之后，我们才会拆装操作数，取负，将结果封装并压入栈。</p>
<aside name="halt">
<p>Lox&rsquo;s approach to error-handling is rather<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span><em>spare</em>. All errors are fatal and
immediately halt the interpreter. There&rsquo;s no way for user code to recover from
an error. If Lox were a real language, this is one of the first things I would
remedy.</p>
</aside>
<p>To access the Value, we use a new little function.
为了访问Value，我们使用一个新的小函数。</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>pop</em>()</div>
<pre><span class="k">static</span> <span class="t">Value</span> <span class="i">peek</span>(<span class="t">int</span> <span class="i">distance</span>) {
  <span class="k">return</span> <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="n">1</span> - <span class="i">distance</span>];
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>pop</em>()</div>

<p>It returns a Value from the stack but doesn&rsquo;t <span name="peek">pop</span> it.
The <code>distance</code> argument is how far down from the top of the stack to look: zero
is the top, one is one slot down, etc.
它从堆栈中返回一个Value，但是并不弹出它。<code>distance</code>参数是指要从堆栈顶部向下看多远：0是栈顶，1是下一个槽，以此类推。</p>
<aside name="peek">
<p>Why not just pop the operand and then validate it? We could do that. In later
chapters, it will be important to leave operands on the stack to ensure the
garbage collector can find them if a collection is triggered in the middle of
the operation. I do the same thing here mostly out of habit.</p>
</aside>
<p>We report the runtime error using a new function that we&rsquo;ll get a lot of mileage
out of over the remainder of the book.
我们使用一个新函数来报告运行时错误，在本书的剩余部分，我们会从中得到很多的好处。</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>resetStack</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">runtimeError</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">format</span>, ...) {
  <span class="t">va_list</span> <span class="i">args</span>;
  <span class="i">va_start</span>(<span class="i">args</span>, <span class="i">format</span>);
  <span class="i">vfprintf</span>(<span class="i">stderr</span>, <span class="i">format</span>, <span class="i">args</span>);
  <span class="i">va_end</span>(<span class="i">args</span>);
  <span class="i">fputs</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">stderr</span>);

  <span class="t">size_t</span> <span class="i">instruction</span> = <span class="i">vm</span>.<span class="i">ip</span> - <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span> - <span class="n">1</span>;
  <span class="t">int</span> <span class="i">line</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">instruction</span>];
  <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;[line %d] in script</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">line</span>);
  <span class="i">resetStack</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>resetStack</em>()</div>

<p>You&rsquo;ve certainly <em>called</em> variadic functions<span class="em">&mdash;</span>ones that take a varying number
of arguments<span class="em">&mdash;</span>in C before: <code>printf()</code> is one. But you may not have <em>defined</em>
your own. This book isn&rsquo;t a C <span name="tutorial">tutorial</span>, so I&rsquo;ll
skim over it here, but basically the <code>...</code> and <code>va_list</code> stuff let us pass an
arbitrary number of arguments to <code>runtimeError()</code>. It forwards those on to
<code>vfprintf()</code>, which is the flavor of <code>printf()</code> that takes an explicit
<code>va_list</code>.
你以前肯定在C语言中调用过变参函数——接受不同数量参数的函数：<code>printf()</code>就是其中之一。但你可能还没<em>定义</em>过自己的变参函数。这本书不是C语言教程，所以我在这里略过了，但是基本上是<code>...</code>和<code>va_list</code>让我们可以向<code>runtimeError()</code>传递任意数量的参数。它将这些参数转发给<code>vfprintf()</code>，这是<code>printf()</code>的一个变体，需要一个显式地<code>va_list</code>。</p>
<aside name="tutorial">
<p>If you are looking for a C tutorial, I love <em><a href="https://www.cs.princeton.edu/~bwk/cbook.html">The C Programming Language</a></em>,
usually called &ldquo;K&amp;R&rdquo; in honor of its authors. It&rsquo;s not entirely up to date, but
the quality of the writing more than makes up for it.</p>
</aside>
<p>Callers can pass a format string to <code>runtimeError()</code> followed by a number of
arguments, just like they can when calling <code>printf()</code> directly. <code>runtimeError()</code>
then formats and prints those arguments. We won&rsquo;t take advantage of that in this
chapter, but later chapters will produce formatted runtime error messages that
contain other data.
调用者可以向<code>runtimeError()</code>传入一个格式化字符串，后跟一些参数，就像他们直接调用<code>printf()</code>一样。然后<code>runtimeError()</code>格式化并打印这些参数。在本章中我们不会利用这一点，但后面的章节中将生成包含其它数据的格式化运行时错误信息。</p>
<p>After we show the hopefully helpful error message, we tell the user which <span
name="stack">line</span> of their code was being executed when the error
occurred. Since we left the tokens behind in the compiler, we look up the line
in the debug information compiled into the chunk. If our compiler did its job
right, that corresponds to the line of source code that the bytecode was
compiled from.
在显示了希望有帮助的错误信息之后，我们还会告诉用户，当错误发生时正在执行代码中的哪一行。因为我们在编译器中留下了标识，所以我们可以从编译到字节码块中的调试信息中查找行号。如果我们的编译器正确完成了它的工作，就能对应到字节码被编译出来的那一行源代码。</p>
<p>We look into the chunk&rsquo;s debug line array using the current bytecode instruction
index <em>minus one</em>. That&rsquo;s because the interpreter advances past each instruction
before executing it. So, at the point that we call <code>runtimeError()</code>, the failed
instruction is the previous one.
我们使用当前字节码指令索引减1来查看字节码块的调试行数组。这是因为解释器在之前每条指令之前都会向前推进。所以，当我们调用 <code>runtimeError()</code>，失败的指令就是前一条。
Just showing the immediate line where the error occurred doesn’t provide much context. Better would be a full stack trace. But we don’t even have functions to call yet, so there is no call stack to trace.</p>
<aside name="stack">
<p>Just showing the immediate line where the error occurred doesn&rsquo;t provide much
context. Better would be a full stack trace. But we don&rsquo;t even have functions to
call yet, so there is no call stack to trace.</p>
</aside>
<p>In order to use <code>va_list</code> and the macros for working with it, we need to bring
in a standard header.
为了使用<code>va_list</code>和相关的宏，我们需要引入一个标准头文件。</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add to top of file</div>
<pre class="insert"><span class="a">#include &lt;stdarg.h&gt;</span>
</pre><pre class="insert-after">#include &lt;stdio.h&gt;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add to top of file</div>

<p>With this, our VM can not only do the right thing when we negate numbers (like
it used to before we broke it), but it also gracefully handles erroneous
attempts to negate other types (which we don&rsquo;t have yet, but still).
有了它，我们的虚拟机不仅可以在对数字取负时正确执行（原本就会这样做），而且还可以优雅地处理对其它类型取负的错误尝试（目前还没有，但仍然存在）。</p>
<h3><a href="#二元数字运算符" id="二元数字运算符"><small>18&#8202;.&#8202;3&#8202;.&#8202;2</small>二元数字运算符</a></h3>
<p>We have our runtime error machinery in place now, so fixing the binary operators
is easier even though they&rsquo;re more complex. We support four binary operators
today: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. The only difference between them is which
underlying C operator they use. To minimize redundant code between the four
operators, we wrapped up the commonality in a big preprocessor macro that takes
the operator token as a parameter.
我们现在已经有了运行时错误机制，所以修复二元运算符更容易，尽管它们更复杂。现在我们支持四种二元运算符：<code>+</code>、<code>-</code>、<code>*</code>和<code>/</code>。它们之间唯一的区别就是使用的是哪种底层C运算符。为了尽量减少这四个运算符之间的冗余代码，我们将它们的共性封装在一个大的预处理宏中，该宏以运算符标识作为参数。</p>
<p>That macro seemed like overkill a <a href="a-virtual-machine.html#binary-operators">few chapters ago</a>, but we get the benefit
from it today. It lets us add the necessary type checking and conversions in one
place.
这个宏在前几章中似乎是多余的，但现在我们却从中受益。它让我们可以在某个地方添加必要的类型检查和转换。</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 6 lines</div>
<pre class="insert"><span class="a">#define BINARY_OP(valueType, op) \</span>
<span class="a">    do { \</span>
<span class="a">      if (!IS_NUMBER(peek(0)) || !IS_NUMBER(peek(1))) { \</span>
<span class="a">        runtimeError(&quot;Operands must be numbers.&quot;); \</span>
<span class="a">        return INTERPRET_RUNTIME_ERROR; \</span>
<span class="a">      } \</span>
<span class="a">      double b = AS_NUMBER(pop()); \</span>
<span class="a">      double a = AS_NUMBER(pop()); \</span>
<span class="a">      push(valueType(a op b)); \</span>
<span class="a">    } while (false)</span>
</pre><pre class="insert-after">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 6 lines</div>

<p>Yeah, I realize that&rsquo;s a monster of a macro. It&rsquo;s not what I&rsquo;d normally consider
good C practice, but let&rsquo;s roll with it. The changes are similar to what we did
for unary negate. First, we check that the two operands are both numbers. If
either isn&rsquo;t, we report a runtime error and yank the ejection seat lever.
是的，我知道这是一个巨大的宏。这不是我通常认为的好的C语言实践，但我们还是用它吧。这些调整与我们对一元取负所做的相似。首先，我们检查两个操作数是否都是数字。如果其中一个不是，我们就报告一个运行时错误，并拉下弹射座椅手柄。</p>
<p>If the operands are fine, we pop them both and unwrap them. Then we apply the
given operator, wrap the result, and push it back on the stack. Note that we
don&rsquo;t wrap the result by directly using <code>NUMBER_VAL()</code>. Instead, the wrapper to
use is passed in as a macro <span name="macro">parameter</span>. For our
existing arithmetic operators, the result is a number, so we pass in the
<code>NUMBER_VAL</code> macro.
如果操作数都没有问题，我们就把它们都弹出栈并进行拆装。然后我们应用给定的运算符，包装结果并将其压回栈中。注意，我们没有直接使用<code>NUMBER_VAL()</code>来包装结果。相反，我们要使用的包装器是作为宏参数传入的。对于我们现有的数字运算符来说，结果是一个数字，所以我们传入<code>NUMBER_VAL</code>宏。</p>
<aside name="macro">
<p>Did you know you can pass macros as parameters to macros? Now you do!</p>
</aside>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 4 lines</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_ADD</span>:      <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, +); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_SUBTRACT</span>: <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, -); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_MULTIPLY</span>: <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, *); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_DIVIDE</span>:   <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, /); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 4 lines</div>

<p>Soon, I&rsquo;ll show you why we made the wrapping macro an argument.
很快，我就会告诉你为什么我们要将包装宏作为参数。</p>
<h2><a href="#两个新类型" id="两个新类型"><small>18&#8202;.&#8202;4</small>两个新类型</a></h2>
<p>All of our existing clox code is back in working order. Finally, it&rsquo;s time to
add some new types. We&rsquo;ve got a running numeric calculator that now does a
number of pointless paranoid runtime type checks. We can represent other types
internally, but there&rsquo;s no way for a user&rsquo;s program to ever create a Value of
one of those types.
我们现有的所有clox代码都恢复正常工作了。最后，是时候添加一些新类型了。我们有一个正在运行的数字计算器，它现在做了一些毫无意义的偏执的运行时类型检查。我们可以在内部表示其它类型，但用户的程序无法创建这些类型的Value。</p>
<p>Not until now, that is. We&rsquo;ll start by adding compiler support for the three new
literals: <code>true</code>, <code>false</code>, and <code>nil</code>. They&rsquo;re all pretty simple, so we&rsquo;ll do all
three in a single batch.
现在还不能。首先，我们向编译器添加对三个新字面量的支持：<code>true</code>、<code>false</code>、<code>nil</code>。它们都很简单，所以我们一次性完成这三个。</p>
<p>With number literals, we had to deal with the fact that there are billions of
possible numeric values. We attended to that by storing the literal&rsquo;s value in
the chunk&rsquo;s constant table and emitting a bytecode instruction that simply
loaded that constant. We could do the same thing for the new types. We&rsquo;d store,
say, <code>true</code>, in the constant table, and use an <code>OP_CONSTANT</code> to read it out.
对于数字字面量，我们要面对这样一个事实：有数十亿个可能的数字值。为此，我们将字面量的值保存在字节码块的常量表中，并生成一个加载该常量的字节码指令。我们可以对这些新类型做同样的事。我们在常量表中存储值，比如<code>true</code>，并使用<code>OP_CONSTANT</code>来读取它。</p>
<p>But given that there are literally (heh) only three possible values we need to
worry about with these new types, it&rsquo;s gratuitous<span class="em">&mdash;</span>and <span
name="small">slow!</span><span class="em">&mdash;</span>to waste a two-byte instruction and a constant
table entry on them. Instead, we&rsquo;ll define three dedicated instructions to push
each of these literals on the stack.
但是考虑到这些新类型实际上只有三种可能的值，这样做是没有必要的——而且速度很慢！——浪费了一个两字节的指令和常量表中的一个项。相反，我们会定义三个专用指令来将这些字面量压入栈中。</p>
<aside name="small" class="bottom">
<p>I&rsquo;m not kidding about dedicated operations for certain constant values being
faster. A bytecode VM spends much of its execution time reading and decoding
instructions. The fewer, simpler instructions you need for a given piece of
behavior, the faster it goes. Short instructions dedicated to common operations
are a classic optimization.</p>
<p>For example, the Java bytecode instruction set has dedicated instructions for
loading 0.0, 1.0, 2.0, and the integer values from -1 through 5. (This ends up
being a vestigial optimization given that most mature JVMs now JIT-compile the
bytecode to machine code before execution anyway.)</p>
</aside>
<div class="codehilite"><pre class="insert-before">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_NIL</span>,
  <span class="a">OP_TRUE</span>,
  <span class="a">OP_FALSE</span>,
</pre><pre class="insert-after">  OP_ADD,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Our scanner already treats <code>true</code>, <code>false</code>, and <code>nil</code> as keywords, so we can
skip right to the parser. With our table-based Pratt parser, we just need to
slot parser functions into the rows associated with those keyword token types.
We&rsquo;ll use the same function in all three slots. Here:
我们的扫描器已经将<code>true</code>、<code>false</code>和<code>nil</code>视为关键字，所以我们可以直接调到解析器。对于我们这个基于表格的Pratt解析器，只需要将解析器函数插入到与这些关键字标识类型相对应的行中。我们会在三个槽中使用相同的函数。这里：</p>
<ul>
<li></li>
</ul>
<p>这里:</p>
<ul>
<li></li>
</ul>
<p>还有这里:</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_ELSE]          = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_FALSE</span>]         = {<span class="i">literal</span>,  <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_FOR]           = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Here:</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_THIS]          = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_TRUE</span>]          = {<span class="i">literal</span>,  <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_VAR]           = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>And here:</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_IF]            = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_NIL</span>]           = {<span class="i">literal</span>,  <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_OR]            = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>When the parser encounters <code>false</code>, <code>nil</code>, or <code>true</code>, in prefix position, it
calls this new parser function:
当解析器在前缀位置遇到<code>false</code>、<code>nil</code>或 <code>true</code>时，它会调用这个新的解析器函数：</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>binary</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">literal</span>() {
  <span class="k">switch</span> (<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">TOKEN_FALSE</span>: <span class="i">emitByte</span>(<span class="a">OP_FALSE</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_NIL</span>: <span class="i">emitByte</span>(<span class="a">OP_NIL</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_TRUE</span>: <span class="i">emitByte</span>(<span class="a">OP_TRUE</span>); <span class="k">break</span>;
    <span class="k">default</span>: <span class="k">return</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>binary</em>()</div>

<p>Since <code>parsePrecedence()</code> has already consumed the keyword token, all we need to
do is output the proper instruction. We <span name="switch">figure</span> that
out based on the type of token we parsed. Our front end can now compile Boolean
and nil literals to bytecode. Moving down the execution pipeline, we reach the
interpreter.
因为<code>parsePrecedence()</code>已经消耗了关键字标识，我们需要做的就是输出正确的指令。我们根据解析出的标识的类型来确定指令。我们的前端现在可以将布尔值和<code>nil</code>字面量编译为字节码。沿着执行管道向下移动，我们就到了解释器。</p>
<aside name="switch">
<p>We could have used separate parser functions for each literal and saved
ourselves a switch but that felt needlessly verbose to me. I think it&rsquo;s mostly a
matter of taste.</p>
</aside>
<div class="codehilite"><pre class="insert-before">      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
        push(constant);
        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NIL</span>: <span class="i">push</span>(<span class="a">NIL_VAL</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_TRUE</span>: <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="k">true</span>)); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_FALSE</span>: <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="k">false</span>)); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_ADD:      BINARY_OP(NUMBER_VAL, +); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>This is pretty self-explanatory. Each instruction summons the appropriate value
and pushes it onto the stack. We shouldn&rsquo;t forget our disassembler either.
这一点是不言而喻的。每条指令都会召唤出相应的值并将其压入堆栈。我们也不能忘记反汇编程序。</p>
<div class="codehilite"><pre class="insert-before">    case OP_CONSTANT:
      return constantInstruction(&quot;OP_CONSTANT&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_NIL</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_NIL&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_TRUE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_TRUE&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_FALSE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_FALSE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_ADD:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>With this in place, we can run this Earth-shattering program:
有了这些，我们就可以运行这个惊天动地的程序：</p>
<div class="codehilite"><pre><span class="k">true</span>
</pre></div>
<p>Except that when the interpreter tries to print the result, it blows up. We need
to extend <code>printValue()</code> to handle the new types too:
只是当解释器试图打印结果时，就崩溃了。我们也需要扩展<code>printValue()</code>来处理新类型：</p>
<div class="codehilite"><pre class="insert-before">void printValue(Value value) {
</pre><div class="source-file"><em>value.c</em><br>
in <em>printValue</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">switch</span> (<span class="i">value</span>.<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">VAL_BOOL</span>:
      <span class="i">printf</span>(<span class="a">AS_BOOL</span>(<span class="i">value</span>) ? <span class="s">&quot;true&quot;</span> : <span class="s">&quot;false&quot;</span>);
      <span class="k">break</span>;
    <span class="k">case</span> <span class="a">VAL_NIL</span>: <span class="i">printf</span>(<span class="s">&quot;nil&quot;</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">VAL_NUMBER</span>: <span class="i">printf</span>(<span class="s">&quot;%g&quot;</span>, <span class="a">AS_NUMBER</span>(<span class="i">value</span>)); <span class="k">break</span>;
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>printValue</em>(), replace 1 line</div>

<p>There we go! Now we have some new types. They just aren&rsquo;t very useful yet. Aside
from the literals, you can&rsquo;t really <em>do</em> anything with them. It will be a while
before <code>nil</code> comes into play, but we can start putting Booleans to work in the
logical operators.
我们继续！现在我们有了一些新的类型，只是它们目前还不是很有用。除了字面量之外，你无法真正对其做任何事。还需要一段时间<code>nil</code>才会发挥作用，但我们可以先让布尔值在逻辑运算符中发挥作用。</p>
<h3><a href="#逻辑非和false" id="逻辑非和false"><small>18&#8202;.&#8202;4&#8202;.&#8202;1</small>逻辑非和false</a></h3>
<p>The simplest logical operator is our old exclamatory friend unary not.
最简单的逻辑运算符是我们充满感叹意味的老朋友一元取非。</p>
<div class="codehilite"><pre><span class="k">print</span> !<span class="k">true</span>; <span class="c">// &quot;false&quot;</span>
</pre></div>
<p>This new operation gets a new instruction.
这个新操作会有一条新指令。</p>
<div class="codehilite"><pre class="insert-before">  OP_DIVIDE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_NOT</span>,
</pre><pre class="insert-after">  OP_NEGATE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>We can reuse the <code>unary()</code> parser function we wrote for unary negation to
compile a not expression. We just need to slot it into the parsing table.
我们可以重用为一元取负所写的解析函数来编译一个逻辑非表达式。我们只需要将其插入到解析表格中。</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_STAR]          = {NULL,     binary, PREC_FACTOR},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_BANG</span>]          = {<span class="i">unary</span>,    <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_BANG_EQUAL]    = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Because I knew we were going to do this, the <code>unary()</code> function already has a
switch on the token type to figure out which bytecode instruction to output. We
merely add another case.
因为我之前已知道我们要这样做，<code>unary()</code>函数已经有了关于标识类型的switch语句，来判断要输出哪个字节码指令。我们只需要增加一个分支即可。</p>
<div class="codehilite"><pre class="insert-before">  switch (operatorType) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>unary</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">TOKEN_BANG</span>: <span class="i">emitByte</span>(<span class="a">OP_NOT</span>); <span class="k">break</span>;
</pre><pre class="insert-after">    case TOKEN_MINUS: emitByte(OP_NEGATE); break;
    default: return; // Unreachable.
  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>unary</em>()</div>

<p>That&rsquo;s it for the front end. Let&rsquo;s head over to the VM and conjure this
instruction into life.
前端就这样了。让我们去虚拟机那里，并将这个指令变成现实。</p>
<div class="codehilite"><pre class="insert-before">      case OP_DIVIDE:   BINARY_OP(NUMBER_VAL, /); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NOT</span>:
        <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="i">isFalsey</span>(<span class="i">pop</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Like our previous unary operator, it pops the one operand, performs the
operation, and pushes the result. And, as we did there, we have to worry about
dynamic typing. Taking the logical not of <code>true</code> is easy, but there&rsquo;s nothing
preventing an unruly programmer from writing something like this:
跟之前的一元运算符一样，它会弹出一个操作数，执行操作，并将结果压入栈中。正如我们所做的那样，我们必须考虑动态类型。对<code>true</code>进行逻辑取非很容易，但没什么能阻止一个不守规矩的程序员写出这样的东西：</p>
<div class="codehilite"><pre><span class="k">print</span> !<span class="k">nil</span>;
</pre></div>
<p>For unary minus, we made it an error to negate anything that isn&rsquo;t a <span
name="negate">number</span>. But Lox, like most scripting languages, is more
permissive when it comes to <code>!</code> and other contexts where a Boolean is expected.
The rule for how other types are handled is called &ldquo;falsiness&rdquo;, and we implement
it here:
对于一元取负，我们把对任何非数字的东西进行取负当作一个错误。但是Lox，像大多数脚本语言一样，在涉及到<code>!</code>和其它期望出现布尔值的情况下，是比较宽容的。处理其它类型的规则被称为“falsiness”，我们在这里实现它：</p>
<aside name="negate">
<p>Now I can&rsquo;t help but try to figure out what it would mean to negate other types
of values. <code>nil</code> is probably its own negation, sort of like a weird pseudo-zero.
Negating a string could, uh, reverse it?</p>
</aside>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>peek</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">isFalsey</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="k">return</span> <span class="a">IS_NIL</span>(<span class="i">value</span>) || (<span class="a">IS_BOOL</span>(<span class="i">value</span>) &amp;&amp; !<span class="a">AS_BOOL</span>(<span class="i">value</span>));
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>peek</em>()</div>

<p>Lox follows Ruby in that <code>nil</code> and <code>false</code> are falsey and every other value
behaves like <code>true</code>. We&rsquo;ve got a new instruction we can generate, so we also
need to be able to <em>un</em>generate it in the disassembler.
Lox遵循Ruby的规定，<code>nil</code>和<code>false</code>是假的，其它的值都表现为<code>true</code>。我们已经有了一条可以生成的新指令，所以我们也需要能够在反汇编程序中反生成它。</p>
<div class="codehilite"><pre class="insert-before">    case OP_DIVIDE:
      return simpleInstruction(&quot;OP_DIVIDE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_NOT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_NOT&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<h3><a href="#相等与比较运算符" id="相等与比较运算符"><small>18&#8202;.&#8202;4&#8202;.&#8202;2</small>相等与比较运算符</a></h3>
<p>That wasn&rsquo;t too bad. Let&rsquo;s keep the momentum going and knock out the equality
and comparison operators too: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. That covers
all of the operators that return Boolean results except the logical operators
<code>and</code> and <code>or</code>. Since those need to short-circuit (basically do a little
control flow) we aren&rsquo;t ready for them yet.
还不算太糟。让我们继续保持这种势头，搞定相等与比较运算符： <code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>和<code>&gt;=</code>。这涵盖了所有会返回布尔值的运算符，除了逻辑运算符<code>and</code>和<code>or</code>。因为这些运算符需要短路计算（基本上是做一个小小的控制流），我们还没准备好。</p>
<p>Here are the new instructions for those operators:
下面是这些运算符对应的新指令：</p>
<div class="codehilite"><pre class="insert-before">  OP_FALSE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_EQUAL</span>,
  <span class="a">OP_GREATER</span>,
  <span class="a">OP_LESS</span>,
</pre><pre class="insert-after">  OP_ADD,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Wait, only three? What about <code>!=</code>, <code>&lt;=</code>, and <code>&gt;=</code>? We could create instructions
for those too. Honestly, the VM would execute faster if we did, so we <em>should</em>
do that if the goal is performance.
等一下，只有三个？那<code>!=</code>、<code>&lt;=</code>和<code>&gt;=</code>呢？我们也可以为它们创建指令。老实说，如果我们这样做，虚拟机的执行速度会更快。所以如果我们的目标是追求性能，那就<em>应该</em>这样做。</p>
<p>But my main goal is to teach you about bytecode compilers. I want you to start
internalizing the idea that the bytecode instructions don&rsquo;t need to closely
follow the user&rsquo;s source code. The VM has total freedom to use whatever
instruction set and code sequences it wants as long as they have the right
user-visible behavior.
但我的主要目标是教你有关字节码编译器的知识。我想要你开始内化一个想法：字节码指令不需要紧跟用户的源代码。虚拟机可以完全自由地使用它想要的任何指令集和代码序列，只要它们有正确的用户可见的行为。</p>
<p>The expression <code>a != b</code> has the same semantics as <code>!(a == b)</code>, so the compiler
is free to compile the former as if it were the latter. Instead of a dedicated
<code>OP_NOT_EQUAL</code> instruction, it can output an <code>OP_EQUAL</code> followed by an <code>OP_NOT</code>.
Likewise, <code>a &lt;= b</code> is the <span name="same">same</span> as <code>!(a &gt; b)</code> and <code>a &gt;= b</code> is <code>!(a &lt; b)</code>. Thus, we only need three new instructions.
表达式<code>a!=b</code>与<code>!(a==b)</code>具有相同的语义，所以编译器可以自由地编译前者，就好像它是后者一样。它可以输出一条<code>OP_EQUAL</code>指令，之后是一条<code>OP_NOT</code>，而不是一条专用的<code>OP_NOT_EQUAL</code>指令。同样地，<code>a&lt;=b</code>与<code>!(a&gt;b)</code>相同，而<code>a&gt;=b</code>与<code>!(a&lt;b)</code>相同，所以我们只需要三条新指令。</p>
<aside name="same" class="bottom">
<p><em>Is</em> <code>a &lt;= b</code> always the same as <code>!(a &gt; b)</code>? According to <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a>, all
comparison operators return false when an operand is NaN. That means <code>NaN &lt;= 1</code>
is false and <code>NaN &gt; 1</code> is also false. But our desugaring assumes the latter is
always the negation of the former.</p>
<p>For the book, we won&rsquo;t get hung up on this, but these kinds of details will
matter in your real language implementations.</p>
</aside>
<p>Over in the parser, though, we do have six new operators to slot into the parse
table. We use the same <code>binary()</code> parser function from before. Here&rsquo;s the row
for <code>!=</code>:
不过，在解析器中，我们确实有6个新的操作符要加入到解析表中。我们使用与之前相同的<code>binary()</code>解析函数。下面是<code>!=</code>对应的行：</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_BANG]          = {unary,    NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_BANG_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_EQUALITY</span>},
</pre><pre class="insert-after">  [TOKEN_EQUAL]         = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>The remaining five operators are a little farther down in the table.
其余五个运算符在表的最下方。</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_EQUAL]         = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 5 lines</div>
<pre class="insert">  [<span class="a">TOKEN_EQUAL_EQUAL</span>]   = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_EQUALITY</span>},
  [<span class="a">TOKEN_GREATER</span>]       = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
  [<span class="a">TOKEN_GREATER_EQUAL</span>] = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
  [<span class="a">TOKEN_LESS</span>]          = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
  [<span class="a">TOKEN_LESS_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
</pre><pre class="insert-after">  [TOKEN_IDENTIFIER]    = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 5 lines</div>

<p>Inside <code>binary()</code> we already have a switch to generate the right bytecode for
each token type. We add cases for the six new operators.
在<code>binary()</code>中，我们已经有了一个switch语句，为每种标识类型生成正确的字节码。我们为这六个新运算符添加分支。</p>
<div class="codehilite"><pre class="insert-before">  switch (operatorType) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>binary</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">TOKEN_BANG_EQUAL</span>:    <span class="i">emitBytes</span>(<span class="a">OP_EQUAL</span>, <span class="a">OP_NOT</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_EQUAL_EQUAL</span>:   <span class="i">emitByte</span>(<span class="a">OP_EQUAL</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_GREATER</span>:       <span class="i">emitByte</span>(<span class="a">OP_GREATER</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_GREATER_EQUAL</span>: <span class="i">emitBytes</span>(<span class="a">OP_LESS</span>, <span class="a">OP_NOT</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_LESS</span>:          <span class="i">emitByte</span>(<span class="a">OP_LESS</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_LESS_EQUAL</span>:    <span class="i">emitBytes</span>(<span class="a">OP_GREATER</span>, <span class="a">OP_NOT</span>); <span class="k">break</span>;
</pre><pre class="insert-after">    case TOKEN_PLUS:          emitByte(OP_ADD); break;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>binary</em>()</div>

<p>The <code>==</code>, <code>&lt;</code>, and <code>&gt;</code> operators output a single instruction. The others output
a pair of instructions, one to evalute the inverse operation, and then an
<code>OP_NOT</code> to flip the result. Six operators for the price of three instructions!
<code>==</code>、<code>&lt;</code>和<code>&gt;</code> 运算符输出单个指令。其它运算符则输出一对指令，一条用于计算逆运算，然后用<code>OP_NOT</code>来反转结果。仅仅使用三种指令就表达出了六种运算符的效果！</p>
<p>That means over in the VM, our job is simpler. Equality is the most general
operation.
这意味着在虚拟机中，我们的工作更简单了。相等是最普遍的操作。</p>
<div class="codehilite"><pre class="insert-before">      case OP_FALSE: push(BOOL_VAL(false)); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_EQUAL</span>: {
        <span class="t">Value</span> <span class="i">b</span> = <span class="i">pop</span>();
        <span class="t">Value</span> <span class="i">a</span> = <span class="i">pop</span>();
        <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="i">valuesEqual</span>(<span class="i">a</span>, <span class="i">b</span>)));
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_ADD:      BINARY_OP(NUMBER_VAL, +); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>You can evaluate <code>==</code> on any pair of objects, even objects of different types.
There&rsquo;s enough complexity that it makes sense to shunt that logic over to a
separate function. That function always returns a C <code>bool</code>, so we can safely
wrap the result in a <code>BOOL_VAL</code>. The function relates to Values, so it lives
over in the &ldquo;value&rdquo; module.
你可以对任意一对对象执行<code>==</code>，即使这些对象是不同类型的。这有足够的复杂性，所以有必要把这个逻辑分流到一个单独的函数中。这个函数会一个C语言的<code>bool</code>值，所以我们可以安全地把结果包装在一个<code>BOLL_VAL</code>中。这个函数与Value有关，所以它位于“value”模块中。</p>
<div class="codehilite"><pre class="insert-before">} ValueArray;

</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>ValueArray</em></div>
<pre class="insert"><span class="t">bool</span> <span class="i">valuesEqual</span>(<span class="t">Value</span> <span class="i">a</span>, <span class="t">Value</span> <span class="i">b</span>);
</pre><pre class="insert-after">void initValueArray(ValueArray* array);
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>ValueArray</em></div>

<p>And here&rsquo;s the implementation:
下面是实现：</p>
<div class="codehilite"><div class="source-file"><em>value.c</em><br>
add after <em>printValue</em>()</div>
<pre><span class="t">bool</span> <span class="i">valuesEqual</span>(<span class="t">Value</span> <span class="i">a</span>, <span class="t">Value</span> <span class="i">b</span>) {
  <span class="k">if</span> (<span class="i">a</span>.<span class="i">type</span> != <span class="i">b</span>.<span class="i">type</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">switch</span> (<span class="i">a</span>.<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">VAL_BOOL</span>:   <span class="k">return</span> <span class="a">AS_BOOL</span>(<span class="i">a</span>) == <span class="a">AS_BOOL</span>(<span class="i">b</span>);
    <span class="k">case</span> <span class="a">VAL_NIL</span>:    <span class="k">return</span> <span class="k">true</span>;
    <span class="k">case</span> <span class="a">VAL_NUMBER</span>: <span class="k">return</span> <span class="a">AS_NUMBER</span>(<span class="i">a</span>) == <span class="a">AS_NUMBER</span>(<span class="i">b</span>);
    <span class="k">default</span>:         <span class="k">return</span> <span class="k">false</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, add after <em>printValue</em>()</div>

<p>First, we check the types. If the Values have <span
name="equal">different</span> types, they are definitely not equal. Otherwise,
we unwrap the two Values and compare them directly.
首先，我们检查类型。如果两个Value的类型不同，它们肯定不相等。否则，我们就把这两个Value拆装并直接进行比较。</p>
<aside name="equal">
<p>Some languages have &ldquo;implicit conversions&rdquo; where values of different types may
be considered equal if one can be converted to the other&rsquo;s type. For example,
the number 0 is equivalent to the string &ldquo;0&rdquo; in JavaScript. This looseness was a
large enough source of pain that JS added a separate &ldquo;strict equality&rdquo; operator,
<code>===</code>.</p>
<p>PHP considers the strings &ldquo;1&rdquo; and &ldquo;01&rdquo; to be equivalent because both can be
converted to equivalent numbers, though the ultimate reason is because PHP was
designed by a Lovecraftian eldritch god to destroy the mind.</p>
<p>Most dynamically typed languages that have separate integer and floating-point
number types consider values of different number types equal if the numeric
values are the same (so, say, 1.0 is equal to 1), though even that seemingly
innocuous convenience can bite the unwary.</p>
</aside>
<p>For each value type, we have a separate case that handles comparing the value
itself. Given how similar the cases are, you might wonder why we can&rsquo;t simply
<code>memcmp()</code> the two Value structs and be done with it. The problem is that
because of padding and different-sized union fields, a Value contains unused
bits. C gives no guarantee about what is in those, so it&rsquo;s possible that two
equal Values actually differ in memory that isn&rsquo;t used.
对于每一种值类型，我们都有一个单独的case分支来处理值本身的比较。考虑到这些分支的相似性，你可能会想，为什么我们不能简单地对两个Value结构体进行<code>memcmp()</code>，然后就可以了。问题在于，因为填充以及联合体字段的大小不同，Value中会包含无用的比特位。C语言不能保证这些值是什么，所以两个相同的Value在未使用的内存中可能是完全不同的。</p><img src="image/types-of-values/memcmp.png" alt="The memory respresentations of two equal values that differ in unused bytes." />
<p>(You wouldn&rsquo;t believe how much pain I went through before learning this fact.)
(你无法想象在了解这个事实之前我经历了多少痛苦。)</p>
<p>Anyway, as we add more types to clox, this function will grow new cases. For
now, these three are sufficient. The other comparison operators are easier since
they work only on numbers.
总之，随着我们向clox中添加更多的类型，这个函数也会增加更多的case分支。就目前而言，这三个已经足够了。其它的比较运算符更简单，因为它们只处理数字。</p>
<div class="codehilite"><pre class="insert-before">        push(BOOL_VAL(valuesEqual(a, b)));
        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GREATER</span>:  <span class="a">BINARY_OP</span>(<span class="a">BOOL_VAL</span>, &gt;); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_LESS</span>:     <span class="a">BINARY_OP</span>(<span class="a">BOOL_VAL</span>, &lt;); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_ADD:      BINARY_OP(NUMBER_VAL, +); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We already extended the <code>BINARY_OP</code> macro to handle operators that return
non-numeric types. Now we get to use that. We pass in <code>BOOL_VAL</code> since the
result value type is Boolean. Otherwise, it&rsquo;s no different from plus or minus.
我们已经扩展了<code>BINARY_OP</code>宏，来处理返回非数字类型的运算符。现在我们要用到它了。因为结果值类型是布尔型，所以我们传入<code>BOOL_VAL</code>。除此之外，这与加减运算没有区别。</p>
<p>As always, the coda to today&rsquo;s aria is disassembling the new instructions.
与往常一样，今天的咏叹调的尾声是对新指令进行反汇编。</p>
<div class="codehilite"><pre class="insert-before">    case OP_FALSE:
      return simpleInstruction(&quot;OP_FALSE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_EQUAL</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_EQUAL&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_GREATER</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_GREATER&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_LESS</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_LESS&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_ADD:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>With that, our numeric calculator has become something closer to a general
expression evaluator. Fire up clox and type in:
这样一来，我们的数字计算器就变得更接近于一个通用的表达式求值器。启动clox并输入：</p>
<div class="codehilite"><pre>!(<span class="n">5</span> - <span class="n">4</span> &gt; <span class="n">3</span> * <span class="n">2</span> == !<span class="k">nil</span>)
</pre></div>
<p>OK, I&rsquo;ll admit that&rsquo;s maybe not the most <em>useful</em> expression, but we&rsquo;re making
progress. We have one missing built-in type with its own literal form: strings.
Those are much more complex because strings can vary in size. That tiny
difference turns out to have implications so large that we give strings <a href="strings.html">their
very own chapter</a>.
好吧，我承认这可能不是最<em>有用的</em>表达式，但我们正在取得进展。我们还缺少一种自带字面量形式的内置类型：字符串。它们要复杂得多，因为字符串的大小可以不同。这个微小的差异会产生巨大的影响，以至于我们给字符串单独开了一章。
: 在静态类型和动态类型之外，还有第三类：单一类型（<strong>unityped</strong>）。在这种范式中，所有的变量都是一个类型，通常是一个机器寄存器整数。单一类型的语言在今天并不常见，但一些Forth派生语言和BCPL（启发了C的语言）是这样工作的。从这一刻起，clox是单一类型的。
: 这个案例中涵盖了<em>虚拟机中内置支持</em>的每一种值。等到我们在语言中添加类时，用户定义的每个类并不需要在这个枚举中添加对应的条目。对于虚拟机而言，一个类的每个实例都是相同的类型：“instance”。换句话说，这是虚拟机中的“类型”概念，而不是用户的。
: 使用联合体将比特位解释为不同类型是C语言的精髓。它提供了许多巧妙的优化，让你能够以内存安全型语言中不允许的方式对内存中的每个字节进行切分。但它也是非常不安全的，如果你不小心，它就可能会锯掉你的手指。
: 一个聪明的语言黑客给了我一个想法，把“as”作为联合体字段名称，因为当你取出各种值时，读起来感觉很好，就像是强制转换一样。
: 我们可以把标签字段移动到联合体字段之后，但这也没有多大帮助。每当我们创建一个Value数组时（这也是我们对Value的主要内存使用），C编译器都会在每个数值之间插入相同的填充，以保持双精度数对齐。
: 没有<code>AS_NIL</code>宏，因为只有一个<code>nil</code>值，所以一个类型为<code>VAL_NIL</code>的Value不会携带任何额外的数据。
: Lox的错误处理方法是相当……简朴的。所有的错误都是致命的，会立即停止解释器。用户代码无法从错误中恢复。如果Lox是一种真正的语言，这是我首先要补救的事情之一。
: 为什么不直接弹出操作数然后验证它呢？我们可以这么做。在后面的章节中，将操作数留在栈上是很重要的，可以确保在运行过程中触发垃圾收集时，垃圾收集器能够找到它们。我在这里做了同样的事情，主要是出于习惯。
: 如果你在寻找一个C教程，我喜欢<a href="https://www.cs.princeton.edu/~bwk/cbook.html">C程序设计语言</a>，通常被称为“K&amp;R”，以纪念它的作者。它并不完全是最新的，但是写作质量足以弥补这一点。
: 仅仅显示发生错误的那一行并不能提供太多的上下文信息。最后是提供完整的堆栈跟踪，但是我们目前甚至还没有函数调用，所以也没有调用堆栈可以跟踪。
: 你知道可以将宏作为参数传递给宏吗？现在你知道了！
: 我不是在开玩笑，对于某些常量值的专用操作会更快。字节码虚拟机的大部分执行时间都花在读取和解码指令上。对于一个特定的行为，你需要的指令越少、越简单，它就越快。专用于常见操作的短指令是一种典型的优化。<BR>例如，Java字节码指令集中有专门的指令用于加载0.0、1.0、2.0以及从-1到5之间的整数。（考虑到大多数成熟的JVM在执行前都会对字节码进行JIT编译，这最终成为了一种残留的优化）
: 现在我忍不住想弄清楚，对其它类型的值取反意味着什么。<code>nil</code>可能有自己的非值，有点像一个奇怪的伪零。对字符串取反可以，呃……，反转？
: <code>a&lt;=b</code>总是与<code>!(a&gt;b)</code>相同吗？根据IEEE 754标准，当操作数为NaN时，所有的比较运算符都返回假。这意味着<code>NaN &lt;= 1</code>是假的，<code>NaN &gt; 1</code>也是假的。但我们的脱糖操作假定了后者是前者的非值。<BR>在本书中，我们不必纠结于此，但这些细节在你的真正的语言实现中会很重要。
: 有些语言支持“隐式转换”，如果某个类型的值可以转换为另一个类型，那么这两种类型的值就可以被认为是相等的。举例来说，在JavaScript中，数字0等同于字符串“0”。这种松散性导致JS增加了一个单独的“严格相等”运算符，<code>===</code>。<BR>PHP认为字符串“1”和“01”是等价的，因为两者都可以转换成等价的数字，但是最根本的原因在于PHP是由Lovecraftian(译者注：洛夫克拉夫特，克苏鲁之父，可见作者对PHP怨念颇深)的邪神设计的，目的是摧毁人类心智。<BR>大多数具有单独的整数和浮点数类型的动态类型语言认为，如果数值相同，则不同数字类型的值是相等的（所以说，1.0等于1），但即便是这种看似无害的便利，如果一不小心也会让人吃不消。</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>We could reduce our binary operators even further than we did here. Which
other instructions can you eliminate, and how would the compiler cope with
their absence?</p>
</li>
<li>
<p>Conversely, we can improve the speed of our bytecode VM by adding more
specific instructions that correspond to higher-level operations. What
instructions would you define to speed up the kind of user code we added
support for in this chapter?</p>
</li>
</ol>
</div>

    <footer>
      <a href="strings.html" class="next">
        下一节: &ldquo;字符串&rdquo; &rarr;
      </a>
      Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a
        href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy;
        2015&hairsp;&ndash;&hairsp;2021</a>
    </footer>
  </article>

  </div>
  </body>
  </html>
